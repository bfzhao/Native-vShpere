////////////////////////////////////////////////////////////////////////
// Copyright (c) 2011, Bingfeng Zhao . All rights reserved.
// 

#include <vector>
#include <sstream>
#include "vim_browser.h"

namespace vim_browser
{
// convert to string, instace
template <typename T> std::string basic2str(const T& t)
{
	std::stringstream ss;
	ss << std::boolalpha << t;
	return ss.str();
}

// convert to string, pointer
template <typename T> std::string basic2str(T* t)
{
	if (!t)
		return "_unset_";
	std::stringstream ss;
	ss << *t;
	return ss.str();
}

// specialize for xsd_anyType
template <> std::string basic2str(xsd__anyType* t)
{
	if (!t)
		return "_unset_";
	std::stringstream ss;
	ss << std::boolalpha << t->__item;
	return ss.str();
}

// specialize for char*
template <> std::string basic2str(char* t)
{
	if (!t)
		return "_unset_";
	std::stringstream ss;
	ss << t;
	return ss.str();
}

// specialize for bool*
template <> std::string basic2str(bool* t)
{
	if (!t)
		return "_unset_";
	std::stringstream ss;
	ss << std::boolalpha <<  *t;
	return ss.str();
}

// convert to string, C-style array
template <typename T> std::string a2s_basic(const T* t, int size)
{
	if (!t)
		return "_unset_";
	std::stringstream ss;
	ss << '@';
	for (int i = 0; i < size; ++i)
	{
		if (i != 0)
			ss << '|';
		ss << std::boolalpha << t[i];
	}
	return ss.str();
}

// convert to string, STL-style array
template <typename T> std::string a2s_basic(const std::vector<T>& t)
{
	std::stringstream ss;
	ss << '@';
	for (size_t i = 0; i < t.size(); ++i)
	{
		if (i != 0)
			ss << '|';
		ss << std::boolalpha << t[i];
	}
	return ss.str();
}

// convert to string, C-style object array
template <typename T> std::string a2s_object(const T* t, int size)
{
	if (!t)
		return "_unset_";
	std::stringstream ss;
	ss << '@';
	for (int i = 0; i < size; ++i)
	{
		if (i != 0)
			ss << '|';
		ss << std::boolalpha << handle_obj(*t[i]);
	}
	return ss.str();
}

// convert to string, STL-style object array
template <typename T> std::string a2s_object(const std::vector<T>& t)
{
	std::stringstream ss;
	ss << '@';
	for (size_t i = 0; i < t.size(); ++i)
	{
		if (i != 0)
			ss << '|';
		ss << std::boolalpha << handle_obj(t[i]);
	}
	return ss.str();
}

// version check routine
extern bool is_higher_version_than(const char* ver);

void update_member(pf_update update, const std::string& name, 
	const std::string& type, const std::string& value, void* context)
{
	update("Name", name, context);
	update("Type", type, context);
	update("Value", value, context);
}

void update_member_with_version(pf_update update, const std::string& name,
	const std::string& type, const std::string& value, void* context, const char* ver)
{
	update("Name", name, context);
	update("Type", type, context);
	if (is_higher_version_than(ver))
		update("Value", value, context);
	else
		update("Value", "_unsupported_", context);
}

void AboutInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AboutInfo", context);
	update_member(update, "apiType", "xsd:string", basic2str(_obj.apiType), context);
	update_member(update, "apiVersion", "xsd:string", basic2str(_obj.apiVersion), context);
	update_member(update, "build", "xsd:string", basic2str(_obj.build), context);
	update_member(update, "fullName", "xsd:string", basic2str(_obj.fullName), context);
	update_member_with_version(update, "instanceUuid", "xsd:string", basic2str(_obj.instanceUuid), context, "4.0");
	update_member_with_version(update, "licenseProductName", "xsd:string", basic2str(_obj.licenseProductName), context, "4.0");
	update_member_with_version(update, "licenseProductVersion", "xsd:string", basic2str(_obj.licenseProductVersion), context, "4.0");
	update_member(update, "localeBuild", "xsd:string", basic2str(_obj.localeBuild), context);
	update_member(update, "localeVersion", "xsd:string", basic2str(_obj.localeVersion), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "osType", "xsd:string", basic2str(_obj.osType), context);
	update_member(update, "productLineId", "xsd:string", basic2str(_obj.productLineId), context);
	update_member(update, "vendor", "xsd:string", basic2str(_obj.vendor), context);
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AboutInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AccountCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AccountCreatedEvent", context);
	update_member(update, "group", "xsd:boolean", basic2str(_obj.group), context);
	update_member(update, "spec", "HostAccountSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AccountCreatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.spec)
			return new HostAccountSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void AccountRemovedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AccountRemovedEvent", context);
	update_member(update, "account", "xsd:string", basic2str(_obj.account), context);
	update_member(update, "group", "xsd:boolean", basic2str(_obj.group), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AccountRemovedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AccountUpdatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AccountUpdatedEvent", context);
	update_member(update, "group", "xsd:boolean", basic2str(_obj.group), context);
	update_member(update, "spec", "HostAccountSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AccountUpdatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.spec)
			return new HostAccountSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void Action_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Action", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* Action_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ActiveDirectoryProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ActiveDirectoryProfile", context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ActiveDirectoryProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AdminPasswordNotChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AdminPasswordNotChangedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AdminPasswordNotChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AfterStartupTaskScheduler_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AfterStartupTaskScheduler", context);
	update_member(update, "minute", "xsd:int", basic2str(_obj.minute), context);
	update("Base", "TaskScheduler", context);
	TaskScheduler_closure(dynamic_cast<const vw1__TaskScheduler&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AfterStartupTaskScheduler_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AlarmAcknowledgedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmAcknowledgedEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update_member(update, "source", "ManagedEntityEventArgument", handle_obj_ptr(_obj.source), context);
	update("Base", "AlarmEvent", context);
	AlarmEvent_closure(dynamic_cast<const vw1__AlarmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmAcknowledgedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	case 1:
		if (_obj.source)
			return new ManagedEntityEventArgument_closure(*_obj.source);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void AlarmAction_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmAction", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmAction_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AlarmActionTriggeredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmActionTriggeredEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update_member(update, "source", "ManagedEntityEventArgument", handle_obj_ptr(_obj.source), context);
	update("Base", "AlarmEvent", context);
	AlarmEvent_closure(dynamic_cast<const vw1__AlarmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmActionTriggeredEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	case 1:
		if (_obj.source)
			return new ManagedEntityEventArgument_closure(*_obj.source);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void AlarmClearedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmClearedEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update_member(update, "from", "xsd:string", basic2str(_obj.from), context);
	update_member(update, "source", "ManagedEntityEventArgument", handle_obj_ptr(_obj.source), context);
	update("Base", "AlarmEvent", context);
	AlarmEvent_closure(dynamic_cast<const vw1__AlarmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmClearedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	case 2:
		if (_obj.source)
			return new ManagedEntityEventArgument_closure(*_obj.source);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmEvent_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void AlarmCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmCreatedEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update("Base", "AlarmEvent", context);
	AlarmEvent_closure(dynamic_cast<const vw1__AlarmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmCreatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void AlarmDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmDescription", context);
	update_member(update, "action", "TypeDescription[]", a2s_object(_obj.action, _obj.__sizeaction), context);
	update_member_with_version(update, "datastoreConnectionState", "ElementDescription[]", a2s_object(_obj.datastoreConnectionState, _obj.__sizedatastoreConnectionState), context, "4.0");
	update_member(update, "entityStatus", "ElementDescription[]", a2s_object(_obj.entityStatus, _obj.__sizeentityStatus), context);
	update_member(update, "expr", "TypeDescription[]", a2s_object(_obj.expr, _obj.__sizeexpr), context);
	update_member(update, "hostSystemConnectionState", "ElementDescription[]", a2s_object(_obj.hostSystemConnectionState, _obj.__sizehostSystemConnectionState), context);
	update_member_with_version(update, "hostSystemPowerState", "ElementDescription[]", a2s_object(_obj.hostSystemPowerState, _obj.__sizehostSystemPowerState), context, "4.0");
	update_member(update, "metricOperator", "ElementDescription[]", a2s_object(_obj.metricOperator, _obj.__sizemetricOperator), context);
	update_member(update, "stateOperator", "ElementDescription[]", a2s_object(_obj.stateOperator, _obj.__sizestateOperator), context);
	update_member_with_version(update, "virtualMachineGuestHeartbeatStatus", "ElementDescription[]", a2s_object(_obj.virtualMachineGuestHeartbeatStatus, _obj.__sizevirtualMachineGuestHeartbeatStatus), context, "4.0");
	update_member(update, "virtualMachinePowerState", "ElementDescription[]", a2s_object(_obj.virtualMachinePowerState, _obj.__sizevirtualMachinePowerState), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmDescription_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeaction)
				return new TypeDescription_closure(*_obj.action[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedatastoreConnectionState)
				return new ElementDescription_closure(*_obj.datastoreConnectionState[i]);
			else
				return 0;
		}
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeentityStatus)
				return new ElementDescription_closure(*_obj.entityStatus[i]);
			else
				return 0;
		}
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeexpr)
				return new TypeDescription_closure(*_obj.expr[i]);
			else
				return 0;
		}
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehostSystemConnectionState)
				return new ElementDescription_closure(*_obj.hostSystemConnectionState[i]);
			else
				return 0;
		}
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehostSystemPowerState)
				return new ElementDescription_closure(*_obj.hostSystemPowerState[i]);
			else
				return 0;
		}
	case 6:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemetricOperator)
				return new ElementDescription_closure(*_obj.metricOperator[i]);
			else
				return 0;
		}
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizestateOperator)
				return new ElementDescription_closure(*_obj.stateOperator[i]);
			else
				return 0;
		}
	case 8:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevirtualMachineGuestHeartbeatStatus)
				return new ElementDescription_closure(*_obj.virtualMachineGuestHeartbeatStatus[i]);
			else
				return 0;
		}
	case 9:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevirtualMachinePowerState)
				return new ElementDescription_closure(*_obj.virtualMachinePowerState[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 10) << 16) + arr_index);
	}
	return 0;
}

void AlarmEmailCompletedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmEmailCompletedEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update_member(update, "to", "xsd:string", basic2str(_obj.to), context);
	update("Base", "AlarmEvent", context);
	AlarmEvent_closure(dynamic_cast<const vw1__AlarmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmEmailCompletedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void AlarmEmailFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmEmailFailedEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update_member(update, "to", "xsd:string", basic2str(_obj.to), context);
	update("Base", "AlarmEvent", context);
	AlarmEvent_closure(dynamic_cast<const vw1__AlarmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmEmailFailedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	case 1:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmEvent_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void AlarmEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmEvent", context);
	update_member(update, "alarm", "AlarmEventArgument", handle_obj_ptr(_obj.alarm), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.alarm)
			return new AlarmEventArgument_closure(*_obj.alarm);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return Event_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void AlarmEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmEventArgument", context);
	update_member(update, "alarm", "Alarm", handle_obj_ptr(_obj.alarm), context);
	update("Base", "EntityEventArgument", context);
	EntityEventArgument_closure(dynamic_cast<const vw1__EntityEventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmEventArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.alarm? 
			get_closure_from_mor(Alarm(_obj.alarm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return EntityEventArgument_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void AlarmExpression_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmExpression", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmExpression_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AlarmInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmInfo", context);
	update_member(update, "alarm", "Alarm", handle_obj_ptr(_obj.alarm), context);
	update_member(update, "creationEventId", "xsd:int", basic2str(_obj.creationEventId), context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "lastModifiedTime", "xsd:dateTime", basic2str(_obj.lastModifiedTime), context);
	update_member(update, "lastModifiedUser", "xsd:string", basic2str(_obj.lastModifiedUser), context);
	update("Base", "AlarmSpec", context);
	AlarmSpec_closure(dynamic_cast<const vw1__AlarmSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.alarm? 
			get_closure_from_mor(Alarm(_obj.alarm)) : 0;
	case 2:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmSpec_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void AlarmReconfiguredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmReconfiguredEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update("Base", "AlarmEvent", context);
	AlarmEvent_closure(dynamic_cast<const vw1__AlarmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmReconfiguredEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void AlarmRemovedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmRemovedEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update("Base", "AlarmEvent", context);
	AlarmEvent_closure(dynamic_cast<const vw1__AlarmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmRemovedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void AlarmScriptCompleteEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmScriptCompleteEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update_member(update, "script", "xsd:string", basic2str(_obj.script), context);
	update("Base", "AlarmEvent", context);
	AlarmEvent_closure(dynamic_cast<const vw1__AlarmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmScriptCompleteEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void AlarmScriptFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmScriptFailedEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update_member(update, "script", "xsd:string", basic2str(_obj.script), context);
	update("Base", "AlarmEvent", context);
	AlarmEvent_closure(dynamic_cast<const vw1__AlarmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmScriptFailedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	case 1:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmEvent_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void AlarmSetting_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmSetting", context);
	update_member(update, "reportingFrequency", "xsd:int", basic2str(_obj.reportingFrequency), context);
	update_member(update, "toleranceRange", "xsd:int", basic2str(_obj.toleranceRange), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmSetting_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AlarmSnmpCompletedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmSnmpCompletedEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update("Base", "AlarmEvent", context);
	AlarmEvent_closure(dynamic_cast<const vw1__AlarmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmSnmpCompletedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void AlarmSnmpFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmSnmpFailedEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "AlarmEvent", context);
	AlarmEvent_closure(dynamic_cast<const vw1__AlarmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmSnmpFailedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	case 1:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void AlarmSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmSpec", context);
	update_member(update, "action", "AlarmAction", handle_obj_ptr(_obj.action), context);
	update_member_with_version(update, "actionFrequency", "xsd:int", basic2str(_obj.actionFrequency), context, "4.0");
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "expression", "AlarmExpression", handle_obj_ptr(_obj.expression), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "setting", "AlarmSetting", handle_obj_ptr(_obj.setting), context);
	update_member_with_version(update, "systemName", "xsd:string", basic2str(_obj.systemName), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.action)
			return new AlarmAction_closure(*_obj.action);
		else
			return 0;
	case 4:
		if (_obj.expression)
			return new AlarmExpression_closure(*_obj.expression);
		else
			return 0;
	case 6:
		if (_obj.setting)
			return new AlarmSetting_closure(*_obj.setting);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void AlarmState_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmState", context);
	update_member_with_version(update, "acknowledged", "xsd:boolean", basic2str(_obj.acknowledged), context, "4.0");
	update_member_with_version(update, "acknowledgedByUser", "xsd:string", basic2str(_obj.acknowledgedByUser), context, "4.0");
	update_member_with_version(update, "acknowledgedTime", "xsd:dateTime", basic2str(_obj.acknowledgedTime), context, "4.0");
	update_member(update, "alarm", "Alarm", handle_obj_ptr(_obj.alarm), context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "overallStatus", "ManagedEntityStatus", handle_obj(_obj.overallStatus), context);
	update_member(update, "time", "xsd:dateTime", basic2str(_obj.time), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmState_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		return _obj.alarm? 
			get_closure_from_mor(Alarm(_obj.alarm)) : 0;
	case 4:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void AlarmStatusChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmStatusChangedEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update_member(update, "from", "xsd:string", basic2str(_obj.from), context);
	update_member(update, "source", "ManagedEntityEventArgument", handle_obj_ptr(_obj.source), context);
	update_member(update, "to", "xsd:string", basic2str(_obj.to), context);
	update("Base", "AlarmEvent", context);
	AlarmEvent_closure(dynamic_cast<const vw1__AlarmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmStatusChangedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	case 2:
		if (_obj.source)
			return new ManagedEntityEventArgument_closure(*_obj.source);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmEvent_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void AlarmTriggeringAction_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmTriggeringAction", context);
	update_member(update, "action", "Action", handle_obj_ptr(_obj.action), context);
	update_member(update, "green2yellow", "xsd:boolean", basic2str(_obj.green2yellow), context);
	update_member(update, "red2yellow", "xsd:boolean", basic2str(_obj.red2yellow), context);
	update_member_with_version(update, "transitionSpecs", "AlarmTriggeringActionTransitionSpec[]", a2s_object(_obj.transitionSpecs, _obj.__sizetransitionSpecs), context, "4.0");
	update_member(update, "yellow2green", "xsd:boolean", basic2str(_obj.yellow2green), context);
	update_member(update, "yellow2red", "xsd:boolean", basic2str(_obj.yellow2red), context);
	update("Base", "AlarmAction", context);
	AlarmAction_closure(dynamic_cast<const vw1__AlarmAction&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmTriggeringAction_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.action)
			return new Action_closure(*_obj.action);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizetransitionSpecs)
				return new AlarmTriggeringActionTransitionSpec_closure(*_obj.transitionSpecs[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return AlarmAction_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void AlarmTriggeringActionTransitionSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmTriggeringActionTransitionSpec", context);
	update_member(update, "finalState", "ManagedEntityStatus", handle_obj(_obj.finalState), context);
	update_member(update, "repeats", "xsd:boolean", basic2str(_obj.repeats), context);
	update_member(update, "startState", "ManagedEntityStatus", handle_obj(_obj.startState), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlarmTriggeringActionTransitionSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AllVirtualMachinesLicensedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AllVirtualMachinesLicensedEvent", context);
	update("Base", "LicenseEvent", context);
	LicenseEvent_closure(dynamic_cast<const vw1__LicenseEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AllVirtualMachinesLicensedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AlreadyAuthenticatedSessionEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlreadyAuthenticatedSessionEvent", context);
	update("Base", "SessionEvent", context);
	SessionEvent_closure(dynamic_cast<const vw1__SessionEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlreadyAuthenticatedSessionEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AndAlarmExpression_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AndAlarmExpression", context);
	update_member(update, "expression", "AlarmExpression[]", a2s_object(_obj.expression, _obj.__sizeexpression), context);
	update("Base", "AlarmExpression", context);
	AlarmExpression_closure(dynamic_cast<const vw1__AlarmExpression&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AndAlarmExpression_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeexpression)
				return new AlarmExpression_closure(*_obj.expression[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return AlarmExpression_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void AnswerFile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AnswerFile", context);
	update_member(update, "createdTime", "xsd:dateTime", basic2str(_obj.createdTime), context);
	update_member(update, "modifiedTime", "xsd:dateTime", basic2str(_obj.modifiedTime), context);
	update_member(update, "userInput", "ProfileDeferredPolicyOptionParameter[]", a2s_object(_obj.userInput, _obj.__sizeuserInput), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AnswerFile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeuserInput)
				return new ProfileDeferredPolicyOptionParameter_closure(*_obj.userInput[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void AnswerFileCreateSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AnswerFileCreateSpec", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AnswerFileCreateSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AnswerFileOptionsCreateSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AnswerFileOptionsCreateSpec", context);
	update_member(update, "userInput", "ProfileDeferredPolicyOptionParameter[]", a2s_object(_obj.userInput, _obj.__sizeuserInput), context);
	update("Base", "AnswerFileCreateSpec", context);
	AnswerFileCreateSpec_closure(dynamic_cast<const vw1__AnswerFileCreateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AnswerFileOptionsCreateSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeuserInput)
				return new ProfileDeferredPolicyOptionParameter_closure(*_obj.userInput[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return AnswerFileCreateSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void AnswerFileSerializedCreateSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AnswerFileSerializedCreateSpec", context);
	update_member(update, "answerFileConfigString", "xsd:string", basic2str(_obj.answerFileConfigString), context);
	update("Base", "AnswerFileCreateSpec", context);
	AnswerFileCreateSpec_closure(dynamic_cast<const vw1__AnswerFileCreateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AnswerFileSerializedCreateSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AnswerFileStatusError_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AnswerFileStatusError", context);
	update_member(update, "errMsg", "LocalizableMessage", handle_obj_ptr(_obj.errMsg), context);
	update_member(update, "userInputPath", "ProfilePropertyPath", handle_obj_ptr(_obj.userInputPath), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AnswerFileStatusError_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.errMsg)
			return new LocalizableMessage_closure(*_obj.errMsg);
		else
			return 0;
	case 1:
		if (_obj.userInputPath)
			return new ProfilePropertyPath_closure(*_obj.userInputPath);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void AnswerFileStatusResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AnswerFileStatusResult", context);
	update_member(update, "checkedTime", "xsd:dateTime", basic2str(_obj.checkedTime), context);
	update_member(update, "error", "AnswerFileStatusError[]", a2s_object(_obj.error, _obj.__sizeerror), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "status", "xsd:string", basic2str(_obj.status), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AnswerFileStatusResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeerror)
				return new AnswerFileStatusError_closure(*_obj.error[i]);
			else
				return 0;
		}
	case 2:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void AnswerFileUpdateFailure_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AnswerFileUpdateFailure", context);
	update_member(update, "errMsg", "LocalizableMessage", handle_obj_ptr(_obj.errMsg), context);
	update_member(update, "userInputPath", "ProfilePropertyPath", handle_obj_ptr(_obj.userInputPath), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AnswerFileUpdateFailure_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.errMsg)
			return new LocalizableMessage_closure(*_obj.errMsg);
		else
			return 0;
	case 1:
		if (_obj.userInputPath)
			return new ProfilePropertyPath_closure(*_obj.userInputPath);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ApplyProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ApplyProfile", context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "policy", "ProfilePolicy[]", a2s_object(_obj.policy, _obj.__sizepolicy), context);
	update_member_with_version(update, "profileTypeName", "xsd:string", basic2str(_obj.profileTypeName), context, "5.0");
	update_member_with_version(update, "profileVersion", "xsd:string", basic2str(_obj.profileVersion), context, "5.0");
	update_member_with_version(update, "property", "ProfileApplyProfileProperty[]", a2s_object(_obj.property, _obj.__sizeproperty), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ApplyProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepolicy)
				return new ProfilePolicy_closure(*_obj.policy[i]);
			else
				return 0;
		}
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeproperty)
				return new ProfileApplyProfileProperty_closure(*_obj.property[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void ApplyStorageRecommendationResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ApplyStorageRecommendationResult", context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ApplyStorageRecommendationResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ArrayUpdateSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ArrayUpdateSpec", context);
	update_member(update, "operation", "ArrayUpdateOperation", handle_obj(_obj.operation), context);
	update_member(update, "removeKey", "xsd:anyType", basic2str(_obj.removeKey), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ArrayUpdateSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AuthenticationProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AuthenticationProfile", context);
	update_member(update, "activeDirectory", "ActiveDirectoryProfile", handle_obj_ptr(_obj.activeDirectory), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AuthenticationProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.activeDirectory)
			return new ActiveDirectoryProfile_closure(*_obj.activeDirectory);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ApplyProfile_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void AuthorizationDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AuthorizationDescription", context);
	update_member(update, "privilege", "ElementDescription[]", a2s_object(_obj.privilege, _obj.__sizeprivilege), context);
	update_member(update, "privilegeGroup", "ElementDescription[]", a2s_object(_obj.privilegeGroup, _obj.__sizeprivilegeGroup), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AuthorizationDescription_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeprivilege)
				return new ElementDescription_closure(*_obj.privilege[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeprivilegeGroup)
				return new ElementDescription_closure(*_obj.privilegeGroup[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void AuthorizationEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AuthorizationEvent", context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AuthorizationEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AuthorizationPrivilege_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AuthorizationPrivilege", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "onParent", "xsd:boolean", basic2str(_obj.onParent), context);
	update_member(update, "privGroupName", "xsd:string", basic2str(_obj.privGroupName), context);
	update_member(update, "privId", "xsd:string", basic2str(_obj.privId), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AuthorizationPrivilege_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AuthorizationRole_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AuthorizationRole", context);
	update_member(update, "info", "Description", handle_obj_ptr(_obj.info), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "privilege", "xsd:string[]", a2s_basic(*_obj.privilege, _obj.__sizeprivilege), context);
	update_member(update, "roleId", "xsd:int", basic2str(_obj.roleId), context);
	update_member(update, "system", "xsd:boolean", basic2str(_obj.system), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AuthorizationRole_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.info)
			return new Description_closure(*_obj.info);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void AutoStartDefaults_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AutoStartDefaults", context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "startDelay", "xsd:int", basic2str(_obj.startDelay), context);
	update_member(update, "stopAction", "xsd:string", basic2str(_obj.stopAction), context);
	update_member(update, "stopDelay", "xsd:int", basic2str(_obj.stopDelay), context);
	update_member(update, "waitForHeartbeat", "xsd:boolean", basic2str(_obj.waitForHeartbeat), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AutoStartDefaults_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AutoStartPowerInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AutoStartPowerInfo", context);
	update_member(update, "key", "VirtualMachine", handle_obj_ptr(_obj.key), context);
	update_member(update, "startAction", "xsd:string", basic2str(_obj.startAction), context);
	update_member(update, "startDelay", "xsd:int", basic2str(_obj.startDelay), context);
	update_member(update, "startOrder", "xsd:int", basic2str(_obj.startOrder), context);
	update_member(update, "stopAction", "xsd:string", basic2str(_obj.stopAction), context);
	update_member(update, "stopDelay", "xsd:int", basic2str(_obj.stopDelay), context);
	update_member(update, "waitForHeartbeat", "AutoStartWaitHeartbeatSetting", handle_obj(_obj.waitForHeartbeat), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AutoStartPowerInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.key? 
			get_closure_from_mor(VirtualMachine(_obj.key)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void BadUsernameSessionEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "BadUsernameSessionEvent", context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update("Base", "SessionEvent", context);
	SessionEvent_closure(dynamic_cast<const vw1__SessionEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* BadUsernameSessionEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void BoolOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "BoolOption", context);
	update_member(update, "defaultValue", "xsd:boolean", basic2str(_obj.defaultValue), context);
	update_member(update, "supported", "xsd:boolean", basic2str(_obj.supported), context);
	update("Base", "OptionType", context);
	OptionType_closure(dynamic_cast<const vw1__OptionType&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* BoolOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void BoolPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "BoolPolicy", context);
	update_member(update, "value", "xsd:boolean", basic2str(_obj.value), context);
	update("Base", "InheritablePolicy", context);
	InheritablePolicy_closure(dynamic_cast<const vw1__InheritablePolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* BoolPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CanceledHostOperationEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CanceledHostOperationEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CanceledHostOperationEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void Capability_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Capability", context);
	update_member(update, "multiHostSupported", "xsd:boolean", basic2str(_obj.multiHostSupported), context);
	update_member(update, "provisioningSupported", "xsd:boolean", basic2str(_obj.provisioningSupported), context);
	update_member_with_version(update, "supportedEVCMode", "EVCMode[]", a2s_object(_obj.supportedEVCMode, _obj.__sizesupportedEVCMode), context, "4.0");
	update_member_with_version(update, "userShellAccessSupported", "xsd:boolean", basic2str(_obj.userShellAccessSupported), context, "2.5");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* Capability_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesupportedEVCMode)
				return new EVCMode_closure(*_obj.supportedEVCMode[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void CheckResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CheckResult", context);
	update_member(update, "error", "LocalizedMethodFault[]", a2s_object(_obj.error, _obj.__sizeerror), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update_member(update, "warning", "LocalizedMethodFault[]", a2s_object(_obj.warning, _obj.__sizewarning), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CheckResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeerror)
				return new LocalizedMethodFault_closure(*_obj.error[i]);
			else
				return 0;
		}
	case 1:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	case 2:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizewarning)
				return new LocalizedMethodFault_closure(*_obj.warning[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void ChoiceOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ChoiceOption", context);
	update_member(update, "choiceInfo", "ElementDescription[]", a2s_object(_obj.choiceInfo, _obj.__sizechoiceInfo), context);
	update_member(update, "defaultIndex", "xsd:int", basic2str(_obj.defaultIndex), context);
	update("Base", "OptionType", context);
	OptionType_closure(dynamic_cast<const vw1__OptionType&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ChoiceOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizechoiceInfo)
				return new ElementDescription_closure(*_obj.choiceInfo[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return OptionType_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterAction_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterAction", context);
	update_member(update, "target", "ManagedObjectReference", handle_obj_ptr(_obj.target), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterAction_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.target)
			return new ManagedObjectReference_closure(*_obj.target);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterActionHistory_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterActionHistory", context);
	update_member(update, "action", "ClusterAction", handle_obj_ptr(_obj.action), context);
	update_member(update, "time", "xsd:dateTime", basic2str(_obj.time), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterActionHistory_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.action)
			return new ClusterAction_closure(*_obj.action);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterAffinityRuleSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterAffinityRuleSpec", context);
	update_member(update, "vm", "VirtualMachine[]", a2s_object(_obj.vm, _obj.__sizevm), context);
	update("Base", "ClusterRuleInfo", context);
	ClusterRuleInfo_closure(dynamic_cast<const vw1__ClusterRuleInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterAffinityRuleSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevm)
				return new VirtualMachine_closure(_obj.vm[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ClusterRuleInfo_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterAntiAffinityRuleSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterAntiAffinityRuleSpec", context);
	update_member(update, "vm", "VirtualMachine[]", a2s_object(_obj.vm, _obj.__sizevm), context);
	update("Base", "ClusterRuleInfo", context);
	ClusterRuleInfo_closure(dynamic_cast<const vw1__ClusterRuleInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterAntiAffinityRuleSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevm)
				return new VirtualMachine_closure(_obj.vm[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ClusterRuleInfo_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterAttemptedVmInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterAttemptedVmInfo", context);
	update_member(update, "task", "Task", handle_obj_ptr(_obj.task), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterAttemptedVmInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.task? 
			get_closure_from_mor(Task(_obj.task)) : 0;
	case 1:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterComplianceCheckedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterComplianceCheckedEvent", context);
	update_member(update, "profile", "ProfileEventArgument", handle_obj_ptr(_obj.profile), context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterComplianceCheckedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.profile)
			return new ProfileEventArgument_closure(*_obj.profile);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ClusterEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterComputeResourceSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterComputeResourceSummary", context);
	update_member_with_version(update, "admissionControlInfo", "ClusterDasAdmissionControlInfo", handle_obj_ptr(_obj.admissionControlInfo), context, "4.0");
	update_member_with_version(update, "currentBalance", "xsd:int", basic2str(_obj.currentBalance), context, "4.0");
	update_member_with_version(update, "currentEVCModeKey", "xsd:string", basic2str(_obj.currentEVCModeKey), context, "4.0");
	update_member(update, "currentFailoverLevel", "xsd:int", basic2str(_obj.currentFailoverLevel), context);
	update_member_with_version(update, "dasData", "ClusterDasData", handle_obj_ptr(_obj.dasData), context, "5.0");
	update_member(update, "numVmotions", "xsd:int", basic2str(_obj.numVmotions), context);
	update_member_with_version(update, "targetBalance", "xsd:int", basic2str(_obj.targetBalance), context, "4.0");
	update("Base", "ComputeResourceSummary", context);
	ComputeResourceSummary_closure(dynamic_cast<const vw1__ComputeResourceSummary&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterComputeResourceSummary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.admissionControlInfo)
			return new ClusterDasAdmissionControlInfo_closure(*_obj.admissionControlInfo);
		else
			return 0;
	case 4:
		if (_obj.dasData)
			return new ClusterDasData_closure(*_obj.dasData);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ComputeResourceSummary_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void ClusterConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterConfigInfo", context);
	update_member(update, "dasConfig", "ClusterDasConfigInfo", handle_obj_ptr(_obj.dasConfig), context);
	update_member(update, "dasVmConfig", "ClusterDasVmConfigInfo[]", a2s_object(_obj.dasVmConfig, _obj.__sizedasVmConfig), context);
	update_member(update, "drsConfig", "ClusterDrsConfigInfo", handle_obj_ptr(_obj.drsConfig), context);
	update_member(update, "drsVmConfig", "ClusterDrsVmConfigInfo[]", a2s_object(_obj.drsVmConfig, _obj.__sizedrsVmConfig), context);
	update_member(update, "rule", "ClusterRuleInfo[]", a2s_object(_obj.rule, _obj.__sizerule), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.dasConfig)
			return new ClusterDasConfigInfo_closure(*_obj.dasConfig);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedasVmConfig)
				return new ClusterDasVmConfigInfo_closure(*_obj.dasVmConfig[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.drsConfig)
			return new ClusterDrsConfigInfo_closure(*_obj.drsConfig);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedrsVmConfig)
				return new ClusterDrsVmConfigInfo_closure(*_obj.drsVmConfig[i]);
			else
				return 0;
		}
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerule)
				return new ClusterRuleInfo_closure(*_obj.rule[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void ClusterConfigInfoEx_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterConfigInfoEx", context);
	update_member(update, "dasConfig", "ClusterDasConfigInfo", handle_obj_ptr(_obj.dasConfig), context);
	update_member(update, "dasVmConfig", "ClusterDasVmConfigInfo[]", a2s_object(_obj.dasVmConfig, _obj.__sizedasVmConfig), context);
	update_member(update, "dpmConfigInfo", "ClusterDpmConfigInfo", handle_obj_ptr(_obj.dpmConfigInfo), context);
	update_member(update, "dpmHostConfig", "ClusterDpmHostConfigInfo[]", a2s_object(_obj.dpmHostConfig, _obj.__sizedpmHostConfig), context);
	update_member(update, "drsConfig", "ClusterDrsConfigInfo", handle_obj_ptr(_obj.drsConfig), context);
	update_member(update, "drsVmConfig", "ClusterDrsVmConfigInfo[]", a2s_object(_obj.drsVmConfig, _obj.__sizedrsVmConfig), context);
	update_member_with_version(update, "group", "ClusterGroupInfo[]", a2s_object(_obj.group, _obj.__sizegroup), context, "4.1");
	update_member(update, "rule", "ClusterRuleInfo[]", a2s_object(_obj.rule, _obj.__sizerule), context);
	update("Base", "ComputeResourceConfigInfo", context);
	ComputeResourceConfigInfo_closure(dynamic_cast<const vw1__ComputeResourceConfigInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterConfigInfoEx_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.dasConfig)
			return new ClusterDasConfigInfo_closure(*_obj.dasConfig);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedasVmConfig)
				return new ClusterDasVmConfigInfo_closure(*_obj.dasVmConfig[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.dpmConfigInfo)
			return new ClusterDpmConfigInfo_closure(*_obj.dpmConfigInfo);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedpmHostConfig)
				return new ClusterDpmHostConfigInfo_closure(*_obj.dpmHostConfig[i]);
			else
				return 0;
		}
	case 4:
		if (_obj.drsConfig)
			return new ClusterDrsConfigInfo_closure(*_obj.drsConfig);
		else
			return 0;
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedrsVmConfig)
				return new ClusterDrsVmConfigInfo_closure(*_obj.drsVmConfig[i]);
			else
				return 0;
		}
	case 6:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizegroup)
				return new ClusterGroupInfo_closure(*_obj.group[i]);
			else
				return 0;
		}
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerule)
				return new ClusterRuleInfo_closure(*_obj.rule[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ComputeResourceConfigInfo_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void ClusterConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterConfigSpec", context);
	update_member(update, "dasConfig", "ClusterDasConfigInfo", handle_obj_ptr(_obj.dasConfig), context);
	update_member(update, "dasVmConfigSpec", "ClusterDasVmConfigSpec[]", a2s_object(_obj.dasVmConfigSpec, _obj.__sizedasVmConfigSpec), context);
	update_member(update, "drsConfig", "ClusterDrsConfigInfo", handle_obj_ptr(_obj.drsConfig), context);
	update_member(update, "drsVmConfigSpec", "ClusterDrsVmConfigSpec[]", a2s_object(_obj.drsVmConfigSpec, _obj.__sizedrsVmConfigSpec), context);
	update_member(update, "rulesSpec", "ClusterRuleSpec[]", a2s_object(_obj.rulesSpec, _obj.__sizerulesSpec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.dasConfig)
			return new ClusterDasConfigInfo_closure(*_obj.dasConfig);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedasVmConfigSpec)
				return new ClusterDasVmConfigSpec_closure(*_obj.dasVmConfigSpec[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.drsConfig)
			return new ClusterDrsConfigInfo_closure(*_obj.drsConfig);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedrsVmConfigSpec)
				return new ClusterDrsVmConfigSpec_closure(*_obj.drsVmConfigSpec[i]);
			else
				return 0;
		}
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerulesSpec)
				return new ClusterRuleSpec_closure(*_obj.rulesSpec[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void ClusterConfigSpecEx_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterConfigSpecEx", context);
	update_member(update, "dasConfig", "ClusterDasConfigInfo", handle_obj_ptr(_obj.dasConfig), context);
	update_member(update, "dasVmConfigSpec", "ClusterDasVmConfigSpec[]", a2s_object(_obj.dasVmConfigSpec, _obj.__sizedasVmConfigSpec), context);
	update_member(update, "dpmConfig", "ClusterDpmConfigInfo", handle_obj_ptr(_obj.dpmConfig), context);
	update_member(update, "dpmHostConfigSpec", "ClusterDpmHostConfigSpec[]", a2s_object(_obj.dpmHostConfigSpec, _obj.__sizedpmHostConfigSpec), context);
	update_member(update, "drsConfig", "ClusterDrsConfigInfo", handle_obj_ptr(_obj.drsConfig), context);
	update_member(update, "drsVmConfigSpec", "ClusterDrsVmConfigSpec[]", a2s_object(_obj.drsVmConfigSpec, _obj.__sizedrsVmConfigSpec), context);
	update_member_with_version(update, "groupSpec", "ClusterGroupSpec[]", a2s_object(_obj.groupSpec, _obj.__sizegroupSpec), context, "4.1");
	update_member(update, "rulesSpec", "ClusterRuleSpec[]", a2s_object(_obj.rulesSpec, _obj.__sizerulesSpec), context);
	update("Base", "ComputeResourceConfigSpec", context);
	ComputeResourceConfigSpec_closure(dynamic_cast<const vw1__ComputeResourceConfigSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterConfigSpecEx_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.dasConfig)
			return new ClusterDasConfigInfo_closure(*_obj.dasConfig);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedasVmConfigSpec)
				return new ClusterDasVmConfigSpec_closure(*_obj.dasVmConfigSpec[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.dpmConfig)
			return new ClusterDpmConfigInfo_closure(*_obj.dpmConfig);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedpmHostConfigSpec)
				return new ClusterDpmHostConfigSpec_closure(*_obj.dpmHostConfigSpec[i]);
			else
				return 0;
		}
	case 4:
		if (_obj.drsConfig)
			return new ClusterDrsConfigInfo_closure(*_obj.drsConfig);
		else
			return 0;
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedrsVmConfigSpec)
				return new ClusterDrsVmConfigSpec_closure(*_obj.drsVmConfigSpec[i]);
			else
				return 0;
		}
	case 6:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizegroupSpec)
				return new ClusterGroupSpec_closure(*_obj.groupSpec[i]);
			else
				return 0;
		}
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerulesSpec)
				return new ClusterRuleSpec_closure(*_obj.rulesSpec[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ComputeResourceConfigSpec_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void ClusterCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterCreatedEvent", context);
	update_member(update, "parent", "FolderEventArgument", handle_obj_ptr(_obj.parent), context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterCreatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.parent)
			return new FolderEventArgument_closure(*_obj.parent);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ClusterEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterDasAamHostInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasAamHostInfo", context);
	update_member(update, "hostDasState", "ClusterDasAamNodeState[]", a2s_object(_obj.hostDasState, _obj.__sizehostDasState), context);
	update_member(update, "primaryHosts", "xsd:string[]", a2s_basic(*_obj.primaryHosts, _obj.__sizeprimaryHosts), context);
	update("Base", "ClusterDasHostInfo", context);
	ClusterDasHostInfo_closure(dynamic_cast<const vw1__ClusterDasHostInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasAamHostInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehostDasState)
				return new ClusterDasAamNodeState_closure(*_obj.hostDasState[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ClusterDasHostInfo_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterDasAamNodeState_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasAamNodeState", context);
	update_member(update, "configState", "xsd:string", basic2str(_obj.configState), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "runtimeState", "xsd:string", basic2str(_obj.runtimeState), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasAamNodeState_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void ClusterDasAdmissionControlInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasAdmissionControlInfo", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasAdmissionControlInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterDasAdmissionControlPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasAdmissionControlPolicy", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasAdmissionControlPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterDasAdvancedRuntimeInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasAdvancedRuntimeInfo", context);
	update_member(update, "dasHostInfo", "ClusterDasHostInfo", handle_obj_ptr(_obj.dasHostInfo), context);
	update_member_with_version(update, "heartbeatDatastoreInfo", "DasHeartbeatDatastoreInfo[]", a2s_object(_obj.heartbeatDatastoreInfo, _obj.__sizeheartbeatDatastoreInfo), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasAdvancedRuntimeInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.dasHostInfo)
			return new ClusterDasHostInfo_closure(*_obj.dasHostInfo);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeheartbeatDatastoreInfo)
				return new DasHeartbeatDatastoreInfo_closure(*_obj.heartbeatDatastoreInfo[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterDasConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasConfigInfo", context);
	update_member(update, "admissionControlEnabled", "xsd:boolean", basic2str(_obj.admissionControlEnabled), context);
	update_member_with_version(update, "admissionControlPolicy", "ClusterDasAdmissionControlPolicy", handle_obj_ptr(_obj.admissionControlPolicy), context, "4.0");
	update_member_with_version(update, "defaultVmSettings", "ClusterDasVmSettings", handle_obj_ptr(_obj.defaultVmSettings), context, "2.5");
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "failoverLevel", "xsd:int", basic2str(_obj.failoverLevel), context);
	update_member_with_version(update, "hBDatastoreCandidatePolicy", "xsd:string", basic2str(_obj.hBDatastoreCandidatePolicy), context, "5.0");
	update_member_with_version(update, "heartbeatDatastore", "Datastore[]", a2s_object(_obj.heartbeatDatastore, _obj.__sizeheartbeatDatastore), context, "5.0");
	update_member_with_version(update, "hostMonitoring", "xsd:string", basic2str(_obj.hostMonitoring), context, "4.0");
	update_member(update, "option", "OptionValue[]", a2s_object(_obj.option, _obj.__sizeoption), context);
	update_member_with_version(update, "vmMonitoring", "xsd:string", basic2str(_obj.vmMonitoring), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.admissionControlPolicy)
			return new ClusterDasAdmissionControlPolicy_closure(*_obj.admissionControlPolicy);
		else
			return 0;
	case 2:
		if (_obj.defaultVmSettings)
			return new ClusterDasVmSettings_closure(*_obj.defaultVmSettings);
		else
			return 0;
	case 6:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeheartbeatDatastore)
				return new Datastore_closure(_obj.heartbeatDatastore[i]);
			else
				return 0;
		}
	case 8:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeoption)
				return new OptionValue_closure(*_obj.option[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 10) << 16) + arr_index);
	}
	return 0;
}

void ClusterDasData_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasData", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasData_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterDasDataSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasDataSummary", context);
	update_member(update, "clusterConfigVersion", "xsd:long", basic2str(_obj.clusterConfigVersion), context);
	update_member(update, "compatListVersion", "xsd:long", basic2str(_obj.compatListVersion), context);
	update_member(update, "hostListVersion", "xsd:long", basic2str(_obj.hostListVersion), context);
	update("Base", "ClusterDasData", context);
	ClusterDasData_closure(dynamic_cast<const vw1__ClusterDasData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasDataSummary_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterDasFailoverLevelAdvancedRuntimeInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasFailoverLevelAdvancedRuntimeInfo", context);
	update_member(update, "hostSlots", "ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots[]", a2s_object(_obj.hostSlots, _obj.__sizehostSlots), context);
	update_member(update, "slotInfo", "ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo", handle_obj_ptr(_obj.slotInfo), context);
	update_member(update, "totalGoodHosts", "xsd:int", basic2str(_obj.totalGoodHosts), context);
	update_member(update, "totalHosts", "xsd:int", basic2str(_obj.totalHosts), context);
	update_member(update, "totalSlots", "xsd:int", basic2str(_obj.totalSlots), context);
	update_member(update, "totalVms", "xsd:int", basic2str(_obj.totalVms), context);
	update_member(update, "unreservedSlots", "xsd:int", basic2str(_obj.unreservedSlots), context);
	update_member(update, "usedSlots", "xsd:int", basic2str(_obj.usedSlots), context);
	update("Base", "ClusterDasAdvancedRuntimeInfo", context);
	ClusterDasAdvancedRuntimeInfo_closure(dynamic_cast<const vw1__ClusterDasAdvancedRuntimeInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasFailoverLevelAdvancedRuntimeInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehostSlots)
				return new ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots_closure(*_obj.hostSlots[i]);
			else
				return 0;
		}
	case 1:
		if (_obj.slotInfo)
			return new ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo_closure(*_obj.slotInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ClusterDasAdvancedRuntimeInfo_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "slots", "xsd:int", basic2str(_obj.slots), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo", context);
	update_member(update, "cpuMHz", "xsd:int", basic2str(_obj.cpuMHz), context);
	update_member(update, "memoryMB", "xsd:int", basic2str(_obj.memoryMB), context);
	update_member(update, "numVcpus", "xsd:int", basic2str(_obj.numVcpus), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterDasFdmHostState_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasFdmHostState", context);
	update_member(update, "state", "xsd:string", basic2str(_obj.state), context);
	update_member(update, "stateReporter", "HostSystem", handle_obj_ptr(_obj.stateReporter), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasFdmHostState_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.stateReporter? 
			get_closure_from_mor(HostSystem(_obj.stateReporter)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterDasHostInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasHostInfo", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasHostInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterDasHostRecommendation_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasHostRecommendation", context);
	update_member(update, "drsRating", "xsd:int", basic2str(_obj.drsRating), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasHostRecommendation_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterDasVmConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasVmConfigInfo", context);
	update_member_with_version(update, "dasSettings", "ClusterDasVmSettings", handle_obj_ptr(_obj.dasSettings), context, "2.5");
	update_member(update, "key", "VirtualMachine", handle_obj_ptr(_obj.key), context);
	update_member(update, "powerOffOnIsolation", "xsd:boolean", basic2str(_obj.powerOffOnIsolation), context);
	update_member(update, "restartPriority", "DasVmPriority", handle_obj_ptr(_obj.restartPriority), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasVmConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.dasSettings)
			return new ClusterDasVmSettings_closure(*_obj.dasSettings);
		else
			return 0;
	case 1:
		return _obj.key? 
			get_closure_from_mor(VirtualMachine(_obj.key)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void ClusterDasVmConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasVmConfigSpec", context);
	update_member(update, "info", "ClusterDasVmConfigInfo", handle_obj_ptr(_obj.info), context);
	update("Base", "ArrayUpdateSpec", context);
	ArrayUpdateSpec_closure(dynamic_cast<const vw1__ArrayUpdateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasVmConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.info)
			return new ClusterDasVmConfigInfo_closure(*_obj.info);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ArrayUpdateSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterDasVmSettings_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDasVmSettings", context);
	update_member(update, "isolationResponse", "xsd:string", basic2str(_obj.isolationResponse), context);
	update_member(update, "restartPriority", "xsd:string", basic2str(_obj.restartPriority), context);
	update_member_with_version(update, "vmToolsMonitoringSettings", "ClusterVmToolsMonitoringSettings", handle_obj_ptr(_obj.vmToolsMonitoringSettings), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDasVmSettings_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.vmToolsMonitoringSettings)
			return new ClusterVmToolsMonitoringSettings_closure(*_obj.vmToolsMonitoringSettings);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ClusterDestroyedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDestroyedEvent", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDestroyedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterDpmConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDpmConfigInfo", context);
	update_member(update, "defaultDpmBehavior", "DpmBehavior", handle_obj_ptr(_obj.defaultDpmBehavior), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member_with_version(update, "hostPowerActionRate", "xsd:int", basic2str(_obj.hostPowerActionRate), context, "4.0");
	update_member(update, "option", "OptionValue[]", a2s_object(_obj.option, _obj.__sizeoption), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDpmConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeoption)
				return new OptionValue_closure(*_obj.option[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void ClusterDpmHostConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDpmHostConfigInfo", context);
	update_member(update, "behavior", "DpmBehavior", handle_obj_ptr(_obj.behavior), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "key", "HostSystem", handle_obj_ptr(_obj.key), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDpmHostConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		return _obj.key? 
			get_closure_from_mor(HostSystem(_obj.key)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ClusterDpmHostConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDpmHostConfigSpec", context);
	update_member(update, "info", "ClusterDpmHostConfigInfo", handle_obj_ptr(_obj.info), context);
	update("Base", "ArrayUpdateSpec", context);
	ArrayUpdateSpec_closure(dynamic_cast<const vw1__ArrayUpdateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDpmHostConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.info)
			return new ClusterDpmHostConfigInfo_closure(*_obj.info);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ArrayUpdateSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterDrsConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDrsConfigInfo", context);
	update_member(update, "defaultVmBehavior", "DrsBehavior", handle_obj_ptr(_obj.defaultVmBehavior), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member_with_version(update, "enableVmBehaviorOverrides", "xsd:boolean", basic2str(_obj.enableVmBehaviorOverrides), context, "4.0");
	update_member(update, "option", "OptionValue[]", a2s_object(_obj.option, _obj.__sizeoption), context);
	update_member(update, "vmotionRate", "xsd:int", basic2str(_obj.vmotionRate), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDrsConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeoption)
				return new OptionValue_closure(*_obj.option[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void ClusterDrsFaults_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDrsFaults", context);
	update_member(update, "faultsByVm", "ClusterDrsFaultsFaultsByVm[]", a2s_object(_obj.faultsByVm, _obj.__sizefaultsByVm), context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDrsFaults_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefaultsByVm)
				return new ClusterDrsFaultsFaultsByVm_closure(*_obj.faultsByVm[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterDrsFaultsFaultsByVirtualDisk_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDrsFaultsFaultsByVirtualDisk", context);
	update_member(update, "disk", "VirtualDiskId", handle_obj_ptr(_obj.disk), context);
	update("Base", "ClusterDrsFaultsFaultsByVm", context);
	ClusterDrsFaultsFaultsByVm_closure(dynamic_cast<const vw1__ClusterDrsFaultsFaultsByVm&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDrsFaultsFaultsByVirtualDisk_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.disk)
			return new VirtualDiskId_closure(*_obj.disk);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ClusterDrsFaultsFaultsByVm_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterDrsFaultsFaultsByVm_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDrsFaultsFaultsByVm", context);
	update_member(update, "fault", "LocalizedMethodFault[]", a2s_object(_obj.fault, _obj.__sizefault), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDrsFaultsFaultsByVm_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefault)
				return new LocalizedMethodFault_closure(*_obj.fault[i]);
			else
				return 0;
		}
	case 1:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterDrsMigration_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDrsMigration", context);
	update_member(update, "cpuLoad", "xsd:int", basic2str(_obj.cpuLoad), context);
	update_member(update, "destination", "HostSystem", handle_obj_ptr(_obj.destination), context);
	update_member(update, "destinationCpuLoad", "xsd:int", basic2str(_obj.destinationCpuLoad), context);
	update_member(update, "destinationMemoryLoad", "xsd:long", basic2str(_obj.destinationMemoryLoad), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "memoryLoad", "xsd:long", basic2str(_obj.memoryLoad), context);
	update_member(update, "source", "HostSystem", handle_obj_ptr(_obj.source), context);
	update_member(update, "sourceCpuLoad", "xsd:int", basic2str(_obj.sourceCpuLoad), context);
	update_member(update, "sourceMemoryLoad", "xsd:long", basic2str(_obj.sourceMemoryLoad), context);
	update_member(update, "time", "xsd:dateTime", basic2str(_obj.time), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDrsMigration_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.destination? 
			get_closure_from_mor(HostSystem(_obj.destination)) : 0;
	case 6:
		return _obj.source? 
			get_closure_from_mor(HostSystem(_obj.source)) : 0;
	case 10:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void ClusterDrsRecommendation_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDrsRecommendation", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "migrationList", "ClusterDrsMigration[]", a2s_object(_obj.migrationList, _obj.__sizemigrationList), context);
	update_member(update, "rating", "xsd:int", basic2str(_obj.rating), context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update_member(update, "reasonText", "xsd:string", basic2str(_obj.reasonText), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDrsRecommendation_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemigrationList)
				return new ClusterDrsMigration_closure(*_obj.migrationList[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void ClusterDrsVmConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDrsVmConfigInfo", context);
	update_member(update, "behavior", "DrsBehavior", handle_obj_ptr(_obj.behavior), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "key", "VirtualMachine", handle_obj_ptr(_obj.key), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDrsVmConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		return _obj.key? 
			get_closure_from_mor(VirtualMachine(_obj.key)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ClusterDrsVmConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterDrsVmConfigSpec", context);
	update_member(update, "info", "ClusterDrsVmConfigInfo", handle_obj_ptr(_obj.info), context);
	update("Base", "ArrayUpdateSpec", context);
	ArrayUpdateSpec_closure(dynamic_cast<const vw1__ArrayUpdateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterDrsVmConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.info)
			return new ClusterDrsVmConfigInfo_closure(*_obj.info);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ArrayUpdateSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterEnterMaintenanceResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterEnterMaintenanceResult", context);
	update_member(update, "fault", "ClusterDrsFaults", handle_obj_ptr(_obj.fault), context);
	update_member(update, "recommendations", "ClusterRecommendation[]", a2s_object(_obj.recommendations, _obj.__sizerecommendations), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterEnterMaintenanceResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new ClusterDrsFaults_closure(*_obj.fault);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerecommendations)
				return new ClusterRecommendation_closure(*_obj.recommendations[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterEvent", context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterFailoverHostAdmissionControlInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterFailoverHostAdmissionControlInfo", context);
	update_member(update, "hostStatus", "ClusterFailoverHostAdmissionControlInfoHostStatus[]", a2s_object(_obj.hostStatus, _obj.__sizehostStatus), context);
	update("Base", "ClusterDasAdmissionControlInfo", context);
	ClusterDasAdmissionControlInfo_closure(dynamic_cast<const vw1__ClusterDasAdmissionControlInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterFailoverHostAdmissionControlInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehostStatus)
				return new ClusterFailoverHostAdmissionControlInfoHostStatus_closure(*_obj.hostStatus[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ClusterDasAdmissionControlInfo_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterFailoverHostAdmissionControlInfoHostStatus_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterFailoverHostAdmissionControlInfoHostStatus", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "status", "ManagedEntityStatus", handle_obj(_obj.status), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterFailoverHostAdmissionControlInfoHostStatus_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterFailoverHostAdmissionControlPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterFailoverHostAdmissionControlPolicy", context);
	update_member(update, "failoverHosts", "HostSystem[]", a2s_object(_obj.failoverHosts, _obj.__sizefailoverHosts), context);
	update("Base", "ClusterDasAdmissionControlPolicy", context);
	ClusterDasAdmissionControlPolicy_closure(dynamic_cast<const vw1__ClusterDasAdmissionControlPolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterFailoverHostAdmissionControlPolicy_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefailoverHosts)
				return new HostSystem_closure(_obj.failoverHosts[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ClusterDasAdmissionControlPolicy_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterFailoverLevelAdmissionControlInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterFailoverLevelAdmissionControlInfo", context);
	update_member(update, "currentFailoverLevel", "xsd:int", basic2str(_obj.currentFailoverLevel), context);
	update("Base", "ClusterDasAdmissionControlInfo", context);
	ClusterDasAdmissionControlInfo_closure(dynamic_cast<const vw1__ClusterDasAdmissionControlInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterFailoverLevelAdmissionControlInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterFailoverLevelAdmissionControlPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterFailoverLevelAdmissionControlPolicy", context);
	update_member(update, "failoverLevel", "xsd:int", basic2str(_obj.failoverLevel), context);
	update("Base", "ClusterDasAdmissionControlPolicy", context);
	ClusterDasAdmissionControlPolicy_closure(dynamic_cast<const vw1__ClusterDasAdmissionControlPolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterFailoverLevelAdmissionControlPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterFailoverResourcesAdmissionControlInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterFailoverResourcesAdmissionControlInfo", context);
	update_member(update, "currentCpuFailoverResourcesPercent", "xsd:int", basic2str(_obj.currentCpuFailoverResourcesPercent), context);
	update_member(update, "currentMemoryFailoverResourcesPercent", "xsd:int", basic2str(_obj.currentMemoryFailoverResourcesPercent), context);
	update("Base", "ClusterDasAdmissionControlInfo", context);
	ClusterDasAdmissionControlInfo_closure(dynamic_cast<const vw1__ClusterDasAdmissionControlInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterFailoverResourcesAdmissionControlInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterFailoverResourcesAdmissionControlPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterFailoverResourcesAdmissionControlPolicy", context);
	update_member(update, "cpuFailoverResourcesPercent", "xsd:int", basic2str(_obj.cpuFailoverResourcesPercent), context);
	update_member(update, "memoryFailoverResourcesPercent", "xsd:int", basic2str(_obj.memoryFailoverResourcesPercent), context);
	update("Base", "ClusterDasAdmissionControlPolicy", context);
	ClusterDasAdmissionControlPolicy_closure(dynamic_cast<const vw1__ClusterDasAdmissionControlPolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterFailoverResourcesAdmissionControlPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterGroupInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterGroupInfo", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member_with_version(update, "userCreated", "xsd:boolean", basic2str(_obj.userCreated), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterGroupInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterGroupSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterGroupSpec", context);
	update_member(update, "info", "ClusterGroupInfo", handle_obj_ptr(_obj.info), context);
	update("Base", "ArrayUpdateSpec", context);
	ArrayUpdateSpec_closure(dynamic_cast<const vw1__ArrayUpdateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterGroupSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.info)
			return new ClusterGroupInfo_closure(*_obj.info);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ArrayUpdateSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterHostGroup_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterHostGroup", context);
	update_member(update, "host", "HostSystem[]", a2s_object(_obj.host, _obj.__sizehost), context);
	update("Base", "ClusterGroupInfo", context);
	ClusterGroupInfo_closure(dynamic_cast<const vw1__ClusterGroupInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterHostGroup_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehost)
				return new HostSystem_closure(_obj.host[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ClusterGroupInfo_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterHostPowerAction_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterHostPowerAction", context);
	update_member(update, "cpuCapacityMHz", "xsd:int", basic2str(_obj.cpuCapacityMHz), context);
	update_member(update, "memCapacityMB", "xsd:int", basic2str(_obj.memCapacityMB), context);
	update_member(update, "operationType", "HostPowerOperationType", handle_obj(_obj.operationType), context);
	update_member(update, "powerConsumptionWatt", "xsd:int", basic2str(_obj.powerConsumptionWatt), context);
	update("Base", "ClusterAction", context);
	ClusterAction_closure(dynamic_cast<const vw1__ClusterAction&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterHostPowerAction_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterHostRecommendation_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterHostRecommendation", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "rating", "xsd:int", basic2str(_obj.rating), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterHostRecommendation_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterInitialPlacementAction_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterInitialPlacementAction", context);
	update_member(update, "pool", "ResourcePool", handle_obj_ptr(_obj.pool), context);
	update_member(update, "targetHost", "HostSystem", handle_obj_ptr(_obj.targetHost), context);
	update("Base", "ClusterAction", context);
	ClusterAction_closure(dynamic_cast<const vw1__ClusterAction&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterInitialPlacementAction_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.pool? 
			get_closure_from_mor(ResourcePool(_obj.pool)) : 0;
	case 1:
		return _obj.targetHost? 
			get_closure_from_mor(HostSystem(_obj.targetHost)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return ClusterAction_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterMigrationAction_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterMigrationAction", context);
	update_member(update, "drsMigration", "ClusterDrsMigration", handle_obj_ptr(_obj.drsMigration), context);
	update("Base", "ClusterAction", context);
	ClusterAction_closure(dynamic_cast<const vw1__ClusterAction&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterMigrationAction_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.drsMigration)
			return new ClusterDrsMigration_closure(*_obj.drsMigration);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ClusterAction_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterNotAttemptedVmInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterNotAttemptedVmInfo", context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterNotAttemptedVmInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	case 1:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ClusterOvercommittedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterOvercommittedEvent", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterOvercommittedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterPowerOnVmResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterPowerOnVmResult", context);
	update_member(update, "attempted", "ClusterAttemptedVmInfo[]", a2s_object(_obj.attempted, _obj.__sizeattempted), context);
	update_member(update, "notAttempted", "ClusterNotAttemptedVmInfo[]", a2s_object(_obj.notAttempted, _obj.__sizenotAttempted), context);
	update_member(update, "recommendations", "ClusterRecommendation[]", a2s_object(_obj.recommendations, _obj.__sizerecommendations), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterPowerOnVmResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeattempted)
				return new ClusterAttemptedVmInfo_closure(*_obj.attempted[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenotAttempted)
				return new ClusterNotAttemptedVmInfo_closure(*_obj.notAttempted[i]);
			else
				return 0;
		}
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerecommendations)
				return new ClusterRecommendation_closure(*_obj.recommendations[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ClusterProfileCompleteConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterProfileCompleteConfigSpec", context);
	update_member(update, "complyProfile", "ComplianceProfile", handle_obj_ptr(_obj.complyProfile), context);
	update("Base", "ClusterProfileConfigSpec", context);
	ClusterProfileConfigSpec_closure(dynamic_cast<const vw1__ClusterProfileConfigSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterProfileCompleteConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.complyProfile)
			return new ComplianceProfile_closure(*_obj.complyProfile);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ClusterProfileConfigSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterProfileConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterProfileConfigInfo", context);
	update_member(update, "complyProfile", "ComplianceProfile", handle_obj_ptr(_obj.complyProfile), context);
	update("Base", "ProfileConfigInfo", context);
	ProfileConfigInfo_closure(dynamic_cast<const vw1__ProfileConfigInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterProfileConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.complyProfile)
			return new ComplianceProfile_closure(*_obj.complyProfile);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ProfileConfigInfo_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterProfileConfigServiceCreateSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterProfileConfigServiceCreateSpec", context);
	update_member(update, "serviceType", "xsd:string[]", a2s_basic(*_obj.serviceType, _obj.__sizeserviceType), context);
	update("Base", "ClusterProfileConfigSpec", context);
	ClusterProfileConfigSpec_closure(dynamic_cast<const vw1__ClusterProfileConfigSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterProfileConfigServiceCreateSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterProfileConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterProfileConfigSpec", context);
	update("Base", "ClusterProfileCreateSpec", context);
	ClusterProfileCreateSpec_closure(dynamic_cast<const vw1__ClusterProfileCreateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterProfileConfigSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterProfileCreateSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterProfileCreateSpec", context);
	update("Base", "ProfileCreateSpec", context);
	ProfileCreateSpec_closure(dynamic_cast<const vw1__ProfileCreateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterProfileCreateSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterRecommendation_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterRecommendation", context);
	update_member(update, "action", "ClusterAction[]", a2s_object(_obj.action, _obj.__sizeaction), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "prerequisite", "xsd:string[]", a2s_basic(*_obj.prerequisite, _obj.__sizeprerequisite), context);
	update_member(update, "rating", "xsd:int", basic2str(_obj.rating), context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update_member(update, "reasonText", "xsd:string", basic2str(_obj.reasonText), context);
	update_member(update, "target", "ManagedObjectReference", handle_obj_ptr(_obj.target), context);
	update_member(update, "time", "xsd:dateTime", basic2str(_obj.time), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterRecommendation_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeaction)
				return new ClusterAction_closure(*_obj.action[i]);
			else
				return 0;
		}
	case 6:
		if (_obj.target)
			return new ManagedObjectReference_closure(*_obj.target);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 9) << 16) + arr_index);
	}
	return 0;
}

void ClusterReconfiguredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterReconfiguredEvent", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterReconfiguredEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterRuleInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterRuleInfo", context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member_with_version(update, "inCompliance", "xsd:boolean", basic2str(_obj.inCompliance), context, "4.1");
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update_member_with_version(update, "mandatory", "xsd:boolean", basic2str(_obj.mandatory), context, "4.1");
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "status", "ManagedEntityStatus", handle_obj_ptr(_obj.status), context);
	update_member_with_version(update, "userCreated", "xsd:boolean", basic2str(_obj.userCreated), context, "4.1");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterRuleInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterRuleSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterRuleSpec", context);
	update_member(update, "info", "ClusterRuleInfo", handle_obj_ptr(_obj.info), context);
	update("Base", "ArrayUpdateSpec", context);
	ArrayUpdateSpec_closure(dynamic_cast<const vw1__ArrayUpdateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterRuleSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.info)
			return new ClusterRuleInfo_closure(*_obj.info);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ArrayUpdateSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterStatusChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterStatusChangedEvent", context);
	update_member(update, "newStatus", "xsd:string", basic2str(_obj.newStatus), context);
	update_member(update, "oldStatus", "xsd:string", basic2str(_obj.oldStatus), context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterStatusChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterVmGroup_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterVmGroup", context);
	update_member(update, "vm", "VirtualMachine[]", a2s_object(_obj.vm, _obj.__sizevm), context);
	update("Base", "ClusterGroupInfo", context);
	ClusterGroupInfo_closure(dynamic_cast<const vw1__ClusterGroupInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterVmGroup_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevm)
				return new VirtualMachine_closure(_obj.vm[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ClusterGroupInfo_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ClusterVmHostRuleInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterVmHostRuleInfo", context);
	update_member(update, "affineHostGroupName", "xsd:string", basic2str(_obj.affineHostGroupName), context);
	update_member(update, "antiAffineHostGroupName", "xsd:string", basic2str(_obj.antiAffineHostGroupName), context);
	update_member(update, "vmGroupName", "xsd:string", basic2str(_obj.vmGroupName), context);
	update("Base", "ClusterRuleInfo", context);
	ClusterRuleInfo_closure(dynamic_cast<const vw1__ClusterRuleInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterVmHostRuleInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ClusterVmToolsMonitoringSettings_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterVmToolsMonitoringSettings", context);
	update_member(update, "clusterSettings", "xsd:boolean", basic2str(_obj.clusterSettings), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "failureInterval", "xsd:int", basic2str(_obj.failureInterval), context);
	update_member(update, "maxFailures", "xsd:int", basic2str(_obj.maxFailures), context);
	update_member(update, "maxFailureWindow", "xsd:int", basic2str(_obj.maxFailureWindow), context);
	update_member(update, "minUpTime", "xsd:int", basic2str(_obj.minUpTime), context);
	update_member_with_version(update, "vmMonitoring", "xsd:string", basic2str(_obj.vmMonitoring), context, "4.1");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterVmToolsMonitoringSettings_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ComplianceFailure_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ComplianceFailure", context);
	update_member(update, "expressionName", "xsd:string", basic2str(_obj.expressionName), context);
	update_member(update, "failureType", "xsd:string", basic2str(_obj.failureType), context);
	update_member(update, "message", "LocalizableMessage", handle_obj_ptr(_obj.message), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ComplianceFailure_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.message)
			return new LocalizableMessage_closure(*_obj.message);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ComplianceLocator_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ComplianceLocator", context);
	update_member(update, "applyPath", "ProfilePropertyPath", handle_obj_ptr(_obj.applyPath), context);
	update_member(update, "expressionName", "xsd:string", basic2str(_obj.expressionName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ComplianceLocator_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.applyPath)
			return new ProfilePropertyPath_closure(*_obj.applyPath);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ComplianceProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ComplianceProfile", context);
	update_member(update, "expression", "ProfileExpression[]", a2s_object(_obj.expression, _obj.__sizeexpression), context);
	update_member(update, "rootExpression", "xsd:string", basic2str(_obj.rootExpression), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ComplianceProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeexpression)
				return new ProfileExpression_closure(*_obj.expression[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ComplianceResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ComplianceResult", context);
	update_member(update, "checkTime", "xsd:dateTime", basic2str(_obj.checkTime), context);
	update_member(update, "complianceStatus", "xsd:string", basic2str(_obj.complianceStatus), context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "failure", "ComplianceFailure[]", a2s_object(_obj.failure, _obj.__sizefailure), context);
	update_member(update, "profile", "Profile", handle_obj_ptr(_obj.profile), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ComplianceResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefailure)
				return new ComplianceFailure_closure(*_obj.failure[i]);
			else
				return 0;
		}
	case 4:
		return _obj.profile? 
			get_closure_from_mor(Profile(_obj.profile)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void CompositePolicyOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CompositePolicyOption", context);
	update_member(update, "option", "PolicyOption[]", a2s_object(_obj.option, _obj.__sizeoption), context);
	update("Base", "PolicyOption", context);
	PolicyOption_closure(dynamic_cast<const vw1__PolicyOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CompositePolicyOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeoption)
				return new PolicyOption_closure(*_obj.option[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return PolicyOption_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ComputeResourceConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ComputeResourceConfigInfo", context);
	update_member_with_version(update, "spbmEnabled", "xsd:boolean", basic2str(_obj.spbmEnabled), context, "5.0");
	update_member(update, "vmSwapPlacement", "xsd:string", basic2str(_obj.vmSwapPlacement), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ComputeResourceConfigInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ComputeResourceConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ComputeResourceConfigSpec", context);
	update_member_with_version(update, "spbmEnabled", "xsd:boolean", basic2str(_obj.spbmEnabled), context, "5.0");
	update_member(update, "vmSwapPlacement", "xsd:string", basic2str(_obj.vmSwapPlacement), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ComputeResourceConfigSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ComputeResourceEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ComputeResourceEventArgument", context);
	update_member(update, "computeResource", "ComputeResource", handle_obj_ptr(_obj.computeResource), context);
	update("Base", "EntityEventArgument", context);
	EntityEventArgument_closure(dynamic_cast<const vw1__EntityEventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ComputeResourceEventArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.computeResource? 
			get_closure_from_mor(ComputeResource(_obj.computeResource)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return EntityEventArgument_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ComputeResourceHostSPBMLicenseInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ComputeResourceHostSPBMLicenseInfo", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "licenseState", "ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState", handle_obj(_obj.licenseState), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ComputeResourceHostSPBMLicenseInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ComputeResourceSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ComputeResourceSummary", context);
	update_member(update, "effectiveCpu", "xsd:int", basic2str(_obj.effectiveCpu), context);
	update_member(update, "effectiveMemory", "xsd:long", basic2str(_obj.effectiveMemory), context);
	update_member(update, "numCpuCores", "xsd:short", basic2str(_obj.numCpuCores), context);
	update_member(update, "numCpuThreads", "xsd:short", basic2str(_obj.numCpuThreads), context);
	update_member(update, "numEffectiveHosts", "xsd:int", basic2str(_obj.numEffectiveHosts), context);
	update_member(update, "numHosts", "xsd:int", basic2str(_obj.numHosts), context);
	update_member(update, "overallStatus", "ManagedEntityStatus", handle_obj(_obj.overallStatus), context);
	update_member(update, "totalCpu", "xsd:int", basic2str(_obj.totalCpu), context);
	update_member(update, "totalMemory", "xsd:long", basic2str(_obj.totalMemory), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ComputeResourceSummary_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ConfigTarget_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ConfigTarget", context);
	update_member(update, "autoVmotion", "xsd:boolean", basic2str(_obj.autoVmotion), context);
	update_member(update, "cdRom", "VirtualMachineCdromInfo[]", a2s_object(_obj.cdRom, _obj.__sizecdRom), context);
	update_member(update, "datastore", "VirtualMachineDatastoreInfo[]", a2s_object(_obj.datastore, _obj.__sizedatastore), context);
	update_member_with_version(update, "distributedVirtualPortgroup", "DistributedVirtualPortgroupInfo[]", a2s_object(_obj.distributedVirtualPortgroup, _obj.__sizedistributedVirtualPortgroup), context, "4.0");
	update_member_with_version(update, "distributedVirtualSwitch", "DistributedVirtualSwitchInfo[]", a2s_object(_obj.distributedVirtualSwitch, _obj.__sizedistributedVirtualSwitch), context, "4.0");
	update_member(update, "floppy", "VirtualMachineFloppyInfo[]", a2s_object(_obj.floppy, _obj.__sizefloppy), context);
	update_member(update, "ideDisk", "VirtualMachineIdeDiskDeviceInfo[]", a2s_object(_obj.ideDisk, _obj.__sizeideDisk), context);
	update_member(update, "legacyNetworkInfo", "VirtualMachineLegacyNetworkSwitchInfo[]", a2s_object(_obj.legacyNetworkInfo, _obj.__sizelegacyNetworkInfo), context);
	update_member(update, "maxMemMBOptimalPerf", "xsd:int", basic2str(_obj.maxMemMBOptimalPerf), context);
	update_member(update, "network", "VirtualMachineNetworkInfo[]", a2s_object(_obj.network, _obj.__sizenetwork), context);
	update_member(update, "numCpuCores", "xsd:int", basic2str(_obj.numCpuCores), context);
	update_member(update, "numCpus", "xsd:int", basic2str(_obj.numCpus), context);
	update_member(update, "numNumaNodes", "xsd:int", basic2str(_obj.numNumaNodes), context);
	update_member(update, "parallel", "VirtualMachineParallelInfo[]", a2s_object(_obj.parallel, _obj.__sizeparallel), context);
	update_member_with_version(update, "pciPassthrough", "VirtualMachinePciPassthroughInfo[]", a2s_object(_obj.pciPassthrough, _obj.__sizepciPassthrough), context, "4.0");
	update_member(update, "resourcePool", "ResourcePoolRuntimeInfo", handle_obj_ptr(_obj.resourcePool), context);
	update_member(update, "scsiDisk", "VirtualMachineScsiDiskDeviceInfo[]", a2s_object(_obj.scsiDisk, _obj.__sizescsiDisk), context);
	update_member(update, "scsiPassthrough", "VirtualMachineScsiPassthroughInfo[]", a2s_object(_obj.scsiPassthrough, _obj.__sizescsiPassthrough), context);
	update_member(update, "serial", "VirtualMachineSerialInfo[]", a2s_object(_obj.serial, _obj.__sizeserial), context);
	update_member_with_version(update, "smcPresent", "xsd:boolean", basic2str(_obj.smcPresent), context, "5.0");
	update_member_with_version(update, "sound", "VirtualMachineSoundInfo[]", a2s_object(_obj.sound, _obj.__sizesound), context, "2.5");
	update_member_with_version(update, "usb", "VirtualMachineUsbInfo[]", a2s_object(_obj.usb, _obj.__sizeusb), context, "2.5");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ConfigTarget_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecdRom)
				return new VirtualMachineCdromInfo_closure(*_obj.cdRom[i]);
			else
				return 0;
		}
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedatastore)
				return new VirtualMachineDatastoreInfo_closure(*_obj.datastore[i]);
			else
				return 0;
		}
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedistributedVirtualPortgroup)
				return new DistributedVirtualPortgroupInfo_closure(*_obj.distributedVirtualPortgroup[i]);
			else
				return 0;
		}
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedistributedVirtualSwitch)
				return new DistributedVirtualSwitchInfo_closure(*_obj.distributedVirtualSwitch[i]);
			else
				return 0;
		}
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefloppy)
				return new VirtualMachineFloppyInfo_closure(*_obj.floppy[i]);
			else
				return 0;
		}
	case 6:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeideDisk)
				return new VirtualMachineIdeDiskDeviceInfo_closure(*_obj.ideDisk[i]);
			else
				return 0;
		}
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizelegacyNetworkInfo)
				return new VirtualMachineLegacyNetworkSwitchInfo_closure(*_obj.legacyNetworkInfo[i]);
			else
				return 0;
		}
	case 9:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenetwork)
				return new VirtualMachineNetworkInfo_closure(*_obj.network[i]);
			else
				return 0;
		}
	case 13:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeparallel)
				return new VirtualMachineParallelInfo_closure(*_obj.parallel[i]);
			else
				return 0;
		}
	case 14:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepciPassthrough)
				return new VirtualMachinePciPassthroughInfo_closure(*_obj.pciPassthrough[i]);
			else
				return 0;
		}
	case 15:
		if (_obj.resourcePool)
			return new ResourcePoolRuntimeInfo_closure(*_obj.resourcePool);
		else
			return 0;
	case 16:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizescsiDisk)
				return new VirtualMachineScsiDiskDeviceInfo_closure(*_obj.scsiDisk[i]);
			else
				return 0;
		}
	case 17:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizescsiPassthrough)
				return new VirtualMachineScsiPassthroughInfo_closure(*_obj.scsiPassthrough[i]);
			else
				return 0;
		}
	case 18:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeserial)
				return new VirtualMachineSerialInfo_closure(*_obj.serial[i]);
			else
				return 0;
		}
	case 20:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesound)
				return new VirtualMachineSoundInfo_closure(*_obj.sound[i]);
			else
				return 0;
		}
	case 21:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeusb)
				return new VirtualMachineUsbInfo_closure(*_obj.usb[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 22) << 16) + arr_index);
	}
	return 0;
}

void CreateTaskAction_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CreateTaskAction", context);
	update_member(update, "cancelable", "xsd:boolean", basic2str(_obj.cancelable), context);
	update_member(update, "taskTypeId", "xsd:string", basic2str(_obj.taskTypeId), context);
	update("Base", "Action", context);
	Action_closure(dynamic_cast<const vw1__Action&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CreateTaskAction_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomFieldDef_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomFieldDef", context);
	update_member_with_version(update, "fieldDefPrivileges", "PrivilegePolicyDef", handle_obj_ptr(_obj.fieldDefPrivileges), context, "2.5");
	update_member_with_version(update, "fieldInstancePrivileges", "PrivilegePolicyDef", handle_obj_ptr(_obj.fieldInstancePrivileges), context, "2.5");
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update_member_with_version(update, "managedObjectType", "xsd:string", basic2str(_obj.managedObjectType), context, "2.5");
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomFieldDef_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fieldDefPrivileges)
			return new PrivilegePolicyDef_closure(*_obj.fieldDefPrivileges);
		else
			return 0;
	case 1:
		if (_obj.fieldInstancePrivileges)
			return new PrivilegePolicyDef_closure(*_obj.fieldInstancePrivileges);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void CustomFieldDefAddedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomFieldDefAddedEvent", context);
	update("Base", "CustomFieldDefEvent", context);
	CustomFieldDefEvent_closure(dynamic_cast<const vw1__CustomFieldDefEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomFieldDefAddedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomFieldDefEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomFieldDefEvent", context);
	update_member(update, "fieldKey", "xsd:int", basic2str(_obj.fieldKey), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "CustomFieldEvent", context);
	CustomFieldEvent_closure(dynamic_cast<const vw1__CustomFieldEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomFieldDefEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomFieldDefRemovedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomFieldDefRemovedEvent", context);
	update("Base", "CustomFieldDefEvent", context);
	CustomFieldDefEvent_closure(dynamic_cast<const vw1__CustomFieldDefEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomFieldDefRemovedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomFieldDefRenamedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomFieldDefRenamedEvent", context);
	update_member(update, "newName", "xsd:string", basic2str(_obj.newName), context);
	update("Base", "CustomFieldDefEvent", context);
	CustomFieldDefEvent_closure(dynamic_cast<const vw1__CustomFieldDefEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomFieldDefRenamedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomFieldEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomFieldEvent", context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomFieldEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomFieldStringValue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomFieldStringValue", context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "CustomFieldValue", context);
	CustomFieldValue_closure(dynamic_cast<const vw1__CustomFieldValue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomFieldStringValue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomFieldValue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomFieldValue", context);
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomFieldValue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomFieldValueChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomFieldValueChangedEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update_member(update, "fieldKey", "xsd:int", basic2str(_obj.fieldKey), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "CustomFieldEvent", context);
	CustomFieldEvent_closure(dynamic_cast<const vw1__CustomFieldEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomFieldValueChangedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return CustomFieldEvent_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void CustomizationAdapterMapping_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationAdapterMapping", context);
	update_member(update, "adapter", "CustomizationIPSettings", handle_obj_ptr(_obj.adapter), context);
	update_member(update, "macAddress", "xsd:string", basic2str(_obj.macAddress), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationAdapterMapping_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.adapter)
			return new CustomizationIPSettings_closure(*_obj.adapter);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void CustomizationAutoIpV6Generator_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationAutoIpV6Generator", context);
	update("Base", "CustomizationIpV6Generator", context);
	CustomizationIpV6Generator_closure(dynamic_cast<const vw1__CustomizationIpV6Generator&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationAutoIpV6Generator_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationCustomIpGenerator_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationCustomIpGenerator", context);
	update_member(update, "argument", "xsd:string", basic2str(_obj.argument), context);
	update("Base", "CustomizationIpGenerator", context);
	CustomizationIpGenerator_closure(dynamic_cast<const vw1__CustomizationIpGenerator&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationCustomIpGenerator_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationCustomIpV6Generator_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationCustomIpV6Generator", context);
	update_member(update, "argument", "xsd:string", basic2str(_obj.argument), context);
	update("Base", "CustomizationIpV6Generator", context);
	CustomizationIpV6Generator_closure(dynamic_cast<const vw1__CustomizationIpV6Generator&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationCustomIpV6Generator_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationCustomName_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationCustomName", context);
	update_member(update, "argument", "xsd:string", basic2str(_obj.argument), context);
	update("Base", "CustomizationName", context);
	CustomizationName_closure(dynamic_cast<const vw1__CustomizationName&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationCustomName_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationDhcpIpGenerator_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationDhcpIpGenerator", context);
	update("Base", "CustomizationIpGenerator", context);
	CustomizationIpGenerator_closure(dynamic_cast<const vw1__CustomizationIpGenerator&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationDhcpIpGenerator_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationDhcpIpV6Generator_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationDhcpIpV6Generator", context);
	update("Base", "CustomizationIpV6Generator", context);
	CustomizationIpV6Generator_closure(dynamic_cast<const vw1__CustomizationIpV6Generator&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationDhcpIpV6Generator_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationEvent", context);
	update_member(update, "logLocation", "xsd:string", basic2str(_obj.logLocation), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationFailed", context);
	update("Base", "CustomizationEvent", context);
	CustomizationEvent_closure(dynamic_cast<const vw1__CustomizationEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationFixedIp_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationFixedIp", context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update("Base", "CustomizationIpGenerator", context);
	CustomizationIpGenerator_closure(dynamic_cast<const vw1__CustomizationIpGenerator&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationFixedIp_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationFixedIpV6_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationFixedIpV6", context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update_member(update, "subnetMask", "xsd:int", basic2str(_obj.subnetMask), context);
	update("Base", "CustomizationIpV6Generator", context);
	CustomizationIpV6Generator_closure(dynamic_cast<const vw1__CustomizationIpV6Generator&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationFixedIpV6_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationFixedName_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationFixedName", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "CustomizationName", context);
	CustomizationName_closure(dynamic_cast<const vw1__CustomizationName&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationFixedName_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationGlobalIPSettings_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationGlobalIPSettings", context);
	update_member(update, "dnsServerList", "xsd:string[]", a2s_basic(*_obj.dnsServerList, _obj.__sizednsServerList), context);
	update_member(update, "dnsSuffixList", "xsd:string[]", a2s_basic(*_obj.dnsSuffixList, _obj.__sizednsSuffixList), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationGlobalIPSettings_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationGuiRunOnce_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationGuiRunOnce", context);
	update_member(update, "commandList", "xsd:string[]", a2s_basic(*_obj.commandList, _obj.__sizecommandList), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationGuiRunOnce_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationGuiUnattended_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationGuiUnattended", context);
	update_member(update, "autoLogon", "xsd:boolean", basic2str(_obj.autoLogon), context);
	update_member(update, "autoLogonCount", "xsd:int", basic2str(_obj.autoLogonCount), context);
	update_member(update, "password", "CustomizationPassword", handle_obj_ptr(_obj.password), context);
	update_member(update, "timeZone", "xsd:int", basic2str(_obj.timeZone), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationGuiUnattended_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.password)
			return new CustomizationPassword_closure(*_obj.password);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void CustomizationIPSettings_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationIPSettings", context);
	update_member(update, "dnsDomain", "xsd:string", basic2str(_obj.dnsDomain), context);
	update_member(update, "dnsServerList", "xsd:string[]", a2s_basic(*_obj.dnsServerList, _obj.__sizednsServerList), context);
	update_member(update, "gateway", "xsd:string[]", a2s_basic(*_obj.gateway, _obj.__sizegateway), context);
	update_member(update, "ip", "CustomizationIpGenerator", handle_obj_ptr(_obj.ip), context);
	update_member_with_version(update, "ipV6Spec", "CustomizationIPSettingsIpV6AddressSpec", handle_obj_ptr(_obj.ipV6Spec), context, "4.0");
	update_member(update, "netBIOS", "CustomizationNetBIOSMode", handle_obj_ptr(_obj.netBIOS), context);
	update_member(update, "primaryWINS", "xsd:string", basic2str(_obj.primaryWINS), context);
	update_member(update, "secondaryWINS", "xsd:string", basic2str(_obj.secondaryWINS), context);
	update_member(update, "subnetMask", "xsd:string", basic2str(_obj.subnetMask), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationIPSettings_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		if (_obj.ip)
			return new CustomizationIpGenerator_closure(*_obj.ip);
		else
			return 0;
	case 4:
		if (_obj.ipV6Spec)
			return new CustomizationIPSettingsIpV6AddressSpec_closure(*_obj.ipV6Spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 9) << 16) + arr_index);
	}
	return 0;
}

void CustomizationIPSettingsIpV6AddressSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationIPSettingsIpV6AddressSpec", context);
	update_member(update, "gateway", "xsd:string[]", a2s_basic(*_obj.gateway, _obj.__sizegateway), context);
	update_member(update, "ip", "CustomizationIpV6Generator[]", a2s_object(_obj.ip, _obj.__sizeip), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationIPSettingsIpV6AddressSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeip)
				return new CustomizationIpV6Generator_closure(*_obj.ip[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void CustomizationIdentification_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationIdentification", context);
	update_member(update, "domainAdmin", "xsd:string", basic2str(_obj.domainAdmin), context);
	update_member(update, "domainAdminPassword", "CustomizationPassword", handle_obj_ptr(_obj.domainAdminPassword), context);
	update_member(update, "joinDomain", "xsd:string", basic2str(_obj.joinDomain), context);
	update_member(update, "joinWorkgroup", "xsd:string", basic2str(_obj.joinWorkgroup), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationIdentification_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.domainAdminPassword)
			return new CustomizationPassword_closure(*_obj.domainAdminPassword);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void CustomizationIdentitySettings_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationIdentitySettings", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationIdentitySettings_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationIpGenerator_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationIpGenerator", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationIpGenerator_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationIpV6Generator_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationIpV6Generator", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationIpV6Generator_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationLicenseFilePrintData_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationLicenseFilePrintData", context);
	update_member(update, "autoMode", "CustomizationLicenseDataMode", handle_obj(_obj.autoMode), context);
	update_member(update, "autoUsers", "xsd:int", basic2str(_obj.autoUsers), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationLicenseFilePrintData_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationLinuxIdentityFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationLinuxIdentityFailed", context);
	update("Base", "CustomizationFailed", context);
	CustomizationFailed_closure(dynamic_cast<const vw1__CustomizationFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationLinuxIdentityFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationLinuxOptions_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationLinuxOptions", context);
	update("Base", "CustomizationOptions", context);
	CustomizationOptions_closure(dynamic_cast<const vw1__CustomizationOptions&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationLinuxOptions_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationLinuxPrep_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationLinuxPrep", context);
	update_member(update, "domain", "xsd:string", basic2str(_obj.domain), context);
	update_member(update, "hostName", "CustomizationName", handle_obj_ptr(_obj.hostName), context);
	update_member_with_version(update, "hwClockUTC", "xsd:boolean", basic2str(_obj.hwClockUTC), context, "4.0");
	update_member_with_version(update, "timeZone", "xsd:string", basic2str(_obj.timeZone), context, "4.0");
	update("Base", "CustomizationIdentitySettings", context);
	CustomizationIdentitySettings_closure(dynamic_cast<const vw1__CustomizationIdentitySettings&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationLinuxPrep_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.hostName)
			return new CustomizationName_closure(*_obj.hostName);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return CustomizationIdentitySettings_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void CustomizationName_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationName", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationName_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationNetworkSetupFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationNetworkSetupFailed", context);
	update("Base", "CustomizationFailed", context);
	CustomizationFailed_closure(dynamic_cast<const vw1__CustomizationFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationNetworkSetupFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationOptions_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationOptions", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationOptions_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationPassword_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationPassword", context);
	update_member(update, "plainText", "xsd:boolean", basic2str(_obj.plainText), context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationPassword_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationPrefixName_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationPrefixName", context);
	update_member(update, "base", "xsd:string", basic2str(_obj.base), context);
	update("Base", "CustomizationName", context);
	CustomizationName_closure(dynamic_cast<const vw1__CustomizationName&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationPrefixName_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationSpec", context);
	update_member(update, "encryptionKey", "xsd:byte[]", a2s_basic(_obj.encryptionKey, _obj.__sizeencryptionKey), context);
	update_member(update, "globalIPSettings", "CustomizationGlobalIPSettings", handle_obj_ptr(_obj.globalIPSettings), context);
	update_member(update, "identity", "CustomizationIdentitySettings", handle_obj_ptr(_obj.identity), context);
	update_member(update, "nicSettingMap", "CustomizationAdapterMapping[]", a2s_object(_obj.nicSettingMap, _obj.__sizenicSettingMap), context);
	update_member(update, "options", "CustomizationOptions", handle_obj_ptr(_obj.options), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.globalIPSettings)
			return new CustomizationGlobalIPSettings_closure(*_obj.globalIPSettings);
		else
			return 0;
	case 2:
		if (_obj.identity)
			return new CustomizationIdentitySettings_closure(*_obj.identity);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenicSettingMap)
				return new CustomizationAdapterMapping_closure(*_obj.nicSettingMap[i]);
			else
				return 0;
		}
	case 4:
		if (_obj.options)
			return new CustomizationOptions_closure(*_obj.options);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void CustomizationSpecInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationSpecInfo", context);
	update_member(update, "changeVersion", "xsd:string", basic2str(_obj.changeVersion), context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "lastUpdateTime", "xsd:dateTime", basic2str(_obj.lastUpdateTime), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationSpecInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationSpecItem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationSpecItem", context);
	update_member(update, "info", "CustomizationSpecInfo", handle_obj_ptr(_obj.info), context);
	update_member(update, "spec", "CustomizationSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationSpecItem_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.info)
			return new CustomizationSpecInfo_closure(*_obj.info);
		else
			return 0;
	case 1:
		if (_obj.spec)
			return new CustomizationSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void CustomizationStartedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationStartedEvent", context);
	update("Base", "CustomizationEvent", context);
	CustomizationEvent_closure(dynamic_cast<const vw1__CustomizationEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationStartedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationStatelessIpV6Generator_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationStatelessIpV6Generator", context);
	update("Base", "CustomizationIpV6Generator", context);
	CustomizationIpV6Generator_closure(dynamic_cast<const vw1__CustomizationIpV6Generator&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationStatelessIpV6Generator_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationSucceeded_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationSucceeded", context);
	update("Base", "CustomizationEvent", context);
	CustomizationEvent_closure(dynamic_cast<const vw1__CustomizationEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationSucceeded_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationSysprep_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationSysprep", context);
	update_member(update, "guiRunOnce", "CustomizationGuiRunOnce", handle_obj_ptr(_obj.guiRunOnce), context);
	update_member(update, "guiUnattended", "CustomizationGuiUnattended", handle_obj_ptr(_obj.guiUnattended), context);
	update_member(update, "identification", "CustomizationIdentification", handle_obj_ptr(_obj.identification), context);
	update_member(update, "licenseFilePrintData", "CustomizationLicenseFilePrintData", handle_obj_ptr(_obj.licenseFilePrintData), context);
	update_member(update, "userData", "CustomizationUserData", handle_obj_ptr(_obj.userData), context);
	update("Base", "CustomizationIdentitySettings", context);
	CustomizationIdentitySettings_closure(dynamic_cast<const vw1__CustomizationIdentitySettings&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationSysprep_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.guiRunOnce)
			return new CustomizationGuiRunOnce_closure(*_obj.guiRunOnce);
		else
			return 0;
	case 1:
		if (_obj.guiUnattended)
			return new CustomizationGuiUnattended_closure(*_obj.guiUnattended);
		else
			return 0;
	case 2:
		if (_obj.identification)
			return new CustomizationIdentification_closure(*_obj.identification);
		else
			return 0;
	case 3:
		if (_obj.licenseFilePrintData)
			return new CustomizationLicenseFilePrintData_closure(*_obj.licenseFilePrintData);
		else
			return 0;
	case 4:
		if (_obj.userData)
			return new CustomizationUserData_closure(*_obj.userData);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return CustomizationIdentitySettings_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void CustomizationSysprepFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationSysprepFailed", context);
	update_member(update, "sysprepVersion", "xsd:string", basic2str(_obj.sysprepVersion), context);
	update_member(update, "systemVersion", "xsd:string", basic2str(_obj.systemVersion), context);
	update("Base", "CustomizationFailed", context);
	CustomizationFailed_closure(dynamic_cast<const vw1__CustomizationFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationSysprepFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationSysprepText_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationSysprepText", context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "CustomizationIdentitySettings", context);
	CustomizationIdentitySettings_closure(dynamic_cast<const vw1__CustomizationIdentitySettings&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationSysprepText_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationUnknownFailure_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationUnknownFailure", context);
	update("Base", "CustomizationFailed", context);
	CustomizationFailed_closure(dynamic_cast<const vw1__CustomizationFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationUnknownFailure_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationUnknownIpGenerator_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationUnknownIpGenerator", context);
	update("Base", "CustomizationIpGenerator", context);
	CustomizationIpGenerator_closure(dynamic_cast<const vw1__CustomizationIpGenerator&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationUnknownIpGenerator_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationUnknownIpV6Generator_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationUnknownIpV6Generator", context);
	update("Base", "CustomizationIpV6Generator", context);
	CustomizationIpV6Generator_closure(dynamic_cast<const vw1__CustomizationIpV6Generator&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationUnknownIpV6Generator_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationUnknownName_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationUnknownName", context);
	update("Base", "CustomizationName", context);
	CustomizationName_closure(dynamic_cast<const vw1__CustomizationName&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationUnknownName_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationUserData_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationUserData", context);
	update_member(update, "computerName", "CustomizationName", handle_obj_ptr(_obj.computerName), context);
	update_member(update, "fullName", "xsd:string", basic2str(_obj.fullName), context);
	update_member(update, "orgName", "xsd:string", basic2str(_obj.orgName), context);
	update_member(update, "productId", "xsd:string", basic2str(_obj.productId), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationUserData_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.computerName)
			return new CustomizationName_closure(*_obj.computerName);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void CustomizationVirtualMachineName_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationVirtualMachineName", context);
	update("Base", "CustomizationName", context);
	CustomizationName_closure(dynamic_cast<const vw1__CustomizationName&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationVirtualMachineName_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationWinOptions_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationWinOptions", context);
	update_member(update, "changeSID", "xsd:boolean", basic2str(_obj.changeSID), context);
	update_member(update, "deleteAccounts", "xsd:boolean", basic2str(_obj.deleteAccounts), context);
	update_member_with_version(update, "reboot", "CustomizationSysprepRebootOption", handle_obj_ptr(_obj.reboot), context, "2.5");
	update("Base", "CustomizationOptions", context);
	CustomizationOptions_closure(dynamic_cast<const vw1__CustomizationOptions&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationWinOptions_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DVPortConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVPortConfigInfo", context);
	update_member(update, "configVersion", "xsd:string", basic2str(_obj.configVersion), context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "scope", "ManagedEntity[]", a2s_object(_obj.scope, _obj.__sizescope), context);
	update_member(update, "setting", "DVPortSetting", handle_obj_ptr(_obj.setting), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVPortConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizescope)
				return new ManagedEntity_closure(_obj.scope[i]);
			else
				return 0;
		}
	case 4:
		if (_obj.setting)
			return new DVPortSetting_closure(*_obj.setting);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void DVPortConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVPortConfigSpec", context);
	update_member(update, "configVersion", "xsd:string", basic2str(_obj.configVersion), context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "operation", "xsd:string", basic2str(_obj.operation), context);
	update_member(update, "scope", "ManagedEntity[]", a2s_object(_obj.scope, _obj.__sizescope), context);
	update_member(update, "setting", "DVPortSetting", handle_obj_ptr(_obj.setting), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVPortConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizescope)
				return new ManagedEntity_closure(_obj.scope[i]);
			else
				return 0;
		}
	case 6:
		if (_obj.setting)
			return new DVPortSetting_closure(*_obj.setting);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void DVPortSetting_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVPortSetting", context);
	update_member(update, "blocked", "BoolPolicy", handle_obj_ptr(_obj.blocked), context);
	update_member(update, "inShapingPolicy", "DVSTrafficShapingPolicy", handle_obj_ptr(_obj.inShapingPolicy), context);
	update_member_with_version(update, "networkResourcePoolKey", "StringPolicy", handle_obj_ptr(_obj.networkResourcePoolKey), context, "5.0");
	update_member(update, "outShapingPolicy", "DVSTrafficShapingPolicy", handle_obj_ptr(_obj.outShapingPolicy), context);
	update_member(update, "vendorSpecificConfig", "DVSVendorSpecificConfig", handle_obj_ptr(_obj.vendorSpecificConfig), context);
	update_member_with_version(update, "vmDirectPathGen2Allowed", "BoolPolicy", handle_obj_ptr(_obj.vmDirectPathGen2Allowed), context, "4.1");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVPortSetting_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.blocked)
			return new BoolPolicy_closure(*_obj.blocked);
		else
			return 0;
	case 1:
		if (_obj.inShapingPolicy)
			return new DVSTrafficShapingPolicy_closure(*_obj.inShapingPolicy);
		else
			return 0;
	case 2:
		if (_obj.networkResourcePoolKey)
			return new StringPolicy_closure(*_obj.networkResourcePoolKey);
		else
			return 0;
	case 3:
		if (_obj.outShapingPolicy)
			return new DVSTrafficShapingPolicy_closure(*_obj.outShapingPolicy);
		else
			return 0;
	case 4:
		if (_obj.vendorSpecificConfig)
			return new DVSVendorSpecificConfig_closure(*_obj.vendorSpecificConfig);
		else
			return 0;
	case 5:
		if (_obj.vmDirectPathGen2Allowed)
			return new BoolPolicy_closure(*_obj.vmDirectPathGen2Allowed);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void DVPortState_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVPortState", context);
	update_member(update, "runtimeInfo", "DVPortStatus", handle_obj_ptr(_obj.runtimeInfo), context);
	update_member(update, "stats", "DistributedVirtualSwitchPortStatistics", handle_obj_ptr(_obj.stats), context);
	update_member(update, "vendorSpecificState", "DistributedVirtualSwitchKeyedOpaqueBlob[]", a2s_object(_obj.vendorSpecificState, _obj.__sizevendorSpecificState), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVPortState_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.runtimeInfo)
			return new DVPortStatus_closure(*_obj.runtimeInfo);
		else
			return 0;
	case 1:
		if (_obj.stats)
			return new DistributedVirtualSwitchPortStatistics_closure(*_obj.stats);
		else
			return 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevendorSpecificState)
				return new DistributedVirtualSwitchKeyedOpaqueBlob_closure(*_obj.vendorSpecificState[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void DVPortStatus_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVPortStatus", context);
	update_member(update, "blocked", "xsd:boolean", basic2str(_obj.blocked), context);
	update_member(update, "linkPeer", "xsd:string", basic2str(_obj.linkPeer), context);
	update_member(update, "linkUp", "xsd:boolean", basic2str(_obj.linkUp), context);
	update_member(update, "macAddress", "xsd:string", basic2str(_obj.macAddress), context);
	update_member(update, "mtu", "xsd:int", basic2str(_obj.mtu), context);
	update_member_with_version(update, "statusDetail", "xsd:string", basic2str(_obj.statusDetail), context, "4.1");
	update_member(update, "trunkingMode", "xsd:boolean", basic2str(_obj.trunkingMode), context);
	update_member(update, "vlanIds", "NumericRange[]", a2s_object(_obj.vlanIds, _obj.__sizevlanIds), context);
	update_member_with_version(update, "vmDirectPathGen2Active", "xsd:boolean", basic2str(_obj.vmDirectPathGen2Active), context, "4.1");
	update_member_with_version(update, "vmDirectPathGen2InactiveReasonExtended", "xsd:string", basic2str(_obj.vmDirectPathGen2InactiveReasonExtended), context, "4.1");
	update_member_with_version(update, "vmDirectPathGen2InactiveReasonNetwork", "xsd:string[]", a2s_basic(*_obj.vmDirectPathGen2InactiveReasonNetwork, _obj.__sizevmDirectPathGen2InactiveReasonNetwork), context, "4.1");
	update_member_with_version(update, "vmDirectPathGen2InactiveReasonOther", "xsd:string[]", a2s_basic(*_obj.vmDirectPathGen2InactiveReasonOther, _obj.__sizevmDirectPathGen2InactiveReasonOther), context, "4.1");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVPortStatus_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevlanIds)
				return new NumericRange_closure(*_obj.vlanIds[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 12) << 16) + arr_index);
	}
	return 0;
}

void DVPortgroupConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVPortgroupConfigInfo", context);
	update_member_with_version(update, "autoExpand", "xsd:boolean", basic2str(_obj.autoExpand), context, "5.0");
	update_member(update, "configVersion", "xsd:string", basic2str(_obj.configVersion), context);
	update_member(update, "defaultPortConfig", "DVPortSetting", handle_obj_ptr(_obj.defaultPortConfig), context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "distributedVirtualSwitch", "DistributedVirtualSwitch", handle_obj_ptr(_obj.distributedVirtualSwitch), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "numPorts", "xsd:int", basic2str(_obj.numPorts), context);
	update_member(update, "policy", "DVPortgroupPolicy", handle_obj_ptr(_obj.policy), context);
	update_member(update, "portNameFormat", "xsd:string", basic2str(_obj.portNameFormat), context);
	update_member(update, "scope", "ManagedEntity[]", a2s_object(_obj.scope, _obj.__sizescope), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update_member(update, "vendorSpecificConfig", "DistributedVirtualSwitchKeyedOpaqueBlob[]", a2s_object(_obj.vendorSpecificConfig, _obj.__sizevendorSpecificConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVPortgroupConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.defaultPortConfig)
			return new DVPortSetting_closure(*_obj.defaultPortConfig);
		else
			return 0;
	case 4:
		return _obj.distributedVirtualSwitch? 
			get_closure_from_mor(DistributedVirtualSwitch(_obj.distributedVirtualSwitch)) : 0;
	case 8:
		if (_obj.policy)
			return new DVPortgroupPolicy_closure(*_obj.policy);
		else
			return 0;
	case 10:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizescope)
				return new ManagedEntity_closure(_obj.scope[i]);
			else
				return 0;
		}
	case 12:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevendorSpecificConfig)
				return new DistributedVirtualSwitchKeyedOpaqueBlob_closure(*_obj.vendorSpecificConfig[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 13) << 16) + arr_index);
	}
	return 0;
}

void DVPortgroupConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVPortgroupConfigSpec", context);
	update_member_with_version(update, "autoExpand", "xsd:boolean", basic2str(_obj.autoExpand), context, "5.0");
	update_member(update, "configVersion", "xsd:string", basic2str(_obj.configVersion), context);
	update_member(update, "defaultPortConfig", "DVPortSetting", handle_obj_ptr(_obj.defaultPortConfig), context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "numPorts", "xsd:int", basic2str(_obj.numPorts), context);
	update_member(update, "policy", "DVPortgroupPolicy", handle_obj_ptr(_obj.policy), context);
	update_member(update, "portNameFormat", "xsd:string", basic2str(_obj.portNameFormat), context);
	update_member(update, "scope", "ManagedEntity[]", a2s_object(_obj.scope, _obj.__sizescope), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update_member(update, "vendorSpecificConfig", "DistributedVirtualSwitchKeyedOpaqueBlob[]", a2s_object(_obj.vendorSpecificConfig, _obj.__sizevendorSpecificConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVPortgroupConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.defaultPortConfig)
			return new DVPortSetting_closure(*_obj.defaultPortConfig);
		else
			return 0;
	case 6:
		if (_obj.policy)
			return new DVPortgroupPolicy_closure(*_obj.policy);
		else
			return 0;
	case 8:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizescope)
				return new ManagedEntity_closure(_obj.scope[i]);
			else
				return 0;
		}
	case 10:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevendorSpecificConfig)
				return new DistributedVirtualSwitchKeyedOpaqueBlob_closure(*_obj.vendorSpecificConfig[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void DVPortgroupCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVPortgroupCreatedEvent", context);
	update("Base", "DVPortgroupEvent", context);
	DVPortgroupEvent_closure(dynamic_cast<const vw1__DVPortgroupEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVPortgroupCreatedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DVPortgroupDestroyedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVPortgroupDestroyedEvent", context);
	update("Base", "DVPortgroupEvent", context);
	DVPortgroupEvent_closure(dynamic_cast<const vw1__DVPortgroupEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVPortgroupDestroyedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DVPortgroupEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVPortgroupEvent", context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVPortgroupEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DVPortgroupPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVPortgroupPolicy", context);
	update_member(update, "blockOverrideAllowed", "xsd:boolean", basic2str(_obj.blockOverrideAllowed), context);
	update_member(update, "livePortMovingAllowed", "xsd:boolean", basic2str(_obj.livePortMovingAllowed), context);
	update_member_with_version(update, "networkResourcePoolOverrideAllowed", "xsd:boolean", basic2str(_obj.networkResourcePoolOverrideAllowed), context, "5.0");
	update_member(update, "portConfigResetAtDisconnect", "xsd:boolean", basic2str(_obj.portConfigResetAtDisconnect), context);
	update_member(update, "shapingOverrideAllowed", "xsd:boolean", basic2str(_obj.shapingOverrideAllowed), context);
	update_member(update, "vendorConfigOverrideAllowed", "xsd:boolean", basic2str(_obj.vendorConfigOverrideAllowed), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVPortgroupPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DVPortgroupReconfiguredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVPortgroupReconfiguredEvent", context);
	update_member(update, "configSpec", "DVPortgroupConfigSpec", handle_obj_ptr(_obj.configSpec), context);
	update("Base", "DVPortgroupEvent", context);
	DVPortgroupEvent_closure(dynamic_cast<const vw1__DVPortgroupEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVPortgroupReconfiguredEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.configSpec)
			return new DVPortgroupConfigSpec_closure(*_obj.configSpec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DVPortgroupEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DVPortgroupRenamedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVPortgroupRenamedEvent", context);
	update_member(update, "newName", "xsd:string", basic2str(_obj.newName), context);
	update_member(update, "oldName", "xsd:string", basic2str(_obj.oldName), context);
	update("Base", "DVPortgroupEvent", context);
	DVPortgroupEvent_closure(dynamic_cast<const vw1__DVPortgroupEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVPortgroupRenamedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DVSCapability_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSCapability", context);
	update_member(update, "compatibleHostComponentProductInfo", "DistributedVirtualSwitchHostProductSpec[]", a2s_object(_obj.compatibleHostComponentProductInfo, _obj.__sizecompatibleHostComponentProductInfo), context);
	update_member(update, "dvPortGroupOperationSupported", "xsd:boolean", basic2str(_obj.dvPortGroupOperationSupported), context);
	update_member(update, "dvPortOperationSupported", "xsd:boolean", basic2str(_obj.dvPortOperationSupported), context);
	update_member(update, "dvsOperationSupported", "xsd:boolean", basic2str(_obj.dvsOperationSupported), context);
	update_member_with_version(update, "featuresSupported", "DVSFeatureCapability", handle_obj_ptr(_obj.featuresSupported), context, "4.1");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSCapability_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecompatibleHostComponentProductInfo)
				return new DistributedVirtualSwitchHostProductSpec_closure(*_obj.compatibleHostComponentProductInfo[i]);
			else
				return 0;
		}
	case 4:
		if (_obj.featuresSupported)
			return new DVSFeatureCapability_closure(*_obj.featuresSupported);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void DVSConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSConfigInfo", context);
	update_member(update, "configVersion", "xsd:string", basic2str(_obj.configVersion), context);
	update_member(update, "contact", "DVSContactInfo", handle_obj_ptr(_obj.contact), context);
	update_member(update, "createTime", "xsd:dateTime", basic2str(_obj.createTime), context);
	update_member(update, "defaultPortConfig", "DVPortSetting", handle_obj_ptr(_obj.defaultPortConfig), context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "extensionKey", "xsd:string", basic2str(_obj.extensionKey), context);
	update_member(update, "host", "DistributedVirtualSwitchHostMember[]", a2s_object(_obj.host, _obj.__sizehost), context);
	update_member(update, "maxPorts", "xsd:int", basic2str(_obj.maxPorts), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member_with_version(update, "networkResourceManagementEnabled", "xsd:boolean", basic2str(_obj.networkResourceManagementEnabled), context, "4.1");
	update_member(update, "numPorts", "xsd:int", basic2str(_obj.numPorts), context);
	update_member(update, "numStandalonePorts", "xsd:int", basic2str(_obj.numStandalonePorts), context);
	update_member(update, "policy", "DVSPolicy", handle_obj_ptr(_obj.policy), context);
	update_member(update, "productInfo", "DistributedVirtualSwitchProductSpec", handle_obj_ptr(_obj.productInfo), context);
	update_member_with_version(update, "switchIpAddress", "xsd:string", basic2str(_obj.switchIpAddress), context, "5.0");
	update_member(update, "targetInfo", "DistributedVirtualSwitchProductSpec", handle_obj_ptr(_obj.targetInfo), context);
	update_member(update, "uplinkPortgroup", "DistributedVirtualPortgroup[]", a2s_object(_obj.uplinkPortgroup, _obj.__sizeuplinkPortgroup), context);
	update_member(update, "uplinkPortPolicy", "DVSUplinkPortPolicy", handle_obj_ptr(_obj.uplinkPortPolicy), context);
	update_member(update, "uuid", "xsd:string", basic2str(_obj.uuid), context);
	update_member(update, "vendorSpecificConfig", "DistributedVirtualSwitchKeyedOpaqueBlob[]", a2s_object(_obj.vendorSpecificConfig, _obj.__sizevendorSpecificConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.contact)
			return new DVSContactInfo_closure(*_obj.contact);
		else
			return 0;
	case 3:
		if (_obj.defaultPortConfig)
			return new DVPortSetting_closure(*_obj.defaultPortConfig);
		else
			return 0;
	case 6:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehost)
				return new DistributedVirtualSwitchHostMember_closure(*_obj.host[i]);
			else
				return 0;
		}
	case 12:
		if (_obj.policy)
			return new DVSPolicy_closure(*_obj.policy);
		else
			return 0;
	case 13:
		if (_obj.productInfo)
			return new DistributedVirtualSwitchProductSpec_closure(*_obj.productInfo);
		else
			return 0;
	case 15:
		if (_obj.targetInfo)
			return new DistributedVirtualSwitchProductSpec_closure(*_obj.targetInfo);
		else
			return 0;
	case 16:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeuplinkPortgroup)
				return new DistributedVirtualPortgroup_closure(_obj.uplinkPortgroup[i]);
			else
				return 0;
		}
	case 17:
		if (_obj.uplinkPortPolicy)
			return new DVSUplinkPortPolicy_closure(*_obj.uplinkPortPolicy);
		else
			return 0;
	case 19:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevendorSpecificConfig)
				return new DistributedVirtualSwitchKeyedOpaqueBlob_closure(*_obj.vendorSpecificConfig[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 20) << 16) + arr_index);
	}
	return 0;
}

void DVSConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSConfigSpec", context);
	update_member(update, "configVersion", "xsd:string", basic2str(_obj.configVersion), context);
	update_member(update, "contact", "DVSContactInfo", handle_obj_ptr(_obj.contact), context);
	update_member(update, "defaultPortConfig", "DVPortSetting", handle_obj_ptr(_obj.defaultPortConfig), context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "extensionKey", "xsd:string", basic2str(_obj.extensionKey), context);
	update_member(update, "host", "DistributedVirtualSwitchHostMemberConfigSpec[]", a2s_object(_obj.host, _obj.__sizehost), context);
	update_member(update, "maxPorts", "xsd:int", basic2str(_obj.maxPorts), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "numStandalonePorts", "xsd:int", basic2str(_obj.numStandalonePorts), context);
	update_member(update, "policy", "DVSPolicy", handle_obj_ptr(_obj.policy), context);
	update_member_with_version(update, "switchIpAddress", "xsd:string", basic2str(_obj.switchIpAddress), context, "5.0");
	update_member(update, "uplinkPortgroup", "DistributedVirtualPortgroup[]", a2s_object(_obj.uplinkPortgroup, _obj.__sizeuplinkPortgroup), context);
	update_member(update, "uplinkPortPolicy", "DVSUplinkPortPolicy", handle_obj_ptr(_obj.uplinkPortPolicy), context);
	update_member(update, "vendorSpecificConfig", "DistributedVirtualSwitchKeyedOpaqueBlob[]", a2s_object(_obj.vendorSpecificConfig, _obj.__sizevendorSpecificConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.contact)
			return new DVSContactInfo_closure(*_obj.contact);
		else
			return 0;
	case 2:
		if (_obj.defaultPortConfig)
			return new DVPortSetting_closure(*_obj.defaultPortConfig);
		else
			return 0;
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehost)
				return new DistributedVirtualSwitchHostMemberConfigSpec_closure(*_obj.host[i]);
			else
				return 0;
		}
	case 9:
		if (_obj.policy)
			return new DVSPolicy_closure(*_obj.policy);
		else
			return 0;
	case 11:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeuplinkPortgroup)
				return new DistributedVirtualPortgroup_closure(_obj.uplinkPortgroup[i]);
			else
				return 0;
		}
	case 12:
		if (_obj.uplinkPortPolicy)
			return new DVSUplinkPortPolicy_closure(*_obj.uplinkPortPolicy);
		else
			return 0;
	case 13:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevendorSpecificConfig)
				return new DistributedVirtualSwitchKeyedOpaqueBlob_closure(*_obj.vendorSpecificConfig[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 14) << 16) + arr_index);
	}
	return 0;
}

void DVSContactInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSContactInfo", context);
	update_member(update, "contact", "xsd:string", basic2str(_obj.contact), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSContactInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DVSCreateSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSCreateSpec", context);
	update_member(update, "capability", "DVSCapability", handle_obj_ptr(_obj.capability), context);
	update_member(update, "configSpec", "DVSConfigSpec", handle_obj_ptr(_obj.configSpec), context);
	update_member(update, "productInfo", "DistributedVirtualSwitchProductSpec", handle_obj_ptr(_obj.productInfo), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSCreateSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.capability)
			return new DVSCapability_closure(*_obj.capability);
		else
			return 0;
	case 1:
		if (_obj.configSpec)
			return new DVSConfigSpec_closure(*_obj.configSpec);
		else
			return 0;
	case 2:
		if (_obj.productInfo)
			return new DistributedVirtualSwitchProductSpec_closure(*_obj.productInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void DVSFailureCriteria_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSFailureCriteria", context);
	update_member(update, "checkBeacon", "BoolPolicy", handle_obj_ptr(_obj.checkBeacon), context);
	update_member(update, "checkDuplex", "BoolPolicy", handle_obj_ptr(_obj.checkDuplex), context);
	update_member(update, "checkErrorPercent", "BoolPolicy", handle_obj_ptr(_obj.checkErrorPercent), context);
	update_member(update, "checkSpeed", "StringPolicy", handle_obj_ptr(_obj.checkSpeed), context);
	update_member(update, "fullDuplex", "BoolPolicy", handle_obj_ptr(_obj.fullDuplex), context);
	update_member(update, "percentage", "IntPolicy", handle_obj_ptr(_obj.percentage), context);
	update_member(update, "speed", "IntPolicy", handle_obj_ptr(_obj.speed), context);
	update("Base", "InheritablePolicy", context);
	InheritablePolicy_closure(dynamic_cast<const vw1__InheritablePolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSFailureCriteria_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.checkBeacon)
			return new BoolPolicy_closure(*_obj.checkBeacon);
		else
			return 0;
	case 1:
		if (_obj.checkDuplex)
			return new BoolPolicy_closure(*_obj.checkDuplex);
		else
			return 0;
	case 2:
		if (_obj.checkErrorPercent)
			return new BoolPolicy_closure(*_obj.checkErrorPercent);
		else
			return 0;
	case 3:
		if (_obj.checkSpeed)
			return new StringPolicy_closure(*_obj.checkSpeed);
		else
			return 0;
	case 4:
		if (_obj.fullDuplex)
			return new BoolPolicy_closure(*_obj.fullDuplex);
		else
			return 0;
	case 5:
		if (_obj.percentage)
			return new IntPolicy_closure(*_obj.percentage);
		else
			return 0;
	case 6:
		if (_obj.speed)
			return new IntPolicy_closure(*_obj.speed);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return InheritablePolicy_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void DVSFeatureCapability_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSFeatureCapability", context);
	update_member_with_version(update, "networkResourceManagementCapability", "DVSNetworkResourceManagementCapability", handle_obj_ptr(_obj.networkResourceManagementCapability), context, "5.0");
	update_member(update, "networkResourceManagementSupported", "xsd:boolean", basic2str(_obj.networkResourceManagementSupported), context);
	update_member(update, "networkResourcePoolHighShareValue", "xsd:int", basic2str(_obj.networkResourcePoolHighShareValue), context);
	update_member(update, "nicTeamingPolicy", "xsd:string[]", a2s_basic(*_obj.nicTeamingPolicy, _obj.__sizenicTeamingPolicy), context);
	update_member(update, "vmDirectPathGen2Supported", "xsd:boolean", basic2str(_obj.vmDirectPathGen2Supported), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSFeatureCapability_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.networkResourceManagementCapability)
			return new DVSNetworkResourceManagementCapability_closure(*_obj.networkResourceManagementCapability);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void DVSManagerDvsConfigTarget_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSManagerDvsConfigTarget", context);
	update_member(update, "distributedVirtualPortgroup", "DistributedVirtualPortgroupInfo[]", a2s_object(_obj.distributedVirtualPortgroup, _obj.__sizedistributedVirtualPortgroup), context);
	update_member(update, "distributedVirtualSwitch", "DistributedVirtualSwitchInfo[]", a2s_object(_obj.distributedVirtualSwitch, _obj.__sizedistributedVirtualSwitch), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSManagerDvsConfigTarget_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedistributedVirtualPortgroup)
				return new DistributedVirtualPortgroupInfo_closure(*_obj.distributedVirtualPortgroup[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedistributedVirtualSwitch)
				return new DistributedVirtualSwitchInfo_closure(*_obj.distributedVirtualSwitch[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DVSNameArrayUplinkPortPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSNameArrayUplinkPortPolicy", context);
	update_member(update, "uplinkPortName", "xsd:string[]", a2s_basic(*_obj.uplinkPortName, _obj.__sizeuplinkPortName), context);
	update("Base", "DVSUplinkPortPolicy", context);
	DVSUplinkPortPolicy_closure(dynamic_cast<const vw1__DVSUplinkPortPolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSNameArrayUplinkPortPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DVSNetworkResourceManagementCapability_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSNetworkResourceManagementCapability", context);
	update_member(update, "networkResourceManagementSupported", "xsd:boolean", basic2str(_obj.networkResourceManagementSupported), context);
	update_member(update, "networkResourcePoolHighShareValue", "xsd:int", basic2str(_obj.networkResourcePoolHighShareValue), context);
	update_member(update, "qosSupported", "xsd:boolean", basic2str(_obj.qosSupported), context);
	update_member(update, "userDefinedNetworkResourcePoolsSupported", "xsd:boolean", basic2str(_obj.userDefinedNetworkResourcePoolsSupported), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSNetworkResourceManagementCapability_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DVSNetworkResourcePool_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSNetworkResourcePool", context);
	update_member(update, "allocationInfo", "DVSNetworkResourcePoolAllocationInfo", handle_obj_ptr(_obj.allocationInfo), context);
	update_member(update, "configVersion", "xsd:string", basic2str(_obj.configVersion), context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSNetworkResourcePool_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.allocationInfo)
			return new DVSNetworkResourcePoolAllocationInfo_closure(*_obj.allocationInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void DVSNetworkResourcePoolAllocationInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSNetworkResourcePoolAllocationInfo", context);
	update_member(update, "limit", "xsd:long", basic2str(_obj.limit), context);
	update_member_with_version(update, "priorityTag", "xsd:int", basic2str(_obj.priorityTag), context, "5.0");
	update_member(update, "shares", "SharesInfo", handle_obj_ptr(_obj.shares), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSNetworkResourcePoolAllocationInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.shares)
			return new SharesInfo_closure(*_obj.shares);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void DVSNetworkResourcePoolConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSNetworkResourcePoolConfigSpec", context);
	update_member(update, "allocationInfo", "DVSNetworkResourcePoolAllocationInfo", handle_obj_ptr(_obj.allocationInfo), context);
	update_member(update, "configVersion", "xsd:string", basic2str(_obj.configVersion), context);
	update_member_with_version(update, "description", "xsd:string", basic2str(_obj.description), context, "5.0");
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member_with_version(update, "name", "xsd:string", basic2str(_obj.name), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSNetworkResourcePoolConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.allocationInfo)
			return new DVSNetworkResourcePoolAllocationInfo_closure(*_obj.allocationInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void DVSPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSPolicy", context);
	update_member(update, "autoPreInstallAllowed", "xsd:boolean", basic2str(_obj.autoPreInstallAllowed), context);
	update_member(update, "autoUpgradeAllowed", "xsd:boolean", basic2str(_obj.autoUpgradeAllowed), context);
	update_member(update, "partialUpgradeAllowed", "xsd:boolean", basic2str(_obj.partialUpgradeAllowed), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DVSSecurityPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSSecurityPolicy", context);
	update_member(update, "allowPromiscuous", "BoolPolicy", handle_obj_ptr(_obj.allowPromiscuous), context);
	update_member(update, "forgedTransmits", "BoolPolicy", handle_obj_ptr(_obj.forgedTransmits), context);
	update_member(update, "macChanges", "BoolPolicy", handle_obj_ptr(_obj.macChanges), context);
	update("Base", "InheritablePolicy", context);
	InheritablePolicy_closure(dynamic_cast<const vw1__InheritablePolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSSecurityPolicy_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.allowPromiscuous)
			return new BoolPolicy_closure(*_obj.allowPromiscuous);
		else
			return 0;
	case 1:
		if (_obj.forgedTransmits)
			return new BoolPolicy_closure(*_obj.forgedTransmits);
		else
			return 0;
	case 2:
		if (_obj.macChanges)
			return new BoolPolicy_closure(*_obj.macChanges);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return InheritablePolicy_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void DVSSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSSummary", context);
	update_member(update, "contact", "DVSContactInfo", handle_obj_ptr(_obj.contact), context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "host", "HostSystem[]", a2s_object(_obj.host, _obj.__sizehost), context);
	update_member(update, "hostMember", "HostSystem[]", a2s_object(_obj.hostMember, _obj.__sizehostMember), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "numPorts", "xsd:int", basic2str(_obj.numPorts), context);
	update_member(update, "portgroupName", "xsd:string[]", a2s_basic(*_obj.portgroupName, _obj.__sizeportgroupName), context);
	update_member(update, "productInfo", "DistributedVirtualSwitchProductSpec", handle_obj_ptr(_obj.productInfo), context);
	update_member(update, "uuid", "xsd:string", basic2str(_obj.uuid), context);
	update_member(update, "vm", "VirtualMachine[]", a2s_object(_obj.vm, _obj.__sizevm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSSummary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.contact)
			return new DVSContactInfo_closure(*_obj.contact);
		else
			return 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehost)
				return new HostSystem_closure(_obj.host[i]);
			else
				return 0;
		}
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehostMember)
				return new HostSystem_closure(_obj.hostMember[i]);
			else
				return 0;
		}
	case 7:
		if (_obj.productInfo)
			return new DistributedVirtualSwitchProductSpec_closure(*_obj.productInfo);
		else
			return 0;
	case 9:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevm)
				return new VirtualMachine_closure(_obj.vm[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 10) << 16) + arr_index);
	}
	return 0;
}

void DVSTrafficShapingPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSTrafficShapingPolicy", context);
	update_member(update, "averageBandwidth", "LongPolicy", handle_obj_ptr(_obj.averageBandwidth), context);
	update_member(update, "burstSize", "LongPolicy", handle_obj_ptr(_obj.burstSize), context);
	update_member(update, "enabled", "BoolPolicy", handle_obj_ptr(_obj.enabled), context);
	update_member(update, "peakBandwidth", "LongPolicy", handle_obj_ptr(_obj.peakBandwidth), context);
	update("Base", "InheritablePolicy", context);
	InheritablePolicy_closure(dynamic_cast<const vw1__InheritablePolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSTrafficShapingPolicy_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.averageBandwidth)
			return new LongPolicy_closure(*_obj.averageBandwidth);
		else
			return 0;
	case 1:
		if (_obj.burstSize)
			return new LongPolicy_closure(*_obj.burstSize);
		else
			return 0;
	case 2:
		if (_obj.enabled)
			return new BoolPolicy_closure(*_obj.enabled);
		else
			return 0;
	case 3:
		if (_obj.peakBandwidth)
			return new LongPolicy_closure(*_obj.peakBandwidth);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return InheritablePolicy_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void DVSUplinkPortPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSUplinkPortPolicy", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSUplinkPortPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DVSVendorSpecificConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVSVendorSpecificConfig", context);
	update_member(update, "keyValue", "DistributedVirtualSwitchKeyedOpaqueBlob[]", a2s_object(_obj.keyValue, _obj.__sizekeyValue), context);
	update("Base", "InheritablePolicy", context);
	InheritablePolicy_closure(dynamic_cast<const vw1__InheritablePolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVSVendorSpecificConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizekeyValue)
				return new DistributedVirtualSwitchKeyedOpaqueBlob_closure(*_obj.keyValue[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return InheritablePolicy_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DailyTaskScheduler_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DailyTaskScheduler", context);
	update_member(update, "hour", "xsd:int", basic2str(_obj.hour), context);
	update("Base", "HourlyTaskScheduler", context);
	HourlyTaskScheduler_closure(dynamic_cast<const vw1__HourlyTaskScheduler&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DailyTaskScheduler_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DasAdmissionControlDisabledEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DasAdmissionControlDisabledEvent", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DasAdmissionControlDisabledEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DasAdmissionControlEnabledEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DasAdmissionControlEnabledEvent", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DasAdmissionControlEnabledEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DasAgentFoundEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DasAgentFoundEvent", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DasAgentFoundEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DasAgentUnavailableEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DasAgentUnavailableEvent", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DasAgentUnavailableEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DasClusterIsolatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DasClusterIsolatedEvent", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DasClusterIsolatedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DasDisabledEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DasDisabledEvent", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DasDisabledEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DasEnabledEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DasEnabledEvent", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DasEnabledEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DasHeartbeatDatastoreInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DasHeartbeatDatastoreInfo", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "hosts", "HostSystem[]", a2s_object(_obj.hosts, _obj.__sizehosts), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DasHeartbeatDatastoreInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehosts)
				return new HostSystem_closure(_obj.hosts[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DasHostFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DasHostFailedEvent", context);
	update_member(update, "failedHost", "HostEventArgument", handle_obj_ptr(_obj.failedHost), context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DasHostFailedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.failedHost)
			return new HostEventArgument_closure(*_obj.failedHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ClusterEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DasHostIsolatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DasHostIsolatedEvent", context);
	update_member(update, "isolatedHost", "HostEventArgument", handle_obj_ptr(_obj.isolatedHost), context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DasHostIsolatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.isolatedHost)
			return new HostEventArgument_closure(*_obj.isolatedHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ClusterEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DatabaseSizeEstimate_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatabaseSizeEstimate", context);
	update_member(update, "size", "xsd:long", basic2str(_obj.size), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatabaseSizeEstimate_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatabaseSizeParam_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatabaseSizeParam", context);
	update_member(update, "inventoryDesc", "InventoryDescription", handle_obj_ptr(_obj.inventoryDesc), context);
	update_member(update, "perfStatsDesc", "PerformanceStatisticsDescription", handle_obj_ptr(_obj.perfStatsDesc), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatabaseSizeParam_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.inventoryDesc)
			return new InventoryDescription_closure(*_obj.inventoryDesc);
		else
			return 0;
	case 1:
		if (_obj.perfStatsDesc)
			return new PerformanceStatisticsDescription_closure(*_obj.perfStatsDesc);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DatacenterCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatacenterCreatedEvent", context);
	update_member(update, "parent", "FolderEventArgument", handle_obj_ptr(_obj.parent), context);
	update("Base", "DatacenterEvent", context);
	DatacenterEvent_closure(dynamic_cast<const vw1__DatacenterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatacenterCreatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.parent)
			return new FolderEventArgument_closure(*_obj.parent);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DatacenterEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DatacenterEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatacenterEvent", context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatacenterEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatacenterEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatacenterEventArgument", context);
	update_member(update, "datacenter", "Datacenter", handle_obj_ptr(_obj.datacenter), context);
	update("Base", "EntityEventArgument", context);
	EntityEventArgument_closure(dynamic_cast<const vw1__EntityEventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatacenterEventArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datacenter? 
			get_closure_from_mor(Datacenter(_obj.datacenter)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return EntityEventArgument_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DatacenterMismatchArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatacenterMismatchArgument", context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "inputDatacenter", "Datacenter", handle_obj_ptr(_obj.inputDatacenter), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatacenterMismatchArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	case 1:
		return _obj.inputDatacenter? 
			get_closure_from_mor(Datacenter(_obj.inputDatacenter)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DatacenterRenamedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatacenterRenamedEvent", context);
	update_member(update, "newName", "xsd:string", basic2str(_obj.newName), context);
	update_member(update, "oldName", "xsd:string", basic2str(_obj.oldName), context);
	update("Base", "DatacenterEvent", context);
	DatacenterEvent_closure(dynamic_cast<const vw1__DatacenterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatacenterRenamedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatastoreCapability_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreCapability", context);
	update_member(update, "directoryHierarchySupported", "xsd:boolean", basic2str(_obj.directoryHierarchySupported), context);
	update_member(update, "perFileThinProvisioningSupported", "xsd:boolean", basic2str(_obj.perFileThinProvisioningSupported), context);
	update_member(update, "rawDiskMappingsSupported", "xsd:boolean", basic2str(_obj.rawDiskMappingsSupported), context);
	update_member_with_version(update, "storageIORMSupported", "xsd:boolean", basic2str(_obj.storageIORMSupported), context, "4.1");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreCapability_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatastoreCapacityIncreasedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreCapacityIncreasedEvent", context);
	update_member(update, "newCapacity", "xsd:long", basic2str(_obj.newCapacity), context);
	update_member(update, "oldCapacity", "xsd:long", basic2str(_obj.oldCapacity), context);
	update("Base", "DatastoreEvent", context);
	DatastoreEvent_closure(dynamic_cast<const vw1__DatastoreEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreCapacityIncreasedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatastoreDestroyedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreDestroyedEvent", context);
	update("Base", "DatastoreEvent", context);
	DatastoreEvent_closure(dynamic_cast<const vw1__DatastoreEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreDestroyedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatastoreDiscoveredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreDiscoveredEvent", context);
	update_member(update, "datastore", "DatastoreEventArgument", handle_obj_ptr(_obj.datastore), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreDiscoveredEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.datastore)
			return new DatastoreEventArgument_closure(*_obj.datastore);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DatastoreDuplicatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreDuplicatedEvent", context);
	update("Base", "DatastoreEvent", context);
	DatastoreEvent_closure(dynamic_cast<const vw1__DatastoreEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreDuplicatedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatastoreEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreEvent", context);
	update_member(update, "datastore", "DatastoreEventArgument", handle_obj_ptr(_obj.datastore), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.datastore)
			return new DatastoreEventArgument_closure(*_obj.datastore);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return Event_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DatastoreEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreEventArgument", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update("Base", "EntityEventArgument", context);
	EntityEventArgument_closure(dynamic_cast<const vw1__EntityEventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreEventArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return EntityEventArgument_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DatastoreFileCopiedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreFileCopiedEvent", context);
	update_member(update, "sourceDatastore", "DatastoreEventArgument", handle_obj_ptr(_obj.sourceDatastore), context);
	update_member(update, "sourceFile", "xsd:string", basic2str(_obj.sourceFile), context);
	update("Base", "DatastoreFileEvent", context);
	DatastoreFileEvent_closure(dynamic_cast<const vw1__DatastoreFileEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreFileCopiedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.sourceDatastore)
			return new DatastoreEventArgument_closure(*_obj.sourceDatastore);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DatastoreFileEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DatastoreFileDeletedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreFileDeletedEvent", context);
	update("Base", "DatastoreFileEvent", context);
	DatastoreFileEvent_closure(dynamic_cast<const vw1__DatastoreFileEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreFileDeletedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatastoreFileEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreFileEvent", context);
	update_member(update, "targetFile", "xsd:string", basic2str(_obj.targetFile), context);
	update("Base", "DatastoreEvent", context);
	DatastoreEvent_closure(dynamic_cast<const vw1__DatastoreEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreFileEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatastoreFileMovedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreFileMovedEvent", context);
	update_member(update, "sourceDatastore", "DatastoreEventArgument", handle_obj_ptr(_obj.sourceDatastore), context);
	update_member(update, "sourceFile", "xsd:string", basic2str(_obj.sourceFile), context);
	update("Base", "DatastoreFileEvent", context);
	DatastoreFileEvent_closure(dynamic_cast<const vw1__DatastoreFileEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreFileMovedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.sourceDatastore)
			return new DatastoreEventArgument_closure(*_obj.sourceDatastore);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DatastoreFileEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DatastoreHostMount_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreHostMount", context);
	update_member(update, "key", "HostSystem", handle_obj_ptr(_obj.key), context);
	update_member(update, "mountInfo", "HostMountInfo", handle_obj_ptr(_obj.mountInfo), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreHostMount_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.key? 
			get_closure_from_mor(HostSystem(_obj.key)) : 0;
	case 1:
		if (_obj.mountInfo)
			return new HostMountInfo_closure(*_obj.mountInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DatastoreIORMReconfiguredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreIORMReconfiguredEvent", context);
	update("Base", "DatastoreEvent", context);
	DatastoreEvent_closure(dynamic_cast<const vw1__DatastoreEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreIORMReconfiguredEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatastoreInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreInfo", context);
	update_member(update, "freeSpace", "xsd:long", basic2str(_obj.freeSpace), context);
	update_member(update, "maxFileSize", "xsd:long", basic2str(_obj.maxFileSize), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member_with_version(update, "timestamp", "xsd:dateTime", basic2str(_obj.timestamp), context, "4.0");
	update_member(update, "url", "xsd:string", basic2str(_obj.url), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatastoreMountPathDatastorePair_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreMountPathDatastorePair", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "oldMountPath", "xsd:string", basic2str(_obj.oldMountPath), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreMountPathDatastorePair_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DatastoreOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreOption", context);
	update_member(update, "unsupportedVolumes", "VirtualMachineDatastoreVolumeOption[]", a2s_object(_obj.unsupportedVolumes, _obj.__sizeunsupportedVolumes), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeunsupportedVolumes)
				return new VirtualMachineDatastoreVolumeOption_closure(*_obj.unsupportedVolumes[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DatastorePrincipalConfigured_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastorePrincipalConfigured", context);
	update_member(update, "datastorePrincipal", "xsd:string", basic2str(_obj.datastorePrincipal), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastorePrincipalConfigured_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatastoreRemovedOnHostEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreRemovedOnHostEvent", context);
	update_member(update, "datastore", "DatastoreEventArgument", handle_obj_ptr(_obj.datastore), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreRemovedOnHostEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.datastore)
			return new DatastoreEventArgument_closure(*_obj.datastore);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DatastoreRenamedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreRenamedEvent", context);
	update_member(update, "newName", "xsd:string", basic2str(_obj.newName), context);
	update_member(update, "oldName", "xsd:string", basic2str(_obj.oldName), context);
	update("Base", "DatastoreEvent", context);
	DatastoreEvent_closure(dynamic_cast<const vw1__DatastoreEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreRenamedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatastoreRenamedOnHostEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreRenamedOnHostEvent", context);
	update_member(update, "newName", "xsd:string", basic2str(_obj.newName), context);
	update_member(update, "oldName", "xsd:string", basic2str(_obj.oldName), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreRenamedOnHostEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatastoreSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreSummary", context);
	update_member(update, "accessible", "xsd:boolean", basic2str(_obj.accessible), context);
	update_member(update, "capacity", "xsd:long", basic2str(_obj.capacity), context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "freeSpace", "xsd:long", basic2str(_obj.freeSpace), context);
	update_member_with_version(update, "maintenanceMode", "xsd:string", basic2str(_obj.maintenanceMode), context, "5.0");
	update_member(update, "multipleHostAccess", "xsd:boolean", basic2str(_obj.multipleHostAccess), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update_member_with_version(update, "uncommitted", "xsd:long", basic2str(_obj.uncommitted), context, "4.0");
	update_member(update, "url", "xsd:string", basic2str(_obj.url), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreSummary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 10) << 16) + arr_index);
	}
	return 0;
}

void DateTimeProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DateTimeProfile", context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DateTimeProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void Description_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Description", context);
	update_member(update, "label", "xsd:string", basic2str(_obj.label), context);
	update_member(update, "summary", "xsd:string", basic2str(_obj.summary), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* Description_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DeviceBackedVirtualDiskSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DeviceBackedVirtualDiskSpec", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update("Base", "VirtualDiskSpec", context);
	VirtualDiskSpec_closure(dynamic_cast<const vw1__VirtualDiskSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DeviceBackedVirtualDiskSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DiagnosticManagerBundleInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DiagnosticManagerBundleInfo", context);
	update_member(update, "system", "HostSystem", handle_obj_ptr(_obj.system), context);
	update_member(update, "url", "xsd:string", basic2str(_obj.url), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DiagnosticManagerBundleInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.system? 
			get_closure_from_mor(HostSystem(_obj.system)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DiagnosticManagerLogDescriptor_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DiagnosticManagerLogDescriptor", context);
	update_member(update, "creator", "xsd:string", basic2str(_obj.creator), context);
	update_member(update, "fileName", "xsd:string", basic2str(_obj.fileName), context);
	update_member(update, "format", "xsd:string", basic2str(_obj.format), context);
	update_member(update, "info", "Description", handle_obj_ptr(_obj.info), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "mimeType", "xsd:string", basic2str(_obj.mimeType), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DiagnosticManagerLogDescriptor_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		if (_obj.info)
			return new Description_closure(*_obj.info);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void DiagnosticManagerLogHeader_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DiagnosticManagerLogHeader", context);
	update_member(update, "lineEnd", "xsd:int", basic2str(_obj.lineEnd), context);
	update_member(update, "lineStart", "xsd:int", basic2str(_obj.lineStart), context);
	update_member(update, "lineText", "xsd:string[]", a2s_basic(*_obj.lineText, _obj.__sizelineText), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DiagnosticManagerLogHeader_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DiskChangeExtent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DiskChangeExtent", context);
	update_member(update, "length", "xsd:long", basic2str(_obj.length), context);
	update_member(update, "start", "xsd:long", basic2str(_obj.start), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DiskChangeExtent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DiskChangeInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DiskChangeInfo", context);
	update_member(update, "changedArea", "DiskChangeExtent[]", a2s_object(_obj.changedArea, _obj.__sizechangedArea), context);
	update_member(update, "length", "xsd:long", basic2str(_obj.length), context);
	update_member(update, "startOffset", "xsd:long", basic2str(_obj.startOffset), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DiskChangeInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizechangedArea)
				return new DiskChangeExtent_closure(*_obj.changedArea[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualPort_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualPort", context);
	update_member(update, "config", "DVPortConfigInfo", handle_obj_ptr(_obj.config), context);
	update_member(update, "conflict", "xsd:boolean", basic2str(_obj.conflict), context);
	update_member(update, "conflictPortKey", "xsd:string", basic2str(_obj.conflictPortKey), context);
	update_member(update, "connectee", "DistributedVirtualSwitchPortConnectee", handle_obj_ptr(_obj.connectee), context);
	update_member(update, "connectionCookie", "xsd:int", basic2str(_obj.connectionCookie), context);
	update_member(update, "dvsUuid", "xsd:string", basic2str(_obj.dvsUuid), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "lastStatusChange", "xsd:dateTime", basic2str(_obj.lastStatusChange), context);
	update_member(update, "portgroupKey", "xsd:string", basic2str(_obj.portgroupKey), context);
	update_member(update, "proxyHost", "HostSystem", handle_obj_ptr(_obj.proxyHost), context);
	update_member(update, "state", "DVPortState", handle_obj_ptr(_obj.state), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualPort_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.config)
			return new DVPortConfigInfo_closure(*_obj.config);
		else
			return 0;
	case 3:
		if (_obj.connectee)
			return new DistributedVirtualSwitchPortConnectee_closure(*_obj.connectee);
		else
			return 0;
	case 9:
		return _obj.proxyHost? 
			get_closure_from_mor(HostSystem(_obj.proxyHost)) : 0;
	case 10:
		if (_obj.state)
			return new DVPortState_closure(*_obj.state);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualPortgroupInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualPortgroupInfo", context);
	update_member(update, "portgroup", "DistributedVirtualPortgroup", handle_obj_ptr(_obj.portgroup), context);
	update_member(update, "portgroupKey", "xsd:string", basic2str(_obj.portgroupKey), context);
	update_member(update, "portgroupName", "xsd:string", basic2str(_obj.portgroupName), context);
	update_member(update, "portgroupType", "xsd:string", basic2str(_obj.portgroupType), context);
	update_member(update, "switchName", "xsd:string", basic2str(_obj.switchName), context);
	update_member(update, "switchUuid", "xsd:string", basic2str(_obj.switchUuid), context);
	update_member(update, "uplinkPortgroup", "xsd:boolean", basic2str(_obj.uplinkPortgroup), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualPortgroupInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.portgroup? 
			get_closure_from_mor(DistributedVirtualPortgroup(_obj.portgroup)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchHostMember_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchHostMember", context);
	update_member(update, "config", "DistributedVirtualSwitchHostMemberConfigInfo", handle_obj_ptr(_obj.config), context);
	update_member(update, "productInfo", "DistributedVirtualSwitchProductSpec", handle_obj_ptr(_obj.productInfo), context);
	update_member_with_version(update, "runtimeState", "DistributedVirtualSwitchHostMemberRuntimeState", handle_obj_ptr(_obj.runtimeState), context, "5.0");
	update_member(update, "status", "xsd:string", basic2str(_obj.status), context);
	update_member_with_version(update, "statusDetail", "xsd:string", basic2str(_obj.statusDetail), context, "4.1");
	update_member(update, "uplinkPortKey", "xsd:string[]", a2s_basic(*_obj.uplinkPortKey, _obj.__sizeuplinkPortKey), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchHostMember_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.config)
			return new DistributedVirtualSwitchHostMemberConfigInfo_closure(*_obj.config);
		else
			return 0;
	case 1:
		if (_obj.productInfo)
			return new DistributedVirtualSwitchProductSpec_closure(*_obj.productInfo);
		else
			return 0;
	case 2:
		if (_obj.runtimeState)
			return new DistributedVirtualSwitchHostMemberRuntimeState_closure(*_obj.runtimeState);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchHostMemberBacking_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchHostMemberBacking", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchHostMemberBacking_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DistributedVirtualSwitchHostMemberConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchHostMemberConfigInfo", context);
	update_member(update, "backing", "DistributedVirtualSwitchHostMemberBacking", handle_obj_ptr(_obj.backing), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "maxProxySwitchPorts", "xsd:int", basic2str(_obj.maxProxySwitchPorts), context);
	update_member(update, "vendorSpecificConfig", "DistributedVirtualSwitchKeyedOpaqueBlob[]", a2s_object(_obj.vendorSpecificConfig, _obj.__sizevendorSpecificConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchHostMemberConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.backing)
			return new DistributedVirtualSwitchHostMemberBacking_closure(*_obj.backing);
		else
			return 0;
	case 1:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevendorSpecificConfig)
				return new DistributedVirtualSwitchKeyedOpaqueBlob_closure(*_obj.vendorSpecificConfig[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchHostMemberConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchHostMemberConfigSpec", context);
	update_member(update, "backing", "DistributedVirtualSwitchHostMemberBacking", handle_obj_ptr(_obj.backing), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "maxProxySwitchPorts", "xsd:int", basic2str(_obj.maxProxySwitchPorts), context);
	update_member(update, "operation", "xsd:string", basic2str(_obj.operation), context);
	update_member(update, "vendorSpecificConfig", "DistributedVirtualSwitchKeyedOpaqueBlob[]", a2s_object(_obj.vendorSpecificConfig, _obj.__sizevendorSpecificConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchHostMemberConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.backing)
			return new DistributedVirtualSwitchHostMemberBacking_closure(*_obj.backing);
		else
			return 0;
	case 1:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevendorSpecificConfig)
				return new DistributedVirtualSwitchKeyedOpaqueBlob_closure(*_obj.vendorSpecificConfig[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchHostMemberPnicBacking_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchHostMemberPnicBacking", context);
	update_member(update, "pnicSpec", "DistributedVirtualSwitchHostMemberPnicSpec[]", a2s_object(_obj.pnicSpec, _obj.__sizepnicSpec), context);
	update("Base", "DistributedVirtualSwitchHostMemberBacking", context);
	DistributedVirtualSwitchHostMemberBacking_closure(dynamic_cast<const vw1__DistributedVirtualSwitchHostMemberBacking&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchHostMemberPnicBacking_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepnicSpec)
				return new DistributedVirtualSwitchHostMemberPnicSpec_closure(*_obj.pnicSpec[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DistributedVirtualSwitchHostMemberBacking_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchHostMemberPnicSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchHostMemberPnicSpec", context);
	update_member(update, "connectionCookie", "xsd:int", basic2str(_obj.connectionCookie), context);
	update_member(update, "pnicDevice", "xsd:string", basic2str(_obj.pnicDevice), context);
	update_member(update, "uplinkPortgroupKey", "xsd:string", basic2str(_obj.uplinkPortgroupKey), context);
	update_member(update, "uplinkPortKey", "xsd:string", basic2str(_obj.uplinkPortKey), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchHostMemberPnicSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DistributedVirtualSwitchHostMemberRuntimeState_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchHostMemberRuntimeState", context);
	update_member(update, "currentMaxProxySwitchPorts", "xsd:int", basic2str(_obj.currentMaxProxySwitchPorts), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchHostMemberRuntimeState_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DistributedVirtualSwitchHostProductSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchHostProductSpec", context);
	update_member(update, "productLineId", "xsd:string", basic2str(_obj.productLineId), context);
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchHostProductSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DistributedVirtualSwitchInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchInfo", context);
	update_member(update, "distributedVirtualSwitch", "DistributedVirtualSwitch", handle_obj_ptr(_obj.distributedVirtualSwitch), context);
	update_member(update, "switchName", "xsd:string", basic2str(_obj.switchName), context);
	update_member(update, "switchUuid", "xsd:string", basic2str(_obj.switchUuid), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.distributedVirtualSwitch? 
			get_closure_from_mor(DistributedVirtualSwitch(_obj.distributedVirtualSwitch)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchKeyedOpaqueBlob_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchKeyedOpaqueBlob", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "opaqueData", "xsd:string", basic2str(_obj.opaqueData), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchKeyedOpaqueBlob_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DistributedVirtualSwitchManagerCompatibilityResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchManagerCompatibilityResult", context);
	update_member(update, "error", "LocalizedMethodFault[]", a2s_object(_obj.error, _obj.__sizeerror), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchManagerCompatibilityResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeerror)
				return new LocalizedMethodFault_closure(*_obj.error[i]);
			else
				return 0;
		}
	case 1:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchManagerDvsProductSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchManagerDvsProductSpec", context);
	update_member(update, "distributedVirtualSwitch", "DistributedVirtualSwitch", handle_obj_ptr(_obj.distributedVirtualSwitch), context);
	update_member(update, "newSwitchProductSpec", "DistributedVirtualSwitchProductSpec", handle_obj_ptr(_obj.newSwitchProductSpec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchManagerDvsProductSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.distributedVirtualSwitch? 
			get_closure_from_mor(DistributedVirtualSwitch(_obj.distributedVirtualSwitch)) : 0;
	case 1:
		if (_obj.newSwitchProductSpec)
			return new DistributedVirtualSwitchProductSpec_closure(*_obj.newSwitchProductSpec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchManagerHostArrayFilter_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchManagerHostArrayFilter", context);
	update_member(update, "host", "HostSystem[]", a2s_object(_obj.host, _obj.__sizehost), context);
	update("Base", "DistributedVirtualSwitchManagerHostDvsFilterSpec", context);
	DistributedVirtualSwitchManagerHostDvsFilterSpec_closure(dynamic_cast<const vw1__DistributedVirtualSwitchManagerHostDvsFilterSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchManagerHostArrayFilter_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehost)
				return new HostSystem_closure(_obj.host[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DistributedVirtualSwitchManagerHostDvsFilterSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchManagerHostContainer_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchManagerHostContainer", context);
	update_member(update, "container", "ManagedEntity", handle_obj_ptr(_obj.container), context);
	update_member(update, "recursive", "xsd:boolean", basic2str(_obj.recursive), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchManagerHostContainer_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.container? 
			get_closure_from_mor(ManagedEntity(_obj.container)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchManagerHostContainerFilter_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchManagerHostContainerFilter", context);
	update_member(update, "hostContainer", "DistributedVirtualSwitchManagerHostContainer", handle_obj_ptr(_obj.hostContainer), context);
	update("Base", "DistributedVirtualSwitchManagerHostDvsFilterSpec", context);
	DistributedVirtualSwitchManagerHostDvsFilterSpec_closure(dynamic_cast<const vw1__DistributedVirtualSwitchManagerHostDvsFilterSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchManagerHostContainerFilter_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.hostContainer)
			return new DistributedVirtualSwitchManagerHostContainer_closure(*_obj.hostContainer);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DistributedVirtualSwitchManagerHostDvsFilterSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchManagerHostDvsFilterSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchManagerHostDvsFilterSpec", context);
	update_member(update, "inclusive", "xsd:boolean", basic2str(_obj.inclusive), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchManagerHostDvsFilterSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DistributedVirtualSwitchManagerHostDvsMembershipFilter_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchManagerHostDvsMembershipFilter", context);
	update_member(update, "distributedVirtualSwitch", "DistributedVirtualSwitch", handle_obj_ptr(_obj.distributedVirtualSwitch), context);
	update("Base", "DistributedVirtualSwitchManagerHostDvsFilterSpec", context);
	DistributedVirtualSwitchManagerHostDvsFilterSpec_closure(dynamic_cast<const vw1__DistributedVirtualSwitchManagerHostDvsFilterSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchManagerHostDvsMembershipFilter_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.distributedVirtualSwitch? 
			get_closure_from_mor(DistributedVirtualSwitch(_obj.distributedVirtualSwitch)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DistributedVirtualSwitchManagerHostDvsFilterSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchPortConnectee_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchPortConnectee", context);
	update_member(update, "addressHint", "xsd:string", basic2str(_obj.addressHint), context);
	update_member(update, "connectedEntity", "ManagedEntity", handle_obj_ptr(_obj.connectedEntity), context);
	update_member(update, "nicKey", "xsd:string", basic2str(_obj.nicKey), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchPortConnectee_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.connectedEntity? 
			get_closure_from_mor(ManagedEntity(_obj.connectedEntity)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchPortConnection_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchPortConnection", context);
	update_member(update, "connectionCookie", "xsd:int", basic2str(_obj.connectionCookie), context);
	update_member(update, "portgroupKey", "xsd:string", basic2str(_obj.portgroupKey), context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update_member(update, "switchUuid", "xsd:string", basic2str(_obj.switchUuid), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchPortConnection_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DistributedVirtualSwitchPortCriteria_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchPortCriteria", context);
	update_member(update, "active", "xsd:boolean", basic2str(_obj.active), context);
	update_member(update, "connected", "xsd:boolean", basic2str(_obj.connected), context);
	update_member(update, "inside", "xsd:boolean", basic2str(_obj.inside), context);
	update_member(update, "portgroupKey", "xsd:string[]", a2s_basic(*_obj.portgroupKey, _obj.__sizeportgroupKey), context);
	update_member(update, "portKey", "xsd:string[]", a2s_basic(*_obj.portKey, _obj.__sizeportKey), context);
	update_member(update, "scope", "ManagedEntity", handle_obj_ptr(_obj.scope), context);
	update_member(update, "uplinkPort", "xsd:boolean", basic2str(_obj.uplinkPort), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchPortCriteria_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 5:
		return _obj.scope? 
			get_closure_from_mor(ManagedEntity(_obj.scope)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchPortStatistics_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchPortStatistics", context);
	update_member(update, "bytesInBroadcast", "xsd:long", basic2str(_obj.bytesInBroadcast), context);
	update_member(update, "bytesInMulticast", "xsd:long", basic2str(_obj.bytesInMulticast), context);
	update_member(update, "bytesInUnicast", "xsd:long", basic2str(_obj.bytesInUnicast), context);
	update_member(update, "bytesOutBroadcast", "xsd:long", basic2str(_obj.bytesOutBroadcast), context);
	update_member(update, "bytesOutMulticast", "xsd:long", basic2str(_obj.bytesOutMulticast), context);
	update_member(update, "bytesOutUnicast", "xsd:long", basic2str(_obj.bytesOutUnicast), context);
	update_member(update, "packetsInBroadcast", "xsd:long", basic2str(_obj.packetsInBroadcast), context);
	update_member(update, "packetsInDropped", "xsd:long", basic2str(_obj.packetsInDropped), context);
	update_member(update, "packetsInException", "xsd:long", basic2str(_obj.packetsInException), context);
	update_member(update, "packetsInMulticast", "xsd:long", basic2str(_obj.packetsInMulticast), context);
	update_member(update, "packetsInUnicast", "xsd:long", basic2str(_obj.packetsInUnicast), context);
	update_member(update, "packetsOutBroadcast", "xsd:long", basic2str(_obj.packetsOutBroadcast), context);
	update_member(update, "packetsOutDropped", "xsd:long", basic2str(_obj.packetsOutDropped), context);
	update_member(update, "packetsOutException", "xsd:long", basic2str(_obj.packetsOutException), context);
	update_member(update, "packetsOutMulticast", "xsd:long", basic2str(_obj.packetsOutMulticast), context);
	update_member(update, "packetsOutUnicast", "xsd:long", basic2str(_obj.packetsOutUnicast), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchPortStatistics_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DistributedVirtualSwitchProductSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchProductSpec", context);
	update_member(update, "build", "xsd:string", basic2str(_obj.build), context);
	update_member(update, "bundleId", "xsd:string", basic2str(_obj.bundleId), context);
	update_member(update, "bundleUrl", "xsd:string", basic2str(_obj.bundleUrl), context);
	update_member(update, "forwardingClass", "xsd:string", basic2str(_obj.forwardingClass), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "vendor", "xsd:string", basic2str(_obj.vendor), context);
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchProductSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsDisabledEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsDisabledEvent", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsDisabledEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsEnabledEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsEnabledEvent", context);
	update_member(update, "behavior", "xsd:string", basic2str(_obj.behavior), context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsEnabledEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsEnteredStandbyModeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsEnteredStandbyModeEvent", context);
	update("Base", "EnteredStandbyModeEvent", context);
	EnteredStandbyModeEvent_closure(dynamic_cast<const vw1__EnteredStandbyModeEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsEnteredStandbyModeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsEnteringStandbyModeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsEnteringStandbyModeEvent", context);
	update("Base", "EnteringStandbyModeEvent", context);
	EnteringStandbyModeEvent_closure(dynamic_cast<const vw1__EnteringStandbyModeEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsEnteringStandbyModeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsExitStandbyModeFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsExitStandbyModeFailedEvent", context);
	update("Base", "ExitStandbyModeFailedEvent", context);
	ExitStandbyModeFailedEvent_closure(dynamic_cast<const vw1__ExitStandbyModeFailedEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsExitStandbyModeFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsExitedStandbyModeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsExitedStandbyModeEvent", context);
	update("Base", "ExitedStandbyModeEvent", context);
	ExitedStandbyModeEvent_closure(dynamic_cast<const vw1__ExitedStandbyModeEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsExitedStandbyModeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsExitingStandbyModeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsExitingStandbyModeEvent", context);
	update("Base", "ExitingStandbyModeEvent", context);
	ExitingStandbyModeEvent_closure(dynamic_cast<const vw1__ExitingStandbyModeEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsExitingStandbyModeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsInvocationFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsInvocationFailedEvent", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsInvocationFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsRecoveredFromFailureEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsRecoveredFromFailureEvent", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsRecoveredFromFailureEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsResourceConfigureFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsResourceConfigureFailedEvent", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsResourceConfigureFailedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DrsResourceConfigureSyncedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsResourceConfigureSyncedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsResourceConfigureSyncedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsRuleComplianceEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsRuleComplianceEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsRuleComplianceEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsRuleViolationEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsRuleViolationEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsRuleViolationEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsVmMigratedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsVmMigratedEvent", context);
	update("Base", "VmMigratedEvent", context);
	VmMigratedEvent_closure(dynamic_cast<const vw1__VmMigratedEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsVmMigratedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsVmPoweredOnEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsVmPoweredOnEvent", context);
	update("Base", "VmPoweredOnEvent", context);
	VmPoweredOnEvent_closure(dynamic_cast<const vw1__VmPoweredOnEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsVmPoweredOnEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DuplicateIpDetectedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DuplicateIpDetectedEvent", context);
	update_member(update, "duplicateIP", "xsd:string", basic2str(_obj.duplicateIP), context);
	update_member(update, "macAddress", "xsd:string", basic2str(_obj.macAddress), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DuplicateIpDetectedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsCreatedEvent", context);
	update_member(update, "parent", "FolderEventArgument", handle_obj_ptr(_obj.parent), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsCreatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.parent)
			return new FolderEventArgument_closure(*_obj.parent);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DvsDestroyedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsDestroyedEvent", context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsDestroyedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsEvent", context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsEventArgument", context);
	update_member(update, "dvs", "DistributedVirtualSwitch", handle_obj_ptr(_obj.dvs), context);
	update("Base", "EntityEventArgument", context);
	EntityEventArgument_closure(dynamic_cast<const vw1__EntityEventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsEventArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.dvs? 
			get_closure_from_mor(DistributedVirtualSwitch(_obj.dvs)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return EntityEventArgument_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DvsHostBackInSyncEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsHostBackInSyncEvent", context);
	update_member(update, "hostBackInSync", "HostEventArgument", handle_obj_ptr(_obj.hostBackInSync), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsHostBackInSyncEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.hostBackInSync)
			return new HostEventArgument_closure(*_obj.hostBackInSync);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DvsHostJoinedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsHostJoinedEvent", context);
	update_member(update, "hostJoined", "HostEventArgument", handle_obj_ptr(_obj.hostJoined), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsHostJoinedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.hostJoined)
			return new HostEventArgument_closure(*_obj.hostJoined);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DvsHostLeftEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsHostLeftEvent", context);
	update_member(update, "hostLeft", "HostEventArgument", handle_obj_ptr(_obj.hostLeft), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsHostLeftEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.hostLeft)
			return new HostEventArgument_closure(*_obj.hostLeft);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DvsHostStatusUpdated_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsHostStatusUpdated", context);
	update_member(update, "hostMember", "HostEventArgument", handle_obj_ptr(_obj.hostMember), context);
	update_member(update, "newStatus", "xsd:string", basic2str(_obj.newStatus), context);
	update_member(update, "newStatusDetail", "xsd:string", basic2str(_obj.newStatusDetail), context);
	update_member(update, "oldStatus", "xsd:string", basic2str(_obj.oldStatus), context);
	update_member(update, "oldStatusDetail", "xsd:string", basic2str(_obj.oldStatusDetail), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsHostStatusUpdated_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.hostMember)
			return new HostEventArgument_closure(*_obj.hostMember);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void DvsHostVNicProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsHostVNicProfile", context);
	update("Base", "DvsVNicProfile", context);
	DvsVNicProfile_closure(dynamic_cast<const vw1__DvsVNicProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsHostVNicProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsHostWentOutOfSyncEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsHostWentOutOfSyncEvent", context);
	update_member(update, "hostOutOfSync", "DvsOutOfSyncHostArgument", handle_obj_ptr(_obj.hostOutOfSync), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsHostWentOutOfSyncEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.hostOutOfSync)
			return new DvsOutOfSyncHostArgument_closure(*_obj.hostOutOfSync);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DvsMergedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsMergedEvent", context);
	update_member(update, "destinationDvs", "DvsEventArgument", handle_obj_ptr(_obj.destinationDvs), context);
	update_member(update, "sourceDvs", "DvsEventArgument", handle_obj_ptr(_obj.sourceDvs), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsMergedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.destinationDvs)
			return new DvsEventArgument_closure(*_obj.destinationDvs);
		else
			return 0;
	case 1:
		if (_obj.sourceDvs)
			return new DvsEventArgument_closure(*_obj.sourceDvs);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DvsOperationBulkFaultFaultOnHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsOperationBulkFaultFaultOnHost", context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsOperationBulkFaultFaultOnHost_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	case 1:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DvsOutOfSyncHostArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsOutOfSyncHostArgument", context);
	update_member(update, "configParamters", "xsd:string[]", a2s_basic(*_obj.configParamters, _obj.__sizeconfigParamters), context);
	update_member(update, "outOfSyncHost", "HostEventArgument", handle_obj_ptr(_obj.outOfSyncHost), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsOutOfSyncHostArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.outOfSyncHost)
			return new HostEventArgument_closure(*_obj.outOfSyncHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DvsPortBlockedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsPortBlockedEvent", context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update_member_with_version(update, "statusDetail", "xsd:string", basic2str(_obj.statusDetail), context, "4.1");
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsPortBlockedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsPortConnectedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsPortConnectedEvent", context);
	update_member(update, "connectee", "DistributedVirtualSwitchPortConnectee", handle_obj_ptr(_obj.connectee), context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsPortConnectedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.connectee)
			return new DistributedVirtualSwitchPortConnectee_closure(*_obj.connectee);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DvsPortCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsPortCreatedEvent", context);
	update_member(update, "portKey", "xsd:string[]", a2s_basic(*_obj.portKey, _obj.__sizeportKey), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsPortCreatedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsPortDeletedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsPortDeletedEvent", context);
	update_member(update, "portKey", "xsd:string[]", a2s_basic(*_obj.portKey, _obj.__sizeportKey), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsPortDeletedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsPortDisconnectedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsPortDisconnectedEvent", context);
	update_member(update, "connectee", "DistributedVirtualSwitchPortConnectee", handle_obj_ptr(_obj.connectee), context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsPortDisconnectedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.connectee)
			return new DistributedVirtualSwitchPortConnectee_closure(*_obj.connectee);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DvsPortEnteredPassthruEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsPortEnteredPassthruEvent", context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsPortEnteredPassthruEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsPortExitedPassthruEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsPortExitedPassthruEvent", context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsPortExitedPassthruEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsPortJoinPortgroupEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsPortJoinPortgroupEvent", context);
	update_member(update, "portgroupKey", "xsd:string", basic2str(_obj.portgroupKey), context);
	update_member(update, "portgroupName", "xsd:string", basic2str(_obj.portgroupName), context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsPortJoinPortgroupEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsPortLeavePortgroupEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsPortLeavePortgroupEvent", context);
	update_member(update, "portgroupKey", "xsd:string", basic2str(_obj.portgroupKey), context);
	update_member(update, "portgroupName", "xsd:string", basic2str(_obj.portgroupName), context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsPortLeavePortgroupEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsPortLinkDownEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsPortLinkDownEvent", context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsPortLinkDownEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsPortLinkUpEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsPortLinkUpEvent", context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsPortLinkUpEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsPortReconfiguredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsPortReconfiguredEvent", context);
	update_member(update, "portKey", "xsd:string[]", a2s_basic(*_obj.portKey, _obj.__sizeportKey), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsPortReconfiguredEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsPortUnblockedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsPortUnblockedEvent", context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsPortUnblockedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsProfile", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "uplink", "PnicUplinkProfile[]", a2s_object(_obj.uplink, _obj.__sizeuplink), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeuplink)
				return new PnicUplinkProfile_closure(*_obj.uplink[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ApplyProfile_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void DvsReconfiguredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsReconfiguredEvent", context);
	update_member(update, "configSpec", "DVSConfigSpec", handle_obj_ptr(_obj.configSpec), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsReconfiguredEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.configSpec)
			return new DVSConfigSpec_closure(*_obj.configSpec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DvsRenamedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsRenamedEvent", context);
	update_member(update, "newName", "xsd:string", basic2str(_obj.newName), context);
	update_member(update, "oldName", "xsd:string", basic2str(_obj.oldName), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsRenamedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsServiceConsoleVNicProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsServiceConsoleVNicProfile", context);
	update("Base", "DvsVNicProfile", context);
	DvsVNicProfile_closure(dynamic_cast<const vw1__DvsVNicProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsServiceConsoleVNicProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsUpgradeAvailableEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsUpgradeAvailableEvent", context);
	update_member(update, "productInfo", "DistributedVirtualSwitchProductSpec", handle_obj_ptr(_obj.productInfo), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsUpgradeAvailableEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.productInfo)
			return new DistributedVirtualSwitchProductSpec_closure(*_obj.productInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DvsUpgradeInProgressEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsUpgradeInProgressEvent", context);
	update_member(update, "productInfo", "DistributedVirtualSwitchProductSpec", handle_obj_ptr(_obj.productInfo), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsUpgradeInProgressEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.productInfo)
			return new DistributedVirtualSwitchProductSpec_closure(*_obj.productInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DvsUpgradeRejectedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsUpgradeRejectedEvent", context);
	update_member(update, "productInfo", "DistributedVirtualSwitchProductSpec", handle_obj_ptr(_obj.productInfo), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsUpgradeRejectedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.productInfo)
			return new DistributedVirtualSwitchProductSpec_closure(*_obj.productInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DvsUpgradedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsUpgradedEvent", context);
	update_member(update, "productInfo", "DistributedVirtualSwitchProductSpec", handle_obj_ptr(_obj.productInfo), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsUpgradedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.productInfo)
			return new DistributedVirtualSwitchProductSpec_closure(*_obj.productInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DvsVNicProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsVNicProfile", context);
	update_member(update, "ipConfig", "IpAddressProfile", handle_obj_ptr(_obj.ipConfig), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsVNicProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.ipConfig)
			return new IpAddressProfile_closure(*_obj.ipConfig);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ApplyProfile_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DynamicArray_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DynamicArray", context);
	update_member(update, "dynamicType", "xsd:string", basic2str(_obj.dynamicType), context);
	update_member(update, "val", "xsd:anyType[]", a2s_basic(_obj.val, _obj.__sizeval), context);
	update("End", std::string(), context);
}

closure* DynamicArray_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DynamicData_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DynamicData", context);
	update_member(update, "dynamicProperty", "DynamicProperty[]", a2s_object(_obj.dynamicProperty, _obj.__sizedynamicProperty), context);
	update_member(update, "dynamicType", "xsd:string", basic2str(_obj.dynamicType), context);
	update("End", std::string(), context);
}

closure* DynamicData_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedynamicProperty)
				return new DynamicProperty_closure(*_obj.dynamicProperty[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void DynamicProperty_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DynamicProperty", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "val", "xsd:anyType", basic2str(_obj.val), context);
	update("End", std::string(), context);
}

closure* DynamicProperty_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EVCMode_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EVCMode", context);
	update_member_with_version(update, "guaranteedCPUFeatures", "HostCpuIdInfo[]", a2s_object(_obj.guaranteedCPUFeatures, _obj.__sizeguaranteedCPUFeatures), context, "4.1");
	update_member_with_version(update, "track", "xsd:string[]", a2s_basic(*_obj.track, _obj.__sizetrack), context, "4.1");
	update_member(update, "vendor", "xsd:string", basic2str(_obj.vendor), context);
	update_member(update, "vendorTier", "xsd:int", basic2str(_obj.vendorTier), context);
	update("Base", "ElementDescription", context);
	ElementDescription_closure(dynamic_cast<const vw1__ElementDescription&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EVCMode_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeguaranteedCPUFeatures)
				return new HostCpuIdInfo_closure(*_obj.guaranteedCPUFeatures[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ElementDescription_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void ElementDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ElementDescription", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "Description", context);
	Description_closure(dynamic_cast<const vw1__Description&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ElementDescription_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EnteredMaintenanceModeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EnteredMaintenanceModeEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EnteredMaintenanceModeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EnteredStandbyModeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EnteredStandbyModeEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EnteredStandbyModeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EnteringMaintenanceModeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EnteringMaintenanceModeEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EnteringMaintenanceModeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EnteringStandbyModeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EnteringStandbyModeEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EnteringStandbyModeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EntityEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EntityEventArgument", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "EventArgument", context);
	EventArgument_closure(dynamic_cast<const vw1__EventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EntityEventArgument_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EnumDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EnumDescription", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "tags", "ElementDescription[]", a2s_object(_obj.tags, _obj.__sizetags), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EnumDescription_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizetags)
				return new ElementDescription_closure(*_obj.tags[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ErrorUpgradeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ErrorUpgradeEvent", context);
	update("Base", "UpgradeEvent", context);
	UpgradeEvent_closure(dynamic_cast<const vw1__UpgradeEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ErrorUpgradeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EvaluationLicenseSource_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EvaluationLicenseSource", context);
	update_member(update, "remainingHours", "xsd:long", basic2str(_obj.remainingHours), context);
	update("Base", "LicenseSource", context);
	LicenseSource_closure(dynamic_cast<const vw1__LicenseSource&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EvaluationLicenseSource_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void Event_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Event", context);
	update_member(update, "chainId", "xsd:int", basic2str(_obj.chainId), context);
	update_member_with_version(update, "changeTag", "xsd:string", basic2str(_obj.changeTag), context, "4.0");
	update_member(update, "computeResource", "ComputeResourceEventArgument", handle_obj_ptr(_obj.computeResource), context);
	update_member(update, "createdTime", "xsd:dateTime", basic2str(_obj.createdTime), context);
	update_member(update, "datacenter", "DatacenterEventArgument", handle_obj_ptr(_obj.datacenter), context);
	update_member_with_version(update, "ds", "DatastoreEventArgument", handle_obj_ptr(_obj.ds), context, "4.0");
	update_member_with_version(update, "dvs", "DvsEventArgument", handle_obj_ptr(_obj.dvs), context, "4.0");
	update_member(update, "fullFormattedMessage", "xsd:string", basic2str(_obj.fullFormattedMessage), context);
	update_member(update, "host", "HostEventArgument", handle_obj_ptr(_obj.host), context);
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update_member_with_version(update, "net", "NetworkEventArgument", handle_obj_ptr(_obj.net), context, "4.0");
	update_member(update, "userName", "xsd:string", basic2str(_obj.userName), context);
	update_member(update, "vm", "VmEventArgument", handle_obj_ptr(_obj.vm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* Event_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.computeResource)
			return new ComputeResourceEventArgument_closure(*_obj.computeResource);
		else
			return 0;
	case 4:
		if (_obj.datacenter)
			return new DatacenterEventArgument_closure(*_obj.datacenter);
		else
			return 0;
	case 5:
		if (_obj.ds)
			return new DatastoreEventArgument_closure(*_obj.ds);
		else
			return 0;
	case 6:
		if (_obj.dvs)
			return new DvsEventArgument_closure(*_obj.dvs);
		else
			return 0;
	case 8:
		if (_obj.host)
			return new HostEventArgument_closure(*_obj.host);
		else
			return 0;
	case 10:
		if (_obj.net)
			return new NetworkEventArgument_closure(*_obj.net);
		else
			return 0;
	case 12:
		if (_obj.vm)
			return new VmEventArgument_closure(*_obj.vm);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 13) << 16) + arr_index);
	}
	return 0;
}

void EventAlarmExpression_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EventAlarmExpression", context);
	update_member_with_version(update, "comparisons", "EventAlarmExpressionComparison[]", a2s_object(_obj.comparisons, _obj.__sizecomparisons), context, "4.0");
	update_member(update, "eventType", "xsd:string", basic2str(_obj.eventType), context);
	update_member(update, "eventTypeId", "xsd:string", basic2str(_obj.eventTypeId), context);
	update_member_with_version(update, "objectType", "xsd:string", basic2str(_obj.objectType), context, "4.0");
	update_member_with_version(update, "status", "ManagedEntityStatus", handle_obj_ptr(_obj.status), context, "4.0");
	update("Base", "AlarmExpression", context);
	AlarmExpression_closure(dynamic_cast<const vw1__AlarmExpression&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EventAlarmExpression_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecomparisons)
				return new EventAlarmExpressionComparison_closure(*_obj.comparisons[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return AlarmExpression_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void EventAlarmExpressionComparison_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EventAlarmExpressionComparison", context);
	update_member(update, "attributeName", "xsd:string", basic2str(_obj.attributeName), context);
	update_member(update, "operator_", "xsd:string", basic2str(_obj.operator_), context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EventAlarmExpressionComparison_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EventArgDesc_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EventArgDesc", context);
	update_member(update, "description", "ElementDescription", handle_obj_ptr(_obj.description), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EventArgDesc_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.description)
			return new ElementDescription_closure(*_obj.description);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void EventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EventArgument", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EventArgument_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EventDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EventDescription", context);
	update_member(update, "category", "ElementDescription[]", a2s_object(_obj.category, _obj.__sizecategory), context);
	update_member_with_version(update, "enumeratedTypes", "EnumDescription[]", a2s_object(_obj.enumeratedTypes, _obj.__sizeenumeratedTypes), context, "4.0");
	update_member(update, "eventInfo", "EventDescriptionEventDetail[]", a2s_object(_obj.eventInfo, _obj.__sizeeventInfo), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EventDescription_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecategory)
				return new ElementDescription_closure(*_obj.category[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeenumeratedTypes)
				return new EnumDescription_closure(*_obj.enumeratedTypes[i]);
			else
				return 0;
		}
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeeventInfo)
				return new EventDescriptionEventDetail_closure(*_obj.eventInfo[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void EventDescriptionEventDetail_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EventDescriptionEventDetail", context);
	update_member(update, "category", "xsd:string", basic2str(_obj.category), context);
	update_member_with_version(update, "description", "xsd:string", basic2str(_obj.description), context, "4.0");
	update_member(update, "formatOnComputeResource", "xsd:string", basic2str(_obj.formatOnComputeResource), context);
	update_member(update, "formatOnDatacenter", "xsd:string", basic2str(_obj.formatOnDatacenter), context);
	update_member(update, "formatOnHost", "xsd:string", basic2str(_obj.formatOnHost), context);
	update_member(update, "formatOnVm", "xsd:string", basic2str(_obj.formatOnVm), context);
	update_member(update, "fullFormat", "xsd:string", basic2str(_obj.fullFormat), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member_with_version(update, "longDescription", "xsd:string", basic2str(_obj.longDescription), context, "4.1");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EventDescriptionEventDetail_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EventEx_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EventEx", context);
	update_member(update, "arguments", "KeyAnyValue[]", a2s_object(_obj.arguments, _obj.__sizearguments), context);
	update_member(update, "eventTypeId", "xsd:string", basic2str(_obj.eventTypeId), context);
	update_member_with_version(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context, "4.1");
	update_member(update, "message", "xsd:string", basic2str(_obj.message), context);
	update_member(update, "objectId", "xsd:string", basic2str(_obj.objectId), context);
	update_member_with_version(update, "objectName", "xsd:string", basic2str(_obj.objectName), context, "4.1");
	update_member(update, "objectType", "xsd:string", basic2str(_obj.objectType), context);
	update_member(update, "severity", "xsd:string", basic2str(_obj.severity), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EventEx_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizearguments)
				return new KeyAnyValue_closure(*_obj.arguments[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return Event_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void EventFilterSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EventFilterSpec", context);
	update_member(update, "alarm", "Alarm", handle_obj_ptr(_obj.alarm), context);
	update_member(update, "category", "xsd:string[]", a2s_basic(*_obj.category, _obj.__sizecategory), context);
	update_member(update, "disableFullMessage", "xsd:boolean", basic2str(_obj.disableFullMessage), context);
	update_member(update, "entity", "EventFilterSpecByEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "eventChainId", "xsd:int", basic2str(_obj.eventChainId), context);
	update_member_with_version(update, "eventTypeId", "xsd:string[]", a2s_basic(*_obj.eventTypeId, _obj.__sizeeventTypeId), context, "4.0");
	update_member(update, "scheduledTask", "ScheduledTask", handle_obj_ptr(_obj.scheduledTask), context);
	update_member_with_version(update, "tag", "xsd:string[]", a2s_basic(*_obj.tag, _obj.__sizetag), context, "4.0");
	update_member(update, "time", "EventFilterSpecByTime", handle_obj_ptr(_obj.time), context);
	update_member(update, "type", "xsd:string[]", a2s_basic(*_obj.type, _obj.__sizetype), context);
	update_member(update, "userName", "EventFilterSpecByUsername", handle_obj_ptr(_obj.userName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EventFilterSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.alarm? 
			get_closure_from_mor(Alarm(_obj.alarm)) : 0;
	case 3:
		if (_obj.entity)
			return new EventFilterSpecByEntity_closure(*_obj.entity);
		else
			return 0;
	case 6:
		return _obj.scheduledTask? 
			get_closure_from_mor(ScheduledTask(_obj.scheduledTask)) : 0;
	case 8:
		if (_obj.time)
			return new EventFilterSpecByTime_closure(*_obj.time);
		else
			return 0;
	case 10:
		if (_obj.userName)
			return new EventFilterSpecByUsername_closure(*_obj.userName);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void EventFilterSpecByEntity_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EventFilterSpecByEntity", context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "recursion", "EventFilterSpecRecursionOption", handle_obj(_obj.recursion), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EventFilterSpecByEntity_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void EventFilterSpecByTime_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EventFilterSpecByTime", context);
	update_member(update, "beginTime", "xsd:dateTime", basic2str(_obj.beginTime), context);
	update_member(update, "endTime", "xsd:dateTime", basic2str(_obj.endTime), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EventFilterSpecByTime_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EventFilterSpecByUsername_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EventFilterSpecByUsername", context);
	update_member(update, "systemUser", "xsd:boolean", basic2str(_obj.systemUser), context);
	update_member(update, "userList", "xsd:string[]", a2s_basic(*_obj.userList, _obj.__sizeuserList), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EventFilterSpecByUsername_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExitMaintenanceModeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExitMaintenanceModeEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExitMaintenanceModeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExitStandbyModeFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExitStandbyModeFailedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExitStandbyModeFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExitedStandbyModeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExitedStandbyModeEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExitedStandbyModeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExitingStandbyModeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExitingStandbyModeEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExitingStandbyModeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExtExtendedProductInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtExtendedProductInfo", context);
	update_member(update, "companyUrl", "xsd:string", basic2str(_obj.companyUrl), context);
	update_member(update, "managementUrl", "xsd:string", basic2str(_obj.managementUrl), context);
	update_member(update, "productUrl", "xsd:string", basic2str(_obj.productUrl), context);
	update_member(update, "self", "ManagedEntity", handle_obj_ptr(_obj.self), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtExtendedProductInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		return _obj.self? 
			get_closure_from_mor(ManagedEntity(_obj.self)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void ExtManagedEntityInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtManagedEntityInfo", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "smallIconUrl", "xsd:string", basic2str(_obj.smallIconUrl), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtManagedEntityInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExtSolutionManagerInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtSolutionManagerInfo", context);
	update_member(update, "smallIconUrl", "xsd:string", basic2str(_obj.smallIconUrl), context);
	update_member(update, "tab", "ExtSolutionManagerInfoTabInfo[]", a2s_object(_obj.tab, _obj.__sizetab), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtSolutionManagerInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizetab)
				return new ExtSolutionManagerInfoTabInfo_closure(*_obj.tab[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ExtSolutionManagerInfoTabInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtSolutionManagerInfoTabInfo", context);
	update_member(update, "label", "xsd:string", basic2str(_obj.label), context);
	update_member(update, "url", "xsd:string", basic2str(_obj.url), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtSolutionManagerInfoTabInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExtendedDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtendedDescription", context);
	update_member(update, "messageArg", "KeyAnyValue[]", a2s_object(_obj.messageArg, _obj.__sizemessageArg), context);
	update_member(update, "messageCatalogKeyPrefix", "xsd:string", basic2str(_obj.messageCatalogKeyPrefix), context);
	update("Base", "Description", context);
	Description_closure(dynamic_cast<const vw1__Description&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtendedDescription_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemessageArg)
				return new KeyAnyValue_closure(*_obj.messageArg[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return Description_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ExtendedElementDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtendedElementDescription", context);
	update_member(update, "messageArg", "KeyAnyValue[]", a2s_object(_obj.messageArg, _obj.__sizemessageArg), context);
	update_member(update, "messageCatalogKeyPrefix", "xsd:string", basic2str(_obj.messageCatalogKeyPrefix), context);
	update("Base", "ElementDescription", context);
	ElementDescription_closure(dynamic_cast<const vw1__ElementDescription&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtendedElementDescription_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemessageArg)
				return new KeyAnyValue_closure(*_obj.messageArg[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ElementDescription_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ExtendedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtendedEvent", context);
	update_member(update, "data", "ExtendedEventPair[]", a2s_object(_obj.data, _obj.__sizedata), context);
	update_member(update, "eventTypeId", "xsd:string", basic2str(_obj.eventTypeId), context);
	update_member(update, "managedObject", "ManagedObjectReference", handle_obj_ptr(_obj.managedObject), context);
	update("Base", "GeneralEvent", context);
	GeneralEvent_closure(dynamic_cast<const vw1__GeneralEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtendedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedata)
				return new ExtendedEventPair_closure(*_obj.data[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.managedObject)
			return new ManagedObjectReference_closure(*_obj.managedObject);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return GeneralEvent_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ExtendedEventPair_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtendedEventPair", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtendedEventPair_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void Extension_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Extension", context);
	update_member(update, "client", "ExtensionClientInfo[]", a2s_object(_obj.client, _obj.__sizeclient), context);
	update_member_with_version(update, "company", "xsd:string", basic2str(_obj.company), context, "4.0");
	update_member(update, "description", "Description", handle_obj_ptr(_obj.description), context);
	update_member(update, "eventList", "ExtensionEventTypeInfo[]", a2s_object(_obj.eventList, _obj.__sizeeventList), context);
	update_member_with_version(update, "extendedProductInfo", "ExtExtendedProductInfo", handle_obj_ptr(_obj.extendedProductInfo), context, "5.0");
	update_member(update, "faultList", "ExtensionFaultTypeInfo[]", a2s_object(_obj.faultList, _obj.__sizefaultList), context);
	update_member_with_version(update, "healthInfo", "ExtensionHealthInfo", handle_obj_ptr(_obj.healthInfo), context, "4.0");
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "lastHeartbeatTime", "xsd:dateTime", basic2str(_obj.lastHeartbeatTime), context);
	update_member_with_version(update, "managedEntityInfo", "ExtManagedEntityInfo[]", a2s_object(_obj.managedEntityInfo, _obj.__sizemanagedEntityInfo), context, "5.0");
	update_member_with_version(update, "ovfConsumerInfo", "ExtensionOvfConsumerInfo", handle_obj_ptr(_obj.ovfConsumerInfo), context, "5.0");
	update_member(update, "privilegeList", "ExtensionPrivilegeInfo[]", a2s_object(_obj.privilegeList, _obj.__sizeprivilegeList), context);
	update_member(update, "resourceList", "ExtensionResourceInfo[]", a2s_object(_obj.resourceList, _obj.__sizeresourceList), context);
	update_member(update, "server", "ExtensionServerInfo[]", a2s_object(_obj.server, _obj.__sizeserver), context);
	update_member_with_version(update, "shownInSolutionManager", "xsd:boolean", basic2str(_obj.shownInSolutionManager), context, "5.0");
	update_member_with_version(update, "solutionManagerInfo", "ExtSolutionManagerInfo", handle_obj_ptr(_obj.solutionManagerInfo), context, "5.0");
	update_member(update, "subjectName", "xsd:string", basic2str(_obj.subjectName), context);
	update_member(update, "taskList", "ExtensionTaskTypeInfo[]", a2s_object(_obj.taskList, _obj.__sizetaskList), context);
	update_member_with_version(update, "type", "xsd:string", basic2str(_obj.type), context, "4.0");
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* Extension_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeclient)
				return new ExtensionClientInfo_closure(*_obj.client[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.description)
			return new Description_closure(*_obj.description);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeeventList)
				return new ExtensionEventTypeInfo_closure(*_obj.eventList[i]);
			else
				return 0;
		}
	case 4:
		if (_obj.extendedProductInfo)
			return new ExtExtendedProductInfo_closure(*_obj.extendedProductInfo);
		else
			return 0;
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefaultList)
				return new ExtensionFaultTypeInfo_closure(*_obj.faultList[i]);
			else
				return 0;
		}
	case 6:
		if (_obj.healthInfo)
			return new ExtensionHealthInfo_closure(*_obj.healthInfo);
		else
			return 0;
	case 9:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemanagedEntityInfo)
				return new ExtManagedEntityInfo_closure(*_obj.managedEntityInfo[i]);
			else
				return 0;
		}
	case 10:
		if (_obj.ovfConsumerInfo)
			return new ExtensionOvfConsumerInfo_closure(*_obj.ovfConsumerInfo);
		else
			return 0;
	case 11:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeprivilegeList)
				return new ExtensionPrivilegeInfo_closure(*_obj.privilegeList[i]);
			else
				return 0;
		}
	case 12:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeresourceList)
				return new ExtensionResourceInfo_closure(*_obj.resourceList[i]);
			else
				return 0;
		}
	case 13:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeserver)
				return new ExtensionServerInfo_closure(*_obj.server[i]);
			else
				return 0;
		}
	case 15:
		if (_obj.solutionManagerInfo)
			return new ExtSolutionManagerInfo_closure(*_obj.solutionManagerInfo);
		else
			return 0;
	case 17:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizetaskList)
				return new ExtensionTaskTypeInfo_closure(*_obj.taskList[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 20) << 16) + arr_index);
	}
	return 0;
}

void ExtensionClientInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtensionClientInfo", context);
	update_member(update, "company", "xsd:string", basic2str(_obj.company), context);
	update_member(update, "description", "Description", handle_obj_ptr(_obj.description), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update_member(update, "url", "xsd:string", basic2str(_obj.url), context);
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtensionClientInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.description)
			return new Description_closure(*_obj.description);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void ExtensionEventTypeInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtensionEventTypeInfo", context);
	update_member(update, "eventID", "xsd:string", basic2str(_obj.eventID), context);
	update_member_with_version(update, "eventTypeSchema", "xsd:string", basic2str(_obj.eventTypeSchema), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtensionEventTypeInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExtensionFaultTypeInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtensionFaultTypeInfo", context);
	update_member(update, "faultID", "xsd:string", basic2str(_obj.faultID), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtensionFaultTypeInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExtensionHealthInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtensionHealthInfo", context);
	update_member(update, "url", "xsd:string", basic2str(_obj.url), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtensionHealthInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExtensionOvfConsumerInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtensionOvfConsumerInfo", context);
	update_member(update, "callbackUrl", "xsd:string", basic2str(_obj.callbackUrl), context);
	update_member(update, "sectionType", "xsd:string[]", a2s_basic(*_obj.sectionType, _obj.__sizesectionType), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtensionOvfConsumerInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExtensionPrivilegeInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtensionPrivilegeInfo", context);
	update_member(update, "privGroupName", "xsd:string", basic2str(_obj.privGroupName), context);
	update_member(update, "privID", "xsd:string", basic2str(_obj.privID), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtensionPrivilegeInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExtensionResourceInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtensionResourceInfo", context);
	update_member(update, "data", "KeyValue[]", a2s_object(_obj.data, _obj.__sizedata), context);
	update_member(update, "locale", "xsd:string", basic2str(_obj.locale), context);
	update_member(update, "module", "xsd:string", basic2str(_obj.module), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtensionResourceInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedata)
				return new KeyValue_closure(*_obj.data[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ExtensionServerInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtensionServerInfo", context);
	update_member(update, "adminEmail", "xsd:string[]", a2s_basic(*_obj.adminEmail, _obj.__sizeadminEmail), context);
	update_member(update, "company", "xsd:string", basic2str(_obj.company), context);
	update_member(update, "description", "Description", handle_obj_ptr(_obj.description), context);
	update_member_with_version(update, "serverThumbprint", "xsd:string", basic2str(_obj.serverThumbprint), context, "4.1");
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update_member(update, "url", "xsd:string", basic2str(_obj.url), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtensionServerInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.description)
			return new Description_closure(*_obj.description);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void ExtensionTaskTypeInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtensionTaskTypeInfo", context);
	update_member(update, "taskID", "xsd:string", basic2str(_obj.taskID), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtensionTaskTypeInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FailoverLevelRestored_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FailoverLevelRestored", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FailoverLevelRestored_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FaultToleranceConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FaultToleranceConfigInfo", context);
	update_member(update, "configPaths", "xsd:string[]", a2s_basic(*_obj.configPaths, _obj.__sizeconfigPaths), context);
	update_member(update, "instanceUuids", "xsd:string[]", a2s_basic(*_obj.instanceUuids, _obj.__sizeinstanceUuids), context);
	update_member(update, "role", "xsd:int", basic2str(_obj.role), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FaultToleranceConfigInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FaultTolerancePrimaryConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FaultTolerancePrimaryConfigInfo", context);
	update_member(update, "secondaries", "VirtualMachine[]", a2s_object(_obj.secondaries, _obj.__sizesecondaries), context);
	update("Base", "FaultToleranceConfigInfo", context);
	FaultToleranceConfigInfo_closure(dynamic_cast<const vw1__FaultToleranceConfigInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FaultTolerancePrimaryConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesecondaries)
				return new VirtualMachine_closure(_obj.secondaries[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return FaultToleranceConfigInfo_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void FaultToleranceSecondaryConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FaultToleranceSecondaryConfigInfo", context);
	update_member(update, "primaryVM", "VirtualMachine", handle_obj_ptr(_obj.primaryVM), context);
	update("Base", "FaultToleranceConfigInfo", context);
	FaultToleranceConfigInfo_closure(dynamic_cast<const vw1__FaultToleranceConfigInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FaultToleranceSecondaryConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.primaryVM? 
			get_closure_from_mor(VirtualMachine(_obj.primaryVM)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return FaultToleranceConfigInfo_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void FaultToleranceSecondaryOpResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FaultToleranceSecondaryOpResult", context);
	update_member(update, "powerOnAttempted", "xsd:boolean", basic2str(_obj.powerOnAttempted), context);
	update_member(update, "powerOnResult", "ClusterPowerOnVmResult", handle_obj_ptr(_obj.powerOnResult), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FaultToleranceSecondaryOpResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.powerOnResult)
			return new ClusterPowerOnVmResult_closure(*_obj.powerOnResult);
		else
			return 0;
	case 2:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void FcoeConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FcoeConfig", context);
	update_member(update, "capabilities", "FcoeConfigFcoeCapabilities", handle_obj_ptr(_obj.capabilities), context);
	update_member(update, "fcoeActive", "xsd:boolean", basic2str(_obj.fcoeActive), context);
	update_member(update, "priorityClass", "xsd:int", basic2str(_obj.priorityClass), context);
	update_member(update, "sourceMac", "xsd:string", basic2str(_obj.sourceMac), context);
	update_member(update, "vlanRange", "FcoeConfigVlanRange[]", a2s_object(_obj.vlanRange, _obj.__sizevlanRange), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FcoeConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.capabilities)
			return new FcoeConfigFcoeCapabilities_closure(*_obj.capabilities);
		else
			return 0;
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevlanRange)
				return new FcoeConfigVlanRange_closure(*_obj.vlanRange[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void FcoeConfigFcoeCapabilities_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FcoeConfigFcoeCapabilities", context);
	update_member(update, "priorityClass", "xsd:boolean", basic2str(_obj.priorityClass), context);
	update_member(update, "sourceMacAddress", "xsd:boolean", basic2str(_obj.sourceMacAddress), context);
	update_member(update, "vlanRange", "xsd:boolean", basic2str(_obj.vlanRange), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FcoeConfigFcoeCapabilities_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FcoeConfigFcoeSpecification_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FcoeConfigFcoeSpecification", context);
	update_member(update, "priorityClass", "xsd:int", basic2str(_obj.priorityClass), context);
	update_member(update, "sourceMac", "xsd:string", basic2str(_obj.sourceMac), context);
	update_member(update, "underlyingPnic", "xsd:string", basic2str(_obj.underlyingPnic), context);
	update_member(update, "vlanRange", "FcoeConfigVlanRange[]", a2s_object(_obj.vlanRange, _obj.__sizevlanRange), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FcoeConfigFcoeSpecification_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevlanRange)
				return new FcoeConfigVlanRange_closure(*_obj.vlanRange[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void FcoeConfigVlanRange_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FcoeConfigVlanRange", context);
	update_member(update, "vlanHigh", "xsd:int", basic2str(_obj.vlanHigh), context);
	update_member(update, "vlanLow", "xsd:int", basic2str(_obj.vlanLow), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FcoeConfigVlanRange_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FileBackedVirtualDiskSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FileBackedVirtualDiskSpec", context);
	update_member(update, "capacityKb", "xsd:long", basic2str(_obj.capacityKb), context);
	update("Base", "VirtualDiskSpec", context);
	VirtualDiskSpec_closure(dynamic_cast<const vw1__VirtualDiskSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FileBackedVirtualDiskSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FileInfo", context);
	update_member(update, "fileSize", "xsd:long", basic2str(_obj.fileSize), context);
	update_member(update, "modification", "xsd:dateTime", basic2str(_obj.modification), context);
	update_member_with_version(update, "owner", "xsd:string", basic2str(_obj.owner), context, "4.0");
	update_member(update, "path", "xsd:string", basic2str(_obj.path), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FileInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FileQuery_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FileQuery", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FileQuery_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FileQueryFlags_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FileQueryFlags", context);
	update_member_with_version(update, "fileOwner", "xsd:boolean", basic2str(_obj.fileOwner), context, "4.0");
	update_member(update, "fileSize", "xsd:boolean", basic2str(_obj.fileSize), context);
	update_member(update, "fileType", "xsd:boolean", basic2str(_obj.fileType), context);
	update_member(update, "modification", "xsd:boolean", basic2str(_obj.modification), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FileQueryFlags_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FileTransferInformation_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FileTransferInformation", context);
	update_member(update, "attributes", "GuestFileAttributes", handle_obj_ptr(_obj.attributes), context);
	update_member(update, "size", "xsd:long", basic2str(_obj.size), context);
	update_member(update, "url", "xsd:string", basic2str(_obj.url), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FileTransferInformation_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.attributes)
			return new GuestFileAttributes_closure(*_obj.attributes);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void FirewallProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FirewallProfile", context);
	update_member(update, "ruleset", "FirewallProfileRulesetProfile[]", a2s_object(_obj.ruleset, _obj.__sizeruleset), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FirewallProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeruleset)
				return new FirewallProfileRulesetProfile_closure(*_obj.ruleset[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ApplyProfile_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void FirewallProfileRulesetProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FirewallProfileRulesetProfile", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FirewallProfileRulesetProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FloatOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FloatOption", context);
	update_member(update, "defaultValue", "xsd:float", basic2str(_obj.defaultValue), context);
	update_member(update, "max_", "xsd:float", basic2str(_obj.max_), context);
	update_member(update, "min_", "xsd:float", basic2str(_obj.min_), context);
	update("Base", "OptionType", context);
	OptionType_closure(dynamic_cast<const vw1__OptionType&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FloatOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FloppyImageFileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FloppyImageFileInfo", context);
	update("Base", "FileInfo", context);
	FileInfo_closure(dynamic_cast<const vw1__FileInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FloppyImageFileInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FloppyImageFileQuery_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FloppyImageFileQuery", context);
	update("Base", "FileQuery", context);
	FileQuery_closure(dynamic_cast<const vw1__FileQuery&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FloppyImageFileQuery_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FolderEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FolderEventArgument", context);
	update_member(update, "folder", "Folder", handle_obj_ptr(_obj.folder), context);
	update("Base", "EntityEventArgument", context);
	EntityEventArgument_closure(dynamic_cast<const vw1__EntityEventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FolderEventArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.folder? 
			get_closure_from_mor(Folder(_obj.folder)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return EntityEventArgument_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void FolderFileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FolderFileInfo", context);
	update("Base", "FileInfo", context);
	FileInfo_closure(dynamic_cast<const vw1__FileInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FolderFileInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FolderFileQuery_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FolderFileQuery", context);
	update("Base", "FileQuery", context);
	FileQuery_closure(dynamic_cast<const vw1__FileQuery&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FolderFileQuery_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GeneralEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GeneralEvent", context);
	update_member(update, "message", "xsd:string", basic2str(_obj.message), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GeneralEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GeneralHostErrorEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GeneralHostErrorEvent", context);
	update("Base", "GeneralEvent", context);
	GeneralEvent_closure(dynamic_cast<const vw1__GeneralEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GeneralHostErrorEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GeneralHostInfoEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GeneralHostInfoEvent", context);
	update("Base", "GeneralEvent", context);
	GeneralEvent_closure(dynamic_cast<const vw1__GeneralEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GeneralHostInfoEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GeneralHostWarningEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GeneralHostWarningEvent", context);
	update("Base", "GeneralEvent", context);
	GeneralEvent_closure(dynamic_cast<const vw1__GeneralEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GeneralHostWarningEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GeneralUserEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GeneralUserEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update("Base", "GeneralEvent", context);
	GeneralEvent_closure(dynamic_cast<const vw1__GeneralEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GeneralUserEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return GeneralEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void GeneralVmErrorEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GeneralVmErrorEvent", context);
	update("Base", "GeneralEvent", context);
	GeneralEvent_closure(dynamic_cast<const vw1__GeneralEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GeneralVmErrorEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GeneralVmInfoEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GeneralVmInfoEvent", context);
	update("Base", "GeneralEvent", context);
	GeneralEvent_closure(dynamic_cast<const vw1__GeneralEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GeneralVmInfoEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GeneralVmWarningEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GeneralVmWarningEvent", context);
	update("Base", "GeneralEvent", context);
	GeneralEvent_closure(dynamic_cast<const vw1__GeneralEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GeneralVmWarningEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GhostDvsProxySwitchDetectedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GhostDvsProxySwitchDetectedEvent", context);
	update_member(update, "switchUuid", "xsd:string[]", a2s_basic(*_obj.switchUuid, _obj.__sizeswitchUuid), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GhostDvsProxySwitchDetectedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GhostDvsProxySwitchRemovedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GhostDvsProxySwitchRemovedEvent", context);
	update_member(update, "switchUuid", "xsd:string[]", a2s_basic(*_obj.switchUuid, _obj.__sizeswitchUuid), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GhostDvsProxySwitchRemovedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GlobalMessageChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GlobalMessageChangedEvent", context);
	update_member(update, "message", "xsd:string", basic2str(_obj.message), context);
	update("Base", "SessionEvent", context);
	SessionEvent_closure(dynamic_cast<const vw1__SessionEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GlobalMessageChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GroupAlarmAction_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GroupAlarmAction", context);
	update_member(update, "action", "AlarmAction[]", a2s_object(_obj.action, _obj.__sizeaction), context);
	update("Base", "AlarmAction", context);
	AlarmAction_closure(dynamic_cast<const vw1__AlarmAction&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GroupAlarmAction_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeaction)
				return new AlarmAction_closure(*_obj.action[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return AlarmAction_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void GuestAuthentication_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestAuthentication", context);
	update_member(update, "interactiveSession", "xsd:boolean", basic2str(_obj.interactiveSession), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestAuthentication_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GuestDiskInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestDiskInfo", context);
	update_member(update, "capacity", "xsd:long", basic2str(_obj.capacity), context);
	update_member(update, "diskPath", "xsd:string", basic2str(_obj.diskPath), context);
	update_member(update, "freeSpace", "xsd:long", basic2str(_obj.freeSpace), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestDiskInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GuestFileAttributes_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestFileAttributes", context);
	update_member(update, "accessTime", "xsd:dateTime", basic2str(_obj.accessTime), context);
	update_member(update, "modificationTime", "xsd:dateTime", basic2str(_obj.modificationTime), context);
	update_member(update, "symlinkTarget", "xsd:string", basic2str(_obj.symlinkTarget), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestFileAttributes_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GuestFileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestFileInfo", context);
	update_member(update, "attributes", "GuestFileAttributes", handle_obj_ptr(_obj.attributes), context);
	update_member(update, "path", "xsd:string", basic2str(_obj.path), context);
	update_member(update, "size", "xsd:long", basic2str(_obj.size), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestFileInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.attributes)
			return new GuestFileAttributes_closure(*_obj.attributes);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void GuestInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestInfo", context);
	update_member_with_version(update, "appHeartbeatStatus", "xsd:string", basic2str(_obj.appHeartbeatStatus), context, "4.1");
	update_member(update, "disk", "GuestDiskInfo[]", a2s_object(_obj.disk, _obj.__sizedisk), context);
	update_member(update, "guestFamily", "xsd:string", basic2str(_obj.guestFamily), context);
	update_member(update, "guestFullName", "xsd:string", basic2str(_obj.guestFullName), context);
	update_member(update, "guestId", "xsd:string", basic2str(_obj.guestId), context);
	update_member_with_version(update, "guestOperationsReady", "xsd:boolean", basic2str(_obj.guestOperationsReady), context, "5.0");
	update_member(update, "guestState", "xsd:string", basic2str(_obj.guestState), context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update_member_with_version(update, "interactiveGuestOperationsReady", "xsd:boolean", basic2str(_obj.interactiveGuestOperationsReady), context, "5.0");
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update_member_with_version(update, "ipStack", "GuestStackInfo[]", a2s_object(_obj.ipStack, _obj.__sizeipStack), context, "4.1");
	update_member(update, "net", "GuestNicInfo[]", a2s_object(_obj.net, _obj.__sizenet), context);
	update_member(update, "screen", "GuestScreenInfo", handle_obj_ptr(_obj.screen), context);
	update_member_with_version(update, "toolsRunningStatus", "xsd:string", basic2str(_obj.toolsRunningStatus), context, "4.0");
	update_member(update, "toolsStatus", "VirtualMachineToolsStatus", handle_obj_ptr(_obj.toolsStatus), context);
	update_member(update, "toolsVersion", "xsd:string", basic2str(_obj.toolsVersion), context);
	update_member_with_version(update, "toolsVersionStatus", "xsd:string", basic2str(_obj.toolsVersionStatus), context, "4.0");
	update_member_with_version(update, "toolsVersionStatus2", "xsd:string", basic2str(_obj.toolsVersionStatus2), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedisk)
				return new GuestDiskInfo_closure(*_obj.disk[i]);
			else
				return 0;
		}
	case 10:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeipStack)
				return new GuestStackInfo_closure(*_obj.ipStack[i]);
			else
				return 0;
		}
	case 11:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenet)
				return new GuestNicInfo_closure(*_obj.net[i]);
			else
				return 0;
		}
	case 12:
		if (_obj.screen)
			return new GuestScreenInfo_closure(*_obj.screen);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 18) << 16) + arr_index);
	}
	return 0;
}

void GuestListFileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestListFileInfo", context);
	update_member(update, "files", "GuestFileInfo[]", a2s_object(_obj.files, _obj.__sizefiles), context);
	update_member(update, "remaining", "xsd:int", basic2str(_obj.remaining), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestListFileInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefiles)
				return new GuestFileInfo_closure(*_obj.files[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void GuestNicInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestNicInfo", context);
	update_member(update, "connected", "xsd:boolean", basic2str(_obj.connected), context);
	update_member(update, "deviceConfigId", "xsd:int", basic2str(_obj.deviceConfigId), context);
	update_member_with_version(update, "dnsConfig", "NetDnsConfigInfo", handle_obj_ptr(_obj.dnsConfig), context, "4.1");
	update_member(update, "ipAddress", "xsd:string[]", a2s_basic(*_obj.ipAddress, _obj.__sizeipAddress), context);
	update_member_with_version(update, "ipConfig", "NetIpConfigInfo", handle_obj_ptr(_obj.ipConfig), context, "4.1");
	update_member(update, "macAddress", "xsd:string", basic2str(_obj.macAddress), context);
	update_member_with_version(update, "netBIOSConfig", "NetBIOSConfigInfo", handle_obj_ptr(_obj.netBIOSConfig), context, "4.1");
	update_member(update, "network", "xsd:string", basic2str(_obj.network), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestNicInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.dnsConfig)
			return new NetDnsConfigInfo_closure(*_obj.dnsConfig);
		else
			return 0;
	case 4:
		if (_obj.ipConfig)
			return new NetIpConfigInfo_closure(*_obj.ipConfig);
		else
			return 0;
	case 6:
		if (_obj.netBIOSConfig)
			return new NetBIOSConfigInfo_closure(*_obj.netBIOSConfig);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void GuestOsDescriptor_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestOsDescriptor", context);
	update_member(update, "cpuFeatureMask", "HostCpuIdInfo[]", a2s_object(_obj.cpuFeatureMask, _obj.__sizecpuFeatureMask), context);
	update_member(update, "family", "xsd:string", basic2str(_obj.family), context);
	update_member(update, "fullName", "xsd:string", basic2str(_obj.fullName), context);
	update_member_with_version(update, "ich7mRecommended", "xsd:boolean", basic2str(_obj.ich7mRecommended), context, "5.0");
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member_with_version(update, "numSupportedCoresPerSocket", "xsd:int", basic2str(_obj.numSupportedCoresPerSocket), context, "5.0");
	update_member_with_version(update, "numSupportedPhysicalSockets", "xsd:int", basic2str(_obj.numSupportedPhysicalSockets), context, "5.0");
	update_member(update, "recommendedColorDepth", "xsd:int", basic2str(_obj.recommendedColorDepth), context);
	update_member(update, "recommendedDiskController", "xsd:string", basic2str(_obj.recommendedDiskController), context);
	update_member(update, "recommendedDiskSizeMB", "xsd:int", basic2str(_obj.recommendedDiskSizeMB), context);
	update_member(update, "recommendedEthernetCard", "xsd:string", basic2str(_obj.recommendedEthernetCard), context);
	update_member_with_version(update, "recommendedFirmware", "xsd:string", basic2str(_obj.recommendedFirmware), context, "5.0");
	update_member(update, "recommendedMemMB", "xsd:int", basic2str(_obj.recommendedMemMB), context);
	update_member(update, "recommendedSCSIController", "xsd:string", basic2str(_obj.recommendedSCSIController), context);
	update_member_with_version(update, "recommendedUSBController", "xsd:string", basic2str(_obj.recommendedUSBController), context, "5.0");
	update_member_with_version(update, "smcRecommended", "xsd:boolean", basic2str(_obj.smcRecommended), context, "5.0");
	update_member_with_version(update, "smcRequired", "xsd:boolean", basic2str(_obj.smcRequired), context, "5.0");
	update_member(update, "supportedDiskControllerList", "xsd:string[]", a2s_basic(*_obj.supportedDiskControllerList, _obj.__sizesupportedDiskControllerList), context);
	update_member(update, "supportedEthernetCard", "xsd:string[]", a2s_basic(*_obj.supportedEthernetCard, _obj.__sizesupportedEthernetCard), context);
	update_member_with_version(update, "supportedFirmware", "xsd:string[]", a2s_basic(*_obj.supportedFirmware, _obj.__sizesupportedFirmware), context, "5.0");
	update_member_with_version(update, "supportedForCreate", "xsd:boolean", basic2str(_obj.supportedForCreate), context, "5.0");
	update_member(update, "supportedMaxCPUs", "xsd:int", basic2str(_obj.supportedMaxCPUs), context);
	update_member(update, "supportedMaxMemMB", "xsd:int", basic2str(_obj.supportedMaxMemMB), context);
	update_member(update, "supportedMinMemMB", "xsd:int", basic2str(_obj.supportedMinMemMB), context);
	update_member(update, "supportedNumDisks", "xsd:int", basic2str(_obj.supportedNumDisks), context);
	update_member_with_version(update, "supportedUSBControllerList", "xsd:string[]", a2s_basic(*_obj.supportedUSBControllerList, _obj.__sizesupportedUSBControllerList), context, "5.0");
	update_member_with_version(update, "supportLevel", "xsd:string", basic2str(_obj.supportLevel), context, "5.0");
	update_member_with_version(update, "supports3D", "xsd:boolean", basic2str(_obj.supports3D), context, "5.0");
	update_member_with_version(update, "supportsCpuHotAdd", "xsd:boolean", basic2str(_obj.supportsCpuHotAdd), context, "4.0");
	update_member_with_version(update, "supportsCpuHotRemove", "xsd:boolean", basic2str(_obj.supportsCpuHotRemove), context, "4.0");
	update_member_with_version(update, "supportsMemoryHotAdd", "xsd:boolean", basic2str(_obj.supportsMemoryHotAdd), context, "4.0");
	update_member(update, "supportsSlaveDisk", "xsd:boolean", basic2str(_obj.supportsSlaveDisk), context);
	update_member_with_version(update, "supportsVMI", "xsd:boolean", basic2str(_obj.supportsVMI), context, "4.0");
	update_member(update, "supportsWakeOnLan", "xsd:boolean", basic2str(_obj.supportsWakeOnLan), context);
	update_member_with_version(update, "usbRecommended", "xsd:boolean", basic2str(_obj.usbRecommended), context, "5.0");
	update_member_with_version(update, "vRAMSizeInKB", "IntOption", handle_obj_ptr(_obj.vRAMSizeInKB), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestOsDescriptor_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecpuFeatureMask)
				return new HostCpuIdInfo_closure(*_obj.cpuFeatureMask[i]);
			else
				return 0;
		}
	case 35:
		if (_obj.vRAMSizeInKB)
			return new IntOption_closure(*_obj.vRAMSizeInKB);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 36) << 16) + arr_index);
	}
	return 0;
}

void GuestPosixFileAttributes_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestPosixFileAttributes", context);
	update_member(update, "groupId", "xsd:int", basic2str(_obj.groupId), context);
	update_member(update, "ownerId", "xsd:int", basic2str(_obj.ownerId), context);
	update_member(update, "permissions", "xsd:long", basic2str(_obj.permissions), context);
	update("Base", "GuestFileAttributes", context);
	GuestFileAttributes_closure(dynamic_cast<const vw1__GuestFileAttributes&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestPosixFileAttributes_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GuestProcessInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestProcessInfo", context);
	update_member(update, "cmdLine", "xsd:string", basic2str(_obj.cmdLine), context);
	update_member(update, "endTime", "xsd:dateTime", basic2str(_obj.endTime), context);
	update_member(update, "exitCode", "xsd:int", basic2str(_obj.exitCode), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "owner", "xsd:string", basic2str(_obj.owner), context);
	update_member(update, "pid", "xsd:long", basic2str(_obj.pid), context);
	update_member(update, "startTime", "xsd:dateTime", basic2str(_obj.startTime), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestProcessInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GuestProgramSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestProgramSpec", context);
	update_member(update, "arguments", "xsd:string", basic2str(_obj.arguments), context);
	update_member(update, "envVariables", "xsd:string[]", a2s_basic(*_obj.envVariables, _obj.__sizeenvVariables), context);
	update_member(update, "programPath", "xsd:string", basic2str(_obj.programPath), context);
	update_member(update, "workingDirectory", "xsd:string", basic2str(_obj.workingDirectory), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestProgramSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GuestScreenInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestScreenInfo", context);
	update_member(update, "height", "xsd:int", basic2str(_obj.height), context);
	update_member(update, "width", "xsd:int", basic2str(_obj.width), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestScreenInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GuestStackInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestStackInfo", context);
	update_member(update, "dhcpConfig", "NetDhcpConfigInfo", handle_obj_ptr(_obj.dhcpConfig), context);
	update_member(update, "dnsConfig", "NetDnsConfigInfo", handle_obj_ptr(_obj.dnsConfig), context);
	update_member(update, "ipRouteConfig", "NetIpRouteConfigInfo", handle_obj_ptr(_obj.ipRouteConfig), context);
	update_member(update, "ipStackConfig", "KeyValue[]", a2s_object(_obj.ipStackConfig, _obj.__sizeipStackConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestStackInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.dhcpConfig)
			return new NetDhcpConfigInfo_closure(*_obj.dhcpConfig);
		else
			return 0;
	case 1:
		if (_obj.dnsConfig)
			return new NetDnsConfigInfo_closure(*_obj.dnsConfig);
		else
			return 0;
	case 2:
		if (_obj.ipRouteConfig)
			return new NetIpRouteConfigInfo_closure(*_obj.ipRouteConfig);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeipStackConfig)
				return new KeyValue_closure(*_obj.ipStackConfig[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void GuestWindowsFileAttributes_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestWindowsFileAttributes", context);
	update_member(update, "createTime", "xsd:dateTime", basic2str(_obj.createTime), context);
	update_member(update, "hidden", "xsd:boolean", basic2str(_obj.hidden), context);
	update_member(update, "readOnly", "xsd:boolean", basic2str(_obj.readOnly), context);
	update("Base", "GuestFileAttributes", context);
	GuestFileAttributes_closure(dynamic_cast<const vw1__GuestFileAttributes&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestWindowsFileAttributes_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GuestWindowsProgramSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestWindowsProgramSpec", context);
	update_member(update, "startMinimized", "xsd:boolean", basic2str(_obj.startMinimized), context);
	update("Base", "GuestProgramSpec", context);
	GuestProgramSpec_closure(dynamic_cast<const vw1__GuestProgramSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestWindowsProgramSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HbrManagerReplicationVmInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HbrManagerReplicationVmInfo", context);
	update_member(update, "imageId", "xsd:string", basic2str(_obj.imageId), context);
	update_member(update, "lastError", "LocalizedMethodFault", handle_obj_ptr(_obj.lastError), context);
	update_member(update, "progressInfo", "ReplicationVmProgressInfo", handle_obj_ptr(_obj.progressInfo), context);
	update_member(update, "state", "xsd:string", basic2str(_obj.state), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HbrManagerReplicationVmInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.lastError)
			return new LocalizedMethodFault_closure(*_obj.lastError);
		else
			return 0;
	case 2:
		if (_obj.progressInfo)
			return new ReplicationVmProgressInfo_closure(*_obj.progressInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HealthStatusChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HealthStatusChangedEvent", context);
	update_member(update, "componentId", "xsd:string", basic2str(_obj.componentId), context);
	update_member(update, "componentName", "xsd:string", basic2str(_obj.componentName), context);
	update_member(update, "newStatus", "xsd:string", basic2str(_obj.newStatus), context);
	update_member(update, "oldStatus", "xsd:string", basic2str(_obj.oldStatus), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HealthStatusChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HealthSystemRuntime_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HealthSystemRuntime", context);
	update_member(update, "hardwareStatusInfo", "HostHardwareStatusInfo", handle_obj_ptr(_obj.hardwareStatusInfo), context);
	update_member(update, "systemHealthInfo", "HostSystemHealthInfo", handle_obj_ptr(_obj.systemHealthInfo), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HealthSystemRuntime_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.hardwareStatusInfo)
			return new HostHardwareStatusInfo_closure(*_obj.hardwareStatusInfo);
		else
			return 0;
	case 1:
		if (_obj.systemHealthInfo)
			return new HostSystemHealthInfo_closure(*_obj.systemHealthInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostAccountSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostAccountSpec", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "password", "xsd:string", basic2str(_obj.password), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostAccountSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostActiveDirectory_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostActiveDirectory", context);
	update_member(update, "changeOperation", "xsd:string", basic2str(_obj.changeOperation), context);
	update_member(update, "spec", "HostActiveDirectorySpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostActiveDirectory_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.spec)
			return new HostActiveDirectorySpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostActiveDirectoryInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostActiveDirectoryInfo", context);
	update_member(update, "domainMembershipStatus", "xsd:string", basic2str(_obj.domainMembershipStatus), context);
	update_member(update, "joinedDomain", "xsd:string", basic2str(_obj.joinedDomain), context);
	update_member(update, "trustedDomain", "xsd:string[]", a2s_basic(*_obj.trustedDomain, _obj.__sizetrustedDomain), context);
	update("Base", "HostDirectoryStoreInfo", context);
	HostDirectoryStoreInfo_closure(dynamic_cast<const vw1__HostDirectoryStoreInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostActiveDirectoryInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostActiveDirectorySpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostActiveDirectorySpec", context);
	update_member_with_version(update, "camServer", "xsd:string", basic2str(_obj.camServer), context, "5.0");
	update_member(update, "domainName", "xsd:string", basic2str(_obj.domainName), context);
	update_member(update, "password", "xsd:string", basic2str(_obj.password), context);
	update_member_with_version(update, "thumbprint", "xsd:string", basic2str(_obj.thumbprint), context, "5.0");
	update_member(update, "userName", "xsd:string", basic2str(_obj.userName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostActiveDirectorySpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostAddFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostAddFailedEvent", context);
	update_member(update, "hostname", "xsd:string", basic2str(_obj.hostname), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostAddFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostAddedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostAddedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostAddedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostAdminDisableEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostAdminDisableEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostAdminDisableEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostAdminEnableEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostAdminEnableEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostAdminEnableEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostApplyProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostApplyProfile", context);
	update_member_with_version(update, "authentication", "AuthenticationProfile", handle_obj_ptr(_obj.authentication), context, "4.1");
	update_member(update, "datetime", "DateTimeProfile", handle_obj_ptr(_obj.datetime), context);
	update_member(update, "firewall", "FirewallProfile", handle_obj_ptr(_obj.firewall), context);
	update_member(update, "memory", "HostMemoryProfile", handle_obj_ptr(_obj.memory), context);
	update_member(update, "network", "NetworkProfile", handle_obj_ptr(_obj.network), context);
	update_member(update, "option", "OptionProfile[]", a2s_object(_obj.option, _obj.__sizeoption), context);
	update_member(update, "security", "SecurityProfile", handle_obj_ptr(_obj.security), context);
	update_member(update, "service", "ServiceProfile[]", a2s_object(_obj.service, _obj.__sizeservice), context);
	update_member(update, "storage", "StorageProfile", handle_obj_ptr(_obj.storage), context);
	update_member(update, "userAccount", "UserProfile[]", a2s_object(_obj.userAccount, _obj.__sizeuserAccount), context);
	update_member(update, "usergroupAccount", "UserGroupProfile[]", a2s_object(_obj.usergroupAccount, _obj.__sizeusergroupAccount), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostApplyProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.authentication)
			return new AuthenticationProfile_closure(*_obj.authentication);
		else
			return 0;
	case 1:
		if (_obj.datetime)
			return new DateTimeProfile_closure(*_obj.datetime);
		else
			return 0;
	case 2:
		if (_obj.firewall)
			return new FirewallProfile_closure(*_obj.firewall);
		else
			return 0;
	case 3:
		if (_obj.memory)
			return new HostMemoryProfile_closure(*_obj.memory);
		else
			return 0;
	case 4:
		if (_obj.network)
			return new NetworkProfile_closure(*_obj.network);
		else
			return 0;
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeoption)
				return new OptionProfile_closure(*_obj.option[i]);
			else
				return 0;
		}
	case 6:
		if (_obj.security)
			return new SecurityProfile_closure(*_obj.security);
		else
			return 0;
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeservice)
				return new ServiceProfile_closure(*_obj.service[i]);
			else
				return 0;
		}
	case 8:
		if (_obj.storage)
			return new StorageProfile_closure(*_obj.storage);
		else
			return 0;
	case 9:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeuserAccount)
				return new UserProfile_closure(*_obj.userAccount[i]);
			else
				return 0;
		}
	case 10:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeusergroupAccount)
				return new UserGroupProfile_closure(*_obj.usergroupAccount[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ApplyProfile_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void HostAuthenticationManagerInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostAuthenticationManagerInfo", context);
	update_member(update, "authConfig", "HostAuthenticationStoreInfo[]", a2s_object(_obj.authConfig, _obj.__sizeauthConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostAuthenticationManagerInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeauthConfig)
				return new HostAuthenticationStoreInfo_closure(*_obj.authConfig[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostAuthenticationStoreInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostAuthenticationStoreInfo", context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostAuthenticationStoreInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostAutoStartManagerConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostAutoStartManagerConfig", context);
	update_member(update, "defaults", "AutoStartDefaults", handle_obj_ptr(_obj.defaults), context);
	update_member(update, "powerInfo", "AutoStartPowerInfo[]", a2s_object(_obj.powerInfo, _obj.__sizepowerInfo), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostAutoStartManagerConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.defaults)
			return new AutoStartDefaults_closure(*_obj.defaults);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepowerInfo)
				return new AutoStartPowerInfo_closure(*_obj.powerInfo[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostBIOSInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostBIOSInfo", context);
	update_member(update, "biosVersion", "xsd:string", basic2str(_obj.biosVersion), context);
	update_member(update, "releaseDate", "xsd:dateTime", basic2str(_obj.releaseDate), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostBIOSInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostBlockAdapterTargetTransport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostBlockAdapterTargetTransport", context);
	update("Base", "HostTargetTransport", context);
	HostTargetTransport_closure(dynamic_cast<const vw1__HostTargetTransport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostBlockAdapterTargetTransport_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostBlockHba_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostBlockHba", context);
	update("Base", "HostHostBusAdapter", context);
	HostHostBusAdapter_closure(dynamic_cast<const vw1__HostHostBusAdapter&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostBlockHba_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostBootDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostBootDevice", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostBootDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostBootDeviceInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostBootDeviceInfo", context);
	update_member(update, "bootDevices", "HostBootDevice[]", a2s_object(_obj.bootDevices, _obj.__sizebootDevices), context);
	update_member(update, "currentBootDeviceKey", "xsd:string", basic2str(_obj.currentBootDeviceKey), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostBootDeviceInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizebootDevices)
				return new HostBootDevice_closure(*_obj.bootDevices[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostCacheConfigurationInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCacheConfigurationInfo", context);
	update_member(update, "key", "Datastore", handle_obj_ptr(_obj.key), context);
	update_member(update, "swapSize", "xsd:long", basic2str(_obj.swapSize), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCacheConfigurationInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.key? 
			get_closure_from_mor(Datastore(_obj.key)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostCacheConfigurationSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCacheConfigurationSpec", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "swapSize", "xsd:long", basic2str(_obj.swapSize), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCacheConfigurationSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostCapability_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCapability", context);
	update_member_with_version(update, "backgroundSnapshotsSupported", "xsd:boolean", basic2str(_obj.backgroundSnapshotsSupported), context, "2.5");
	update_member_with_version(update, "cloneFromSnapshotSupported", "xsd:boolean", basic2str(_obj.cloneFromSnapshotSupported), context, "4.0");
	update_member_with_version(update, "cpuMemoryResourceConfigurationSupported", "xsd:boolean", basic2str(_obj.cpuMemoryResourceConfigurationSupported), context, "2.5");
	update_member(update, "datastorePrincipalSupported", "xsd:boolean", basic2str(_obj.datastorePrincipalSupported), context);
	update_member_with_version(update, "deltaDiskBackingsSupported", "xsd:boolean", basic2str(_obj.deltaDiskBackingsSupported), context, "4.0");
	update_member_with_version(update, "firewallIpRulesSupported", "xsd:boolean", basic2str(_obj.firewallIpRulesSupported), context, "5.0");
	update_member_with_version(update, "ftCompatibilityIssues", "xsd:string[]", a2s_basic(*_obj.ftCompatibilityIssues, _obj.__sizeftCompatibilityIssues), context, "4.1");
	update_member_with_version(update, "ftSupported", "xsd:boolean", basic2str(_obj.ftSupported), context, "4.0");
	update_member(update, "highGuestMemSupported", "xsd:boolean", basic2str(_obj.highGuestMemSupported), context);
	update_member_with_version(update, "ipmiSupported", "xsd:boolean", basic2str(_obj.ipmiSupported), context, "4.0");
	update_member(update, "iscsiSupported", "xsd:boolean", basic2str(_obj.iscsiSupported), context);
	update_member_with_version(update, "localSwapDatastoreSupported", "xsd:boolean", basic2str(_obj.localSwapDatastoreSupported), context, "2.5");
	update_member_with_version(update, "loginBySSLThumbprintSupported", "xsd:boolean", basic2str(_obj.loginBySSLThumbprintSupported), context, "4.0");
	update_member(update, "maintenanceModeSupported", "xsd:boolean", basic2str(_obj.maintenanceModeSupported), context);
	update_member_with_version(update, "maxHostRunningVms", "xsd:int", basic2str(_obj.maxHostRunningVms), context, "5.0");
	update_member_with_version(update, "maxHostSupportedVcpus", "xsd:int", basic2str(_obj.maxHostSupportedVcpus), context, "5.0");
	update_member(update, "maxRunningVMs", "xsd:int", basic2str(_obj.maxRunningVMs), context);
	update_member(update, "maxSupportedVcpus", "xsd:int", basic2str(_obj.maxSupportedVcpus), context);
	update_member(update, "maxSupportedVMs", "xsd:int", basic2str(_obj.maxSupportedVMs), context);
	update_member(update, "nfsSupported", "xsd:boolean", basic2str(_obj.nfsSupported), context);
	update_member(update, "nicTeamingSupported", "xsd:boolean", basic2str(_obj.nicTeamingSupported), context);
	update_member_with_version(update, "perVMNetworkTrafficShapingSupported", "xsd:boolean", basic2str(_obj.perVMNetworkTrafficShapingSupported), context, "4.0");
	update_member_with_version(update, "perVmSwapFiles", "xsd:boolean", basic2str(_obj.perVmSwapFiles), context, "2.5");
	update_member_with_version(update, "preAssignedPCIUnitNumbersSupported", "xsd:boolean", basic2str(_obj.preAssignedPCIUnitNumbersSupported), context, "2.5");
	update_member(update, "rebootSupported", "xsd:boolean", basic2str(_obj.rebootSupported), context);
	update_member_with_version(update, "recordReplaySupported", "xsd:boolean", basic2str(_obj.recordReplaySupported), context, "4.0");
	update_member(update, "recursiveResourcePoolsSupported", "xsd:boolean", basic2str(_obj.recursiveResourcePoolsSupported), context);
	update_member_with_version(update, "replayCompatibilityIssues", "xsd:string[]", a2s_basic(*_obj.replayCompatibilityIssues, _obj.__sizereplayCompatibilityIssues), context, "4.1");
	update_member_with_version(update, "replayUnsupportedReason", "xsd:string", basic2str(_obj.replayUnsupportedReason), context, "4.0");
	update_member_with_version(update, "restrictedSnapshotRelocateSupported", "xsd:boolean", basic2str(_obj.restrictedSnapshotRelocateSupported), context, "2.5");
	update_member(update, "sanSupported", "xsd:boolean", basic2str(_obj.sanSupported), context);
	update_member_with_version(update, "scaledScreenshotSupported", "xsd:boolean", basic2str(_obj.scaledScreenshotSupported), context, "2.5");
	update_member_with_version(update, "screenshotSupported", "xsd:boolean", basic2str(_obj.screenshotSupported), context, "2.5");
	update_member_with_version(update, "servicePackageInfoSupported", "xsd:boolean", basic2str(_obj.servicePackageInfoSupported), context, "5.0");
	update_member(update, "shutdownSupported", "xsd:boolean", basic2str(_obj.shutdownSupported), context);
	update_member_with_version(update, "snapshotRelayoutSupported", "xsd:boolean", basic2str(_obj.snapshotRelayoutSupported), context, "5.0");
	update_member_with_version(update, "standbySupported", "xsd:boolean", basic2str(_obj.standbySupported), context, "2.5");
	update_member_with_version(update, "storageIORMSupported", "xsd:boolean", basic2str(_obj.storageIORMSupported), context, "4.1");
	update_member_with_version(update, "storageVMotionSupported", "xsd:boolean", basic2str(_obj.storageVMotionSupported), context, "4.0");
	update_member_with_version(update, "supportedCpuFeature", "HostCpuIdInfo[]", a2s_object(_obj.supportedCpuFeature, _obj.__sizesupportedCpuFeature), context, "4.0");
	update_member_with_version(update, "supportedVmfsMajorVersion", "xsd:int[]", a2s_basic(_obj.supportedVmfsMajorVersion, _obj.__sizesupportedVmfsMajorVersion), context, "5.0");
	update_member(update, "suspendedRelocateSupported", "xsd:boolean", basic2str(_obj.suspendedRelocateSupported), context);
	update_member_with_version(update, "tpmSupported", "xsd:boolean", basic2str(_obj.tpmSupported), context, "4.0");
	update_member_with_version(update, "unsharedSwapVMotionSupported", "xsd:boolean", basic2str(_obj.unsharedSwapVMotionSupported), context, "2.5");
	update_member_with_version(update, "virtualExecUsageSupported", "xsd:boolean", basic2str(_obj.virtualExecUsageSupported), context, "4.0");
	update_member(update, "vlanTaggingSupported", "xsd:boolean", basic2str(_obj.vlanTaggingSupported), context);
	update_member_with_version(update, "vmDirectPathGen2Supported", "xsd:boolean", basic2str(_obj.vmDirectPathGen2Supported), context, "4.1");
	update_member_with_version(update, "vmDirectPathGen2UnsupportedReason", "xsd:string[]", a2s_basic(*_obj.vmDirectPathGen2UnsupportedReason, _obj.__sizevmDirectPathGen2UnsupportedReason), context, "4.1");
	update_member_with_version(update, "vmDirectPathGen2UnsupportedReasonExtended", "xsd:string", basic2str(_obj.vmDirectPathGen2UnsupportedReasonExtended), context, "4.1");
	update_member_with_version(update, "vmfsDatastoreMountCapable", "xsd:boolean", basic2str(_obj.vmfsDatastoreMountCapable), context, "5.0");
	update_member(update, "vmotionSupported", "xsd:boolean", basic2str(_obj.vmotionSupported), context);
	update_member_with_version(update, "vmotionWithStorageVMotionSupported", "xsd:boolean", basic2str(_obj.vmotionWithStorageVMotionSupported), context, "4.0");
	update_member_with_version(update, "vStorageCapable", "xsd:boolean", basic2str(_obj.vStorageCapable), context, "4.1");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCapability_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 39:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesupportedCpuFeature)
				return new HostCpuIdInfo_closure(*_obj.supportedCpuFeature[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 53) << 16) + arr_index);
	}
	return 0;
}

void HostCnxFailedAccountFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCnxFailedAccountFailedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCnxFailedAccountFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCnxFailedAlreadyManagedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCnxFailedAlreadyManagedEvent", context);
	update_member(update, "serverName", "xsd:string", basic2str(_obj.serverName), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCnxFailedAlreadyManagedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCnxFailedBadCcagentEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCnxFailedBadCcagentEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCnxFailedBadCcagentEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCnxFailedBadUsernameEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCnxFailedBadUsernameEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCnxFailedBadUsernameEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCnxFailedBadVersionEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCnxFailedBadVersionEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCnxFailedBadVersionEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCnxFailedCcagentUpgradeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCnxFailedCcagentUpgradeEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCnxFailedCcagentUpgradeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCnxFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCnxFailedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCnxFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCnxFailedNetworkErrorEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCnxFailedNetworkErrorEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCnxFailedNetworkErrorEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCnxFailedNoAccessEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCnxFailedNoAccessEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCnxFailedNoAccessEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCnxFailedNoConnectionEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCnxFailedNoConnectionEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCnxFailedNoConnectionEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCnxFailedNoLicenseEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCnxFailedNoLicenseEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCnxFailedNoLicenseEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCnxFailedNotFoundEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCnxFailedNotFoundEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCnxFailedNotFoundEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCnxFailedTimeoutEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCnxFailedTimeoutEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCnxFailedTimeoutEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostComplianceCheckedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostComplianceCheckedEvent", context);
	update_member(update, "profile", "ProfileEventArgument", handle_obj_ptr(_obj.profile), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostComplianceCheckedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.profile)
			return new ProfileEventArgument_closure(*_obj.profile);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostCompliantEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCompliantEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCompliantEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostConfigAppliedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostConfigAppliedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostConfigAppliedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostConfigChange_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostConfigChange", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostConfigChange_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostConfigInfo", context);
	update_member(update, "activeDiagnosticPartition", "HostDiagnosticPartition", handle_obj_ptr(_obj.activeDiagnosticPartition), context);
	update_member_with_version(update, "adminDisabled", "xsd:boolean", basic2str(_obj.adminDisabled), context, "2.5");
	update_member_with_version(update, "authenticationManagerInfo", "HostAuthenticationManagerInfo", handle_obj_ptr(_obj.authenticationManagerInfo), context, "4.1");
	update_member(update, "autoStart", "HostAutoStartManagerConfig", handle_obj_ptr(_obj.autoStart), context);
	update_member_with_version(update, "cacheConfigurationInfo", "HostCacheConfigurationInfo[]", a2s_object(_obj.cacheConfigurationInfo, _obj.__sizecacheConfigurationInfo), context, "5.0");
	update_member(update, "capabilities", "HostNetCapabilities", handle_obj_ptr(_obj.capabilities), context);
	update_member_with_version(update, "certificate", "xsd:byte[]", a2s_basic(_obj.certificate, _obj.__sizecertificate), context, "5.0");
	update_member(update, "consoleReservation", "ServiceConsoleReservationInfo", handle_obj_ptr(_obj.consoleReservation), context);
	update_member_with_version(update, "datastoreCapabilities", "HostDatastoreSystemCapabilities", handle_obj_ptr(_obj.datastoreCapabilities), context, "2.5");
	update_member(update, "datastorePrincipal", "xsd:string", basic2str(_obj.datastorePrincipal), context);
	update_member_with_version(update, "dateTimeInfo", "HostDateTimeInfo", handle_obj_ptr(_obj.dateTimeInfo), context, "2.5");
	update_member_with_version(update, "featureVersion", "HostFeatureVersionInfo[]", a2s_object(_obj.featureVersion, _obj.__sizefeatureVersion), context, "4.1");
	update_member(update, "fileSystemVolume", "HostFileSystemVolumeInfo", handle_obj_ptr(_obj.fileSystemVolume), context);
	update_member(update, "firewall", "HostFirewallInfo", handle_obj_ptr(_obj.firewall), context);
	update_member_with_version(update, "flags", "HostFlagInfo", handle_obj_ptr(_obj.flags), context, "2.5");
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "hyperThread", "HostHyperThreadScheduleInfo", handle_obj_ptr(_obj.hyperThread), context);
	update_member_with_version(update, "ipmi", "HostIpmiInfo", handle_obj_ptr(_obj.ipmi), context, "4.0");
	update_member_with_version(update, "localSwapDatastore", "Datastore", handle_obj_ptr(_obj.localSwapDatastore), context, "2.5");
	update_member_with_version(update, "multipathState", "HostMultipathStateInfo", handle_obj_ptr(_obj.multipathState), context, "4.0");
	update_member(update, "network", "HostNetworkInfo", handle_obj_ptr(_obj.network), context);
	update_member(update, "offloadCapabilities", "HostNetOffloadCapabilities", handle_obj_ptr(_obj.offloadCapabilities), context);
	update_member(update, "option", "OptionValue[]", a2s_object(_obj.option, _obj.__sizeoption), context);
	update_member(update, "optionDef", "OptionDef[]", a2s_object(_obj.optionDef, _obj.__sizeoptionDef), context);
	update_member_with_version(update, "pciPassthruInfo", "HostPciPassthruInfo[]", a2s_object(_obj.pciPassthruInfo, _obj.__sizepciPassthruInfo), context, "4.0");
	update_member_with_version(update, "powerSystemCapability", "PowerSystemCapability", handle_obj_ptr(_obj.powerSystemCapability), context, "4.1");
	update_member_with_version(update, "powerSystemInfo", "PowerSystemInfo", handle_obj_ptr(_obj.powerSystemInfo), context, "4.1");
	update_member(update, "product", "AboutInfo", handle_obj_ptr(_obj.product), context);
	update_member(update, "service", "HostServiceInfo", handle_obj_ptr(_obj.service), context);
	update_member_with_version(update, "sslThumbprintData", "HostSslThumbprintInfo[]", a2s_object(_obj.sslThumbprintData, _obj.__sizesslThumbprintData), context, "5.0");
	update_member_with_version(update, "sslThumbprintInfo", "HostSslThumbprintInfo", handle_obj_ptr(_obj.sslThumbprintInfo), context, "4.0");
	update_member(update, "storageDevice", "HostStorageDeviceInfo", handle_obj_ptr(_obj.storageDevice), context);
	update_member_with_version(update, "systemFile", "xsd:string[]", a2s_basic(*_obj.systemFile, _obj.__sizesystemFile), context, "4.1");
	update_member(update, "systemResources", "HostSystemResourceInfo", handle_obj_ptr(_obj.systemResources), context);
	update_member_with_version(update, "virtualMachineReservation", "VirtualMachineMemoryReservationInfo", handle_obj_ptr(_obj.virtualMachineReservation), context, "2.5");
	update_member_with_version(update, "virtualNicManagerInfo", "HostVirtualNicManagerInfo", handle_obj_ptr(_obj.virtualNicManagerInfo), context, "4.0");
	update_member(update, "vmotion", "HostVMotionInfo", handle_obj_ptr(_obj.vmotion), context);
	update_member_with_version(update, "wakeOnLanCapable", "xsd:boolean", basic2str(_obj.wakeOnLanCapable), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.activeDiagnosticPartition)
			return new HostDiagnosticPartition_closure(*_obj.activeDiagnosticPartition);
		else
			return 0;
	case 2:
		if (_obj.authenticationManagerInfo)
			return new HostAuthenticationManagerInfo_closure(*_obj.authenticationManagerInfo);
		else
			return 0;
	case 3:
		if (_obj.autoStart)
			return new HostAutoStartManagerConfig_closure(*_obj.autoStart);
		else
			return 0;
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecacheConfigurationInfo)
				return new HostCacheConfigurationInfo_closure(*_obj.cacheConfigurationInfo[i]);
			else
				return 0;
		}
	case 5:
		if (_obj.capabilities)
			return new HostNetCapabilities_closure(*_obj.capabilities);
		else
			return 0;
	case 7:
		if (_obj.consoleReservation)
			return new ServiceConsoleReservationInfo_closure(*_obj.consoleReservation);
		else
			return 0;
	case 8:
		if (_obj.datastoreCapabilities)
			return new HostDatastoreSystemCapabilities_closure(*_obj.datastoreCapabilities);
		else
			return 0;
	case 10:
		if (_obj.dateTimeInfo)
			return new HostDateTimeInfo_closure(*_obj.dateTimeInfo);
		else
			return 0;
	case 11:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefeatureVersion)
				return new HostFeatureVersionInfo_closure(*_obj.featureVersion[i]);
			else
				return 0;
		}
	case 12:
		if (_obj.fileSystemVolume)
			return new HostFileSystemVolumeInfo_closure(*_obj.fileSystemVolume);
		else
			return 0;
	case 13:
		if (_obj.firewall)
			return new HostFirewallInfo_closure(*_obj.firewall);
		else
			return 0;
	case 14:
		if (_obj.flags)
			return new HostFlagInfo_closure(*_obj.flags);
		else
			return 0;
	case 15:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	case 16:
		if (_obj.hyperThread)
			return new HostHyperThreadScheduleInfo_closure(*_obj.hyperThread);
		else
			return 0;
	case 17:
		if (_obj.ipmi)
			return new HostIpmiInfo_closure(*_obj.ipmi);
		else
			return 0;
	case 18:
		return _obj.localSwapDatastore? 
			get_closure_from_mor(Datastore(_obj.localSwapDatastore)) : 0;
	case 19:
		if (_obj.multipathState)
			return new HostMultipathStateInfo_closure(*_obj.multipathState);
		else
			return 0;
	case 20:
		if (_obj.network)
			return new HostNetworkInfo_closure(*_obj.network);
		else
			return 0;
	case 21:
		if (_obj.offloadCapabilities)
			return new HostNetOffloadCapabilities_closure(*_obj.offloadCapabilities);
		else
			return 0;
	case 22:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeoption)
				return new OptionValue_closure(*_obj.option[i]);
			else
				return 0;
		}
	case 23:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeoptionDef)
				return new OptionDef_closure(*_obj.optionDef[i]);
			else
				return 0;
		}
	case 24:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepciPassthruInfo)
				return new HostPciPassthruInfo_closure(*_obj.pciPassthruInfo[i]);
			else
				return 0;
		}
	case 25:
		if (_obj.powerSystemCapability)
			return new PowerSystemCapability_closure(*_obj.powerSystemCapability);
		else
			return 0;
	case 26:
		if (_obj.powerSystemInfo)
			return new PowerSystemInfo_closure(*_obj.powerSystemInfo);
		else
			return 0;
	case 27:
		if (_obj.product)
			return new AboutInfo_closure(*_obj.product);
		else
			return 0;
	case 28:
		if (_obj.service)
			return new HostServiceInfo_closure(*_obj.service);
		else
			return 0;
	case 29:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesslThumbprintData)
				return new HostSslThumbprintInfo_closure(*_obj.sslThumbprintData[i]);
			else
				return 0;
		}
	case 30:
		if (_obj.sslThumbprintInfo)
			return new HostSslThumbprintInfo_closure(*_obj.sslThumbprintInfo);
		else
			return 0;
	case 31:
		if (_obj.storageDevice)
			return new HostStorageDeviceInfo_closure(*_obj.storageDevice);
		else
			return 0;
	case 33:
		if (_obj.systemResources)
			return new HostSystemResourceInfo_closure(*_obj.systemResources);
		else
			return 0;
	case 34:
		if (_obj.virtualMachineReservation)
			return new VirtualMachineMemoryReservationInfo_closure(*_obj.virtualMachineReservation);
		else
			return 0;
	case 35:
		if (_obj.virtualNicManagerInfo)
			return new HostVirtualNicManagerInfo_closure(*_obj.virtualNicManagerInfo);
		else
			return 0;
	case 36:
		if (_obj.vmotion)
			return new HostVMotionInfo_closure(*_obj.vmotion);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 38) << 16) + arr_index);
	}
	return 0;
}

void HostConfigManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostConfigManager", context);
	update_member(update, "advancedOption", "OptionManager", handle_obj_ptr(_obj.advancedOption), context);
	update_member_with_version(update, "authenticationManager", "HostAuthenticationManager", handle_obj_ptr(_obj.authenticationManager), context, "4.1");
	update_member(update, "autoStartManager", "HostAutoStartManager", handle_obj_ptr(_obj.autoStartManager), context);
	update_member_with_version(update, "bootDeviceSystem", "HostBootDeviceSystem", handle_obj_ptr(_obj.bootDeviceSystem), context, "2.5");
	update_member_with_version(update, "cacheConfigurationManager", "HostCacheConfigurationManager", handle_obj_ptr(_obj.cacheConfigurationManager), context, "5.0");
	update_member(update, "cpuScheduler", "HostCpuSchedulerSystem", handle_obj_ptr(_obj.cpuScheduler), context);
	update_member(update, "datastoreSystem", "HostDatastoreSystem", handle_obj_ptr(_obj.datastoreSystem), context);
	update_member_with_version(update, "dateTimeSystem", "HostDateTimeSystem", handle_obj_ptr(_obj.dateTimeSystem), context, "2.5");
	update_member(update, "diagnosticSystem", "HostDiagnosticSystem", handle_obj_ptr(_obj.diagnosticSystem), context);
	update_member_with_version(update, "esxAgentHostManager", "HostEsxAgentHostManager", handle_obj_ptr(_obj.esxAgentHostManager), context, "5.0");
	update_member(update, "firewallSystem", "HostFirewallSystem", handle_obj_ptr(_obj.firewallSystem), context);
	update_member_with_version(update, "firmwareSystem", "HostFirmwareSystem", handle_obj_ptr(_obj.firmwareSystem), context, "2.5");
	update_member_with_version(update, "healthStatusSystem", "HostHealthStatusSystem", handle_obj_ptr(_obj.healthStatusSystem), context, "2.5");
	update_member_with_version(update, "imageConfigManager", "HostImageConfigManager", handle_obj_ptr(_obj.imageConfigManager), context, "5.0");
	update_member_with_version(update, "iscsiManager", "IscsiManager", handle_obj_ptr(_obj.iscsiManager), context, "5.0");
	update_member_with_version(update, "kernelModuleSystem", "HostKernelModuleSystem", handle_obj_ptr(_obj.kernelModuleSystem), context, "4.0");
	update_member_with_version(update, "licenseManager", "LicenseManager", handle_obj_ptr(_obj.licenseManager), context, "4.0");
	update_member(update, "memoryManager", "HostMemorySystem", handle_obj_ptr(_obj.memoryManager), context);
	update_member(update, "networkSystem", "HostNetworkSystem", handle_obj_ptr(_obj.networkSystem), context);
	update_member_with_version(update, "patchManager", "HostPatchManager", handle_obj_ptr(_obj.patchManager), context, "2.5");
	update_member_with_version(update, "pciPassthruSystem", "HostPciPassthruSystem", handle_obj_ptr(_obj.pciPassthruSystem), context, "4.0");
	update_member_with_version(update, "powerSystem", "HostPowerSystem", handle_obj_ptr(_obj.powerSystem), context, "4.1");
	update_member(update, "serviceSystem", "HostServiceSystem", handle_obj_ptr(_obj.serviceSystem), context);
	update_member(update, "snmpSystem", "HostSnmpSystem", handle_obj_ptr(_obj.snmpSystem), context);
	update_member(update, "storageSystem", "HostStorageSystem", handle_obj_ptr(_obj.storageSystem), context);
	update_member_with_version(update, "virtualNicManager", "HostVirtualNicManager", handle_obj_ptr(_obj.virtualNicManager), context, "4.0");
	update_member(update, "vmotionSystem", "HostVMotionSystem", handle_obj_ptr(_obj.vmotionSystem), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostConfigManager_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.advancedOption? 
			get_closure_from_mor(OptionManager(_obj.advancedOption)) : 0;
	case 1:
		return _obj.authenticationManager? 
			get_closure_from_mor(HostAuthenticationManager(_obj.authenticationManager)) : 0;
	case 2:
		return _obj.autoStartManager? 
			get_closure_from_mor(HostAutoStartManager(_obj.autoStartManager)) : 0;
	case 3:
		return _obj.bootDeviceSystem? 
			get_closure_from_mor(HostBootDeviceSystem(_obj.bootDeviceSystem)) : 0;
	case 4:
		return _obj.cacheConfigurationManager? 
			get_closure_from_mor(HostCacheConfigurationManager(_obj.cacheConfigurationManager)) : 0;
	case 5:
		return _obj.cpuScheduler? 
			get_closure_from_mor(HostCpuSchedulerSystem(_obj.cpuScheduler)) : 0;
	case 6:
		return _obj.datastoreSystem? 
			get_closure_from_mor(HostDatastoreSystem(_obj.datastoreSystem)) : 0;
	case 7:
		return _obj.dateTimeSystem? 
			get_closure_from_mor(HostDateTimeSystem(_obj.dateTimeSystem)) : 0;
	case 8:
		return _obj.diagnosticSystem? 
			get_closure_from_mor(HostDiagnosticSystem(_obj.diagnosticSystem)) : 0;
	case 9:
		return _obj.esxAgentHostManager? 
			get_closure_from_mor(HostEsxAgentHostManager(_obj.esxAgentHostManager)) : 0;
	case 10:
		return _obj.firewallSystem? 
			get_closure_from_mor(HostFirewallSystem(_obj.firewallSystem)) : 0;
	case 11:
		return _obj.firmwareSystem? 
			get_closure_from_mor(HostFirmwareSystem(_obj.firmwareSystem)) : 0;
	case 12:
		return _obj.healthStatusSystem? 
			get_closure_from_mor(HostHealthStatusSystem(_obj.healthStatusSystem)) : 0;
	case 13:
		return _obj.imageConfigManager? 
			get_closure_from_mor(HostImageConfigManager(_obj.imageConfigManager)) : 0;
	case 14:
		return _obj.iscsiManager? 
			get_closure_from_mor(IscsiManager(_obj.iscsiManager)) : 0;
	case 15:
		return _obj.kernelModuleSystem? 
			get_closure_from_mor(HostKernelModuleSystem(_obj.kernelModuleSystem)) : 0;
	case 16:
		return _obj.licenseManager? 
			get_closure_from_mor(LicenseManager(_obj.licenseManager)) : 0;
	case 17:
		return _obj.memoryManager? 
			get_closure_from_mor(HostMemorySystem(_obj.memoryManager)) : 0;
	case 18:
		return _obj.networkSystem? 
			get_closure_from_mor(HostNetworkSystem(_obj.networkSystem)) : 0;
	case 19:
		return _obj.patchManager? 
			get_closure_from_mor(HostPatchManager(_obj.patchManager)) : 0;
	case 20:
		return _obj.pciPassthruSystem? 
			get_closure_from_mor(HostPciPassthruSystem(_obj.pciPassthruSystem)) : 0;
	case 21:
		return _obj.powerSystem? 
			get_closure_from_mor(HostPowerSystem(_obj.powerSystem)) : 0;
	case 22:
		return _obj.serviceSystem? 
			get_closure_from_mor(HostServiceSystem(_obj.serviceSystem)) : 0;
	case 23:
		return _obj.snmpSystem? 
			get_closure_from_mor(HostSnmpSystem(_obj.snmpSystem)) : 0;
	case 24:
		return _obj.storageSystem? 
			get_closure_from_mor(HostStorageSystem(_obj.storageSystem)) : 0;
	case 25:
		return _obj.virtualNicManager? 
			get_closure_from_mor(HostVirtualNicManager(_obj.virtualNicManager)) : 0;
	case 26:
		return _obj.vmotionSystem? 
			get_closure_from_mor(HostVMotionSystem(_obj.vmotionSystem)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 27) << 16) + arr_index);
	}
	return 0;
}

void HostConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostConfigSpec", context);
	update_member_with_version(update, "activeDirectory", "HostActiveDirectory[]", a2s_object(_obj.activeDirectory, _obj.__sizeactiveDirectory), context, "4.1");
	update_member(update, "datastorePrincipal", "xsd:string", basic2str(_obj.datastorePrincipal), context);
	update_member(update, "datastorePrincipalPasswd", "xsd:string", basic2str(_obj.datastorePrincipalPasswd), context);
	update_member(update, "datetime", "HostDateTimeConfig", handle_obj_ptr(_obj.datetime), context);
	update_member(update, "firewall", "HostFirewallConfig", handle_obj_ptr(_obj.firewall), context);
	update_member_with_version(update, "genericConfig", "KeyAnyValue[]", a2s_object(_obj.genericConfig, _obj.__sizegenericConfig), context, "5.0");
	update_member(update, "license", "HostLicenseSpec", handle_obj_ptr(_obj.license), context);
	update_member(update, "memory", "HostMemorySpec", handle_obj_ptr(_obj.memory), context);
	update_member(update, "nasDatastore", "HostNasVolumeConfig[]", a2s_object(_obj.nasDatastore, _obj.__sizenasDatastore), context);
	update_member(update, "network", "HostNetworkConfig", handle_obj_ptr(_obj.network), context);
	update_member(update, "nicTypeSelection", "HostVirtualNicManagerNicTypeSelection[]", a2s_object(_obj.nicTypeSelection, _obj.__sizenicTypeSelection), context);
	update_member(update, "option", "OptionValue[]", a2s_object(_obj.option, _obj.__sizeoption), context);
	update_member(update, "security", "HostSecuritySpec", handle_obj_ptr(_obj.security), context);
	update_member(update, "service", "HostServiceConfig[]", a2s_object(_obj.service, _obj.__sizeservice), context);
	update_member(update, "storageDevice", "HostStorageDeviceInfo", handle_obj_ptr(_obj.storageDevice), context);
	update_member(update, "userAccount", "HostAccountSpec[]", a2s_object(_obj.userAccount, _obj.__sizeuserAccount), context);
	update_member(update, "usergroupAccount", "HostAccountSpec[]", a2s_object(_obj.usergroupAccount, _obj.__sizeusergroupAccount), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeactiveDirectory)
				return new HostActiveDirectory_closure(*_obj.activeDirectory[i]);
			else
				return 0;
		}
	case 3:
		if (_obj.datetime)
			return new HostDateTimeConfig_closure(*_obj.datetime);
		else
			return 0;
	case 4:
		if (_obj.firewall)
			return new HostFirewallConfig_closure(*_obj.firewall);
		else
			return 0;
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizegenericConfig)
				return new KeyAnyValue_closure(*_obj.genericConfig[i]);
			else
				return 0;
		}
	case 6:
		if (_obj.license)
			return new HostLicenseSpec_closure(*_obj.license);
		else
			return 0;
	case 7:
		if (_obj.memory)
			return new HostMemorySpec_closure(*_obj.memory);
		else
			return 0;
	case 8:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenasDatastore)
				return new HostNasVolumeConfig_closure(*_obj.nasDatastore[i]);
			else
				return 0;
		}
	case 9:
		if (_obj.network)
			return new HostNetworkConfig_closure(*_obj.network);
		else
			return 0;
	case 10:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenicTypeSelection)
				return new HostVirtualNicManagerNicTypeSelection_closure(*_obj.nicTypeSelection[i]);
			else
				return 0;
		}
	case 11:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeoption)
				return new OptionValue_closure(*_obj.option[i]);
			else
				return 0;
		}
	case 12:
		if (_obj.security)
			return new HostSecuritySpec_closure(*_obj.security);
		else
			return 0;
	case 13:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeservice)
				return new HostServiceConfig_closure(*_obj.service[i]);
			else
				return 0;
		}
	case 14:
		if (_obj.storageDevice)
			return new HostStorageDeviceInfo_closure(*_obj.storageDevice);
		else
			return 0;
	case 15:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeuserAccount)
				return new HostAccountSpec_closure(*_obj.userAccount[i]);
			else
				return 0;
		}
	case 16:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeusergroupAccount)
				return new HostAccountSpec_closure(*_obj.usergroupAccount[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 17) << 16) + arr_index);
	}
	return 0;
}

void HostConfigSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostConfigSummary", context);
	update_member_with_version(update, "agentVmDatastore", "Datastore", handle_obj_ptr(_obj.agentVmDatastore), context, "5.0");
	update_member_with_version(update, "agentVmNetwork", "Network", handle_obj_ptr(_obj.agentVmNetwork), context, "5.0");
	update_member_with_version(update, "faultToleranceEnabled", "xsd:boolean", basic2str(_obj.faultToleranceEnabled), context, "4.0");
	update_member_with_version(update, "featureVersion", "HostFeatureVersionInfo[]", a2s_object(_obj.featureVersion, _obj.__sizefeatureVersion), context, "4.1");
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "port", "xsd:int", basic2str(_obj.port), context);
	update_member(update, "product", "AboutInfo", handle_obj_ptr(_obj.product), context);
	update_member_with_version(update, "sslThumbprint", "xsd:string", basic2str(_obj.sslThumbprint), context, "4.0");
	update_member(update, "vmotionEnabled", "xsd:boolean", basic2str(_obj.vmotionEnabled), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostConfigSummary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.agentVmDatastore? 
			get_closure_from_mor(Datastore(_obj.agentVmDatastore)) : 0;
	case 1:
		return _obj.agentVmNetwork? 
			get_closure_from_mor(Network(_obj.agentVmNetwork)) : 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefeatureVersion)
				return new HostFeatureVersionInfo_closure(*_obj.featureVersion[i]);
			else
				return 0;
		}
	case 6:
		if (_obj.product)
			return new AboutInfo_closure(*_obj.product);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 9) << 16) + arr_index);
	}
	return 0;
}

void HostConnectInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostConnectInfo", context);
	update_member(update, "clusterSupported", "xsd:boolean", basic2str(_obj.clusterSupported), context);
	update_member(update, "datastore", "HostDatastoreConnectInfo[]", a2s_object(_obj.datastore, _obj.__sizedatastore), context);
	update_member(update, "host", "HostListSummary", handle_obj_ptr(_obj.host), context);
	update_member_with_version(update, "inDasCluster", "xsd:boolean", basic2str(_obj.inDasCluster), context, "5.0");
	update_member_with_version(update, "license", "HostLicenseConnectInfo", handle_obj_ptr(_obj.license), context, "4.0");
	update_member(update, "network", "HostConnectInfoNetworkInfo[]", a2s_object(_obj.network, _obj.__sizenetwork), context);
	update_member(update, "serverIp", "xsd:string", basic2str(_obj.serverIp), context);
	update_member(update, "vimAccountNameRequired", "xsd:boolean", basic2str(_obj.vimAccountNameRequired), context);
	update_member(update, "vm", "VirtualMachineSummary[]", a2s_object(_obj.vm, _obj.__sizevm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostConnectInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedatastore)
				return new HostDatastoreConnectInfo_closure(*_obj.datastore[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.host)
			return new HostListSummary_closure(*_obj.host);
		else
			return 0;
	case 4:
		if (_obj.license)
			return new HostLicenseConnectInfo_closure(*_obj.license);
		else
			return 0;
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenetwork)
				return new HostConnectInfoNetworkInfo_closure(*_obj.network[i]);
			else
				return 0;
		}
	case 8:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevm)
				return new VirtualMachineSummary_closure(*_obj.vm[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 9) << 16) + arr_index);
	}
	return 0;
}

void HostConnectInfoNetworkInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostConnectInfoNetworkInfo", context);
	update_member(update, "summary", "NetworkSummary", handle_obj_ptr(_obj.summary), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostConnectInfoNetworkInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.summary)
			return new NetworkSummary_closure(*_obj.summary);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostConnectSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostConnectSpec", context);
	update_member(update, "force", "xsd:boolean", basic2str(_obj.force), context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update_member_with_version(update, "managementIp", "xsd:string", basic2str(_obj.managementIp), context, "4.0");
	update_member(update, "password", "xsd:string", basic2str(_obj.password), context);
	update_member(update, "port", "xsd:int", basic2str(_obj.port), context);
	update_member_with_version(update, "sslThumbprint", "xsd:string", basic2str(_obj.sslThumbprint), context, "2.5");
	update_member(update, "userName", "xsd:string", basic2str(_obj.userName), context);
	update_member(update, "vimAccountName", "xsd:string", basic2str(_obj.vimAccountName), context);
	update_member(update, "vimAccountPassword", "xsd:string", basic2str(_obj.vimAccountPassword), context);
	update_member(update, "vmFolder", "Folder", handle_obj_ptr(_obj.vmFolder), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostConnectSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 9:
		return _obj.vmFolder? 
			get_closure_from_mor(Folder(_obj.vmFolder)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 10) << 16) + arr_index);
	}
	return 0;
}

void HostConnectedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostConnectedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostConnectedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostConnectionLostEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostConnectionLostEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostConnectionLostEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCpuIdInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCpuIdInfo", context);
	update_member(update, "eax", "xsd:string", basic2str(_obj.eax), context);
	update_member(update, "ebx", "xsd:string", basic2str(_obj.ebx), context);
	update_member(update, "ecx", "xsd:string", basic2str(_obj.ecx), context);
	update_member(update, "edx", "xsd:string", basic2str(_obj.edx), context);
	update_member(update, "level", "xsd:int", basic2str(_obj.level), context);
	update_member(update, "vendor", "xsd:string", basic2str(_obj.vendor), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCpuIdInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCpuInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCpuInfo", context);
	update_member(update, "hz", "xsd:long", basic2str(_obj.hz), context);
	update_member(update, "numCpuCores", "xsd:short", basic2str(_obj.numCpuCores), context);
	update_member(update, "numCpuPackages", "xsd:short", basic2str(_obj.numCpuPackages), context);
	update_member(update, "numCpuThreads", "xsd:short", basic2str(_obj.numCpuThreads), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCpuInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCpuPackage_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCpuPackage", context);
	update_member(update, "busHz", "xsd:long", basic2str(_obj.busHz), context);
	update_member(update, "cpuFeature", "HostCpuIdInfo[]", a2s_object(_obj.cpuFeature, _obj.__sizecpuFeature), context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "hz", "xsd:long", basic2str(_obj.hz), context);
	update_member(update, "index", "xsd:short", basic2str(_obj.index), context);
	update_member(update, "threadId", "xsd:short[]", a2s_basic(_obj.threadId, _obj.__sizethreadId), context);
	update_member(update, "vendor", "xsd:string", basic2str(_obj.vendor), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCpuPackage_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecpuFeature)
				return new HostCpuIdInfo_closure(*_obj.cpuFeature[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void HostCpuPowerManagementInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCpuPowerManagementInfo", context);
	update_member(update, "currentPolicy", "xsd:string", basic2str(_obj.currentPolicy), context);
	update_member(update, "hardwareSupport", "xsd:string", basic2str(_obj.hardwareSupport), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCpuPowerManagementInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDasDisabledEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDasDisabledEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDasDisabledEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDasDisablingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDasDisablingEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDasDisablingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDasEnabledEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDasEnabledEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDasEnabledEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDasEnablingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDasEnablingEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDasEnablingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDasErrorEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDasErrorEvent", context);
	update_member_with_version(update, "message", "xsd:string", basic2str(_obj.message), context, "2.5");
	update_member_with_version(update, "reason", "xsd:string", basic2str(_obj.reason), context, "4.0");
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDasErrorEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDasEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDasEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDasEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDasOkEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDasOkEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDasOkEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDatastoreBrowserSearchResults_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDatastoreBrowserSearchResults", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "file", "FileInfo[]", a2s_object(_obj.file, _obj.__sizefile), context);
	update_member(update, "folderPath", "xsd:string", basic2str(_obj.folderPath), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDatastoreBrowserSearchResults_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefile)
				return new FileInfo_closure(*_obj.file[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostDatastoreBrowserSearchSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDatastoreBrowserSearchSpec", context);
	update_member(update, "details", "FileQueryFlags", handle_obj_ptr(_obj.details), context);
	update_member(update, "matchPattern", "xsd:string[]", a2s_basic(*_obj.matchPattern, _obj.__sizematchPattern), context);
	update_member(update, "query", "FileQuery[]", a2s_object(_obj.query, _obj.__sizequery), context);
	update_member(update, "searchCaseInsensitive", "xsd:boolean", basic2str(_obj.searchCaseInsensitive), context);
	update_member(update, "sortFoldersFirst", "xsd:boolean", basic2str(_obj.sortFoldersFirst), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDatastoreBrowserSearchSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.details)
			return new FileQueryFlags_closure(*_obj.details);
		else
			return 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizequery)
				return new FileQuery_closure(*_obj.query[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void HostDatastoreConnectInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDatastoreConnectInfo", context);
	update_member(update, "summary", "DatastoreSummary", handle_obj_ptr(_obj.summary), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDatastoreConnectInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.summary)
			return new DatastoreSummary_closure(*_obj.summary);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostDatastoreExistsConnectInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDatastoreExistsConnectInfo", context);
	update_member(update, "newDatastoreName", "xsd:string", basic2str(_obj.newDatastoreName), context);
	update("Base", "HostDatastoreConnectInfo", context);
	HostDatastoreConnectInfo_closure(dynamic_cast<const vw1__HostDatastoreConnectInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDatastoreExistsConnectInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDatastoreNameConflictConnectInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDatastoreNameConflictConnectInfo", context);
	update_member(update, "newDatastoreName", "xsd:string", basic2str(_obj.newDatastoreName), context);
	update("Base", "HostDatastoreConnectInfo", context);
	HostDatastoreConnectInfo_closure(dynamic_cast<const vw1__HostDatastoreConnectInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDatastoreNameConflictConnectInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDatastoreSystemCapabilities_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDatastoreSystemCapabilities", context);
	update_member(update, "localDatastoreSupported", "xsd:boolean", basic2str(_obj.localDatastoreSupported), context);
	update_member(update, "nfsMountCreationRequired", "xsd:boolean", basic2str(_obj.nfsMountCreationRequired), context);
	update_member(update, "nfsMountCreationSupported", "xsd:boolean", basic2str(_obj.nfsMountCreationSupported), context);
	update_member_with_version(update, "vmfsExtentExpansionSupported", "xsd:boolean", basic2str(_obj.vmfsExtentExpansionSupported), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDatastoreSystemCapabilities_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDateTimeConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDateTimeConfig", context);
	update_member(update, "ntpConfig", "HostNtpConfig", handle_obj_ptr(_obj.ntpConfig), context);
	update_member(update, "timeZone", "xsd:string", basic2str(_obj.timeZone), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDateTimeConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.ntpConfig)
			return new HostNtpConfig_closure(*_obj.ntpConfig);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostDateTimeInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDateTimeInfo", context);
	update_member(update, "ntpConfig", "HostNtpConfig", handle_obj_ptr(_obj.ntpConfig), context);
	update_member(update, "timeZone", "HostDateTimeSystemTimeZone", handle_obj_ptr(_obj.timeZone), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDateTimeInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.ntpConfig)
			return new HostNtpConfig_closure(*_obj.ntpConfig);
		else
			return 0;
	case 1:
		if (_obj.timeZone)
			return new HostDateTimeSystemTimeZone_closure(*_obj.timeZone);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostDateTimeSystemTimeZone_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDateTimeSystemTimeZone", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "gmtOffset", "xsd:int", basic2str(_obj.gmtOffset), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDateTimeSystemTimeZone_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDevice", context);
	update_member(update, "deviceName", "xsd:string", basic2str(_obj.deviceName), context);
	update_member(update, "deviceType", "xsd:string", basic2str(_obj.deviceType), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDhcpService_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDhcpService", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "spec", "HostDhcpServiceSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDhcpService_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.spec)
			return new HostDhcpServiceSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostDhcpServiceConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDhcpServiceConfig", context);
	update_member(update, "changeOperation", "xsd:string", basic2str(_obj.changeOperation), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "spec", "HostDhcpServiceSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDhcpServiceConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.spec)
			return new HostDhcpServiceSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostDhcpServiceSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDhcpServiceSpec", context);
	update_member(update, "defaultLeaseDuration", "xsd:int", basic2str(_obj.defaultLeaseDuration), context);
	update_member(update, "ipSubnetAddr", "xsd:string", basic2str(_obj.ipSubnetAddr), context);
	update_member(update, "ipSubnetMask", "xsd:string", basic2str(_obj.ipSubnetMask), context);
	update_member(update, "leaseBeginIp", "xsd:string", basic2str(_obj.leaseBeginIp), context);
	update_member(update, "leaseEndIp", "xsd:string", basic2str(_obj.leaseEndIp), context);
	update_member(update, "maxLeaseDuration", "xsd:int", basic2str(_obj.maxLeaseDuration), context);
	update_member(update, "unlimitedLease", "xsd:boolean", basic2str(_obj.unlimitedLease), context);
	update_member(update, "virtualSwitch", "xsd:string", basic2str(_obj.virtualSwitch), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDhcpServiceSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDiagnosticPartition_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiagnosticPartition", context);
	update_member(update, "diagnosticType", "xsd:string", basic2str(_obj.diagnosticType), context);
	update_member(update, "id", "HostScsiDiskPartition", handle_obj_ptr(_obj.id), context);
	update_member(update, "slots", "xsd:int", basic2str(_obj.slots), context);
	update_member(update, "storageType", "xsd:string", basic2str(_obj.storageType), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiagnosticPartition_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.id)
			return new HostScsiDiskPartition_closure(*_obj.id);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostDiagnosticPartitionCreateDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiagnosticPartitionCreateDescription", context);
	update_member(update, "diskUuid", "xsd:string", basic2str(_obj.diskUuid), context);
	update_member(update, "layout", "HostDiskPartitionLayout", handle_obj_ptr(_obj.layout), context);
	update_member(update, "spec", "HostDiagnosticPartitionCreateSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiagnosticPartitionCreateDescription_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.layout)
			return new HostDiskPartitionLayout_closure(*_obj.layout);
		else
			return 0;
	case 2:
		if (_obj.spec)
			return new HostDiagnosticPartitionCreateSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostDiagnosticPartitionCreateOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiagnosticPartitionCreateOption", context);
	update_member(update, "diagnosticType", "xsd:string", basic2str(_obj.diagnosticType), context);
	update_member(update, "disk", "HostScsiDisk", handle_obj_ptr(_obj.disk), context);
	update_member(update, "storageType", "xsd:string", basic2str(_obj.storageType), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiagnosticPartitionCreateOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.disk)
			return new HostScsiDisk_closure(*_obj.disk);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostDiagnosticPartitionCreateSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiagnosticPartitionCreateSpec", context);
	update_member(update, "active", "xsd:boolean", basic2str(_obj.active), context);
	update_member(update, "diagnosticType", "xsd:string", basic2str(_obj.diagnosticType), context);
	update_member(update, "id", "HostScsiDiskPartition", handle_obj_ptr(_obj.id), context);
	update_member(update, "partition", "HostDiskPartitionSpec", handle_obj_ptr(_obj.partition), context);
	update_member(update, "storageType", "xsd:string", basic2str(_obj.storageType), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiagnosticPartitionCreateSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.id)
			return new HostScsiDiskPartition_closure(*_obj.id);
		else
			return 0;
	case 3:
		if (_obj.partition)
			return new HostDiskPartitionSpec_closure(*_obj.partition);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void HostDigestInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDigestInfo", context);
	update_member(update, "digestMethod", "xsd:string", basic2str(_obj.digestMethod), context);
	update_member(update, "digestValue", "xsd:byte[]", a2s_basic(_obj.digestValue, _obj.__sizedigestValue), context);
	update_member(update, "objectName", "xsd:string", basic2str(_obj.objectName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDigestInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDirectoryStoreInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDirectoryStoreInfo", context);
	update("Base", "HostAuthenticationStoreInfo", context);
	HostAuthenticationStoreInfo_closure(dynamic_cast<const vw1__HostAuthenticationStoreInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDirectoryStoreInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDisconnectedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDisconnectedEvent", context);
	update_member_with_version(update, "reason", "xsd:string", basic2str(_obj.reason), context, "4.0");
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDisconnectedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDiskDimensions_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiskDimensions", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiskDimensions_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDiskDimensionsChs_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiskDimensionsChs", context);
	update_member(update, "cylinder", "xsd:long", basic2str(_obj.cylinder), context);
	update_member(update, "head", "xsd:int", basic2str(_obj.head), context);
	update_member(update, "sector", "xsd:int", basic2str(_obj.sector), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiskDimensionsChs_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDiskDimensionsLba_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiskDimensionsLba", context);
	update_member(update, "block", "xsd:long", basic2str(_obj.block), context);
	update_member(update, "blockSize", "xsd:int", basic2str(_obj.blockSize), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiskDimensionsLba_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDiskMappingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiskMappingInfo", context);
	update_member(update, "exclusive", "xsd:boolean", basic2str(_obj.exclusive), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "physicalPartition", "HostDiskMappingPartitionInfo", handle_obj_ptr(_obj.physicalPartition), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiskMappingInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.physicalPartition)
			return new HostDiskMappingPartitionInfo_closure(*_obj.physicalPartition);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostDiskMappingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiskMappingOption", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "physicalPartition", "HostDiskMappingPartitionOption[]", a2s_object(_obj.physicalPartition, _obj.__sizephysicalPartition), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiskMappingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizephysicalPartition)
				return new HostDiskMappingPartitionOption_closure(*_obj.physicalPartition[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostDiskMappingPartitionInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiskMappingPartitionInfo", context);
	update_member(update, "capacityInKb", "xsd:long", basic2str(_obj.capacityInKb), context);
	update_member(update, "fileSystem", "xsd:string", basic2str(_obj.fileSystem), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiskMappingPartitionInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDiskMappingPartitionOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiskMappingPartitionOption", context);
	update_member(update, "capacityInKb", "xsd:long", basic2str(_obj.capacityInKb), context);
	update_member(update, "fileSystem", "xsd:string", basic2str(_obj.fileSystem), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiskMappingPartitionOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDiskPartitionAttributes_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiskPartitionAttributes", context);
	update_member(update, "attributes", "xsd:byte", basic2str(_obj.attributes), context);
	update_member(update, "endSector", "xsd:long", basic2str(_obj.endSector), context);
	update_member_with_version(update, "guid", "xsd:string", basic2str(_obj.guid), context, "5.0");
	update_member(update, "logical", "xsd:boolean", basic2str(_obj.logical), context);
	update_member(update, "partition", "xsd:int", basic2str(_obj.partition), context);
	update_member_with_version(update, "partitionAlignment", "xsd:long", basic2str(_obj.partitionAlignment), context, "5.0");
	update_member(update, "startSector", "xsd:long", basic2str(_obj.startSector), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiskPartitionAttributes_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDiskPartitionBlockRange_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiskPartitionBlockRange", context);
	update_member(update, "end", "HostDiskDimensionsLba", handle_obj_ptr(_obj.end), context);
	update_member(update, "partition", "xsd:int", basic2str(_obj.partition), context);
	update_member(update, "start", "HostDiskDimensionsLba", handle_obj_ptr(_obj.start), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiskPartitionBlockRange_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.end)
			return new HostDiskDimensionsLba_closure(*_obj.end);
		else
			return 0;
	case 2:
		if (_obj.start)
			return new HostDiskDimensionsLba_closure(*_obj.start);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostDiskPartitionInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiskPartitionInfo", context);
	update_member(update, "deviceName", "xsd:string", basic2str(_obj.deviceName), context);
	update_member(update, "layout", "HostDiskPartitionLayout", handle_obj_ptr(_obj.layout), context);
	update_member(update, "spec", "HostDiskPartitionSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiskPartitionInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.layout)
			return new HostDiskPartitionLayout_closure(*_obj.layout);
		else
			return 0;
	case 2:
		if (_obj.spec)
			return new HostDiskPartitionSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostDiskPartitionLayout_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiskPartitionLayout", context);
	update_member(update, "partition", "HostDiskPartitionBlockRange[]", a2s_object(_obj.partition, _obj.__sizepartition), context);
	update_member(update, "total", "HostDiskDimensionsLba", handle_obj_ptr(_obj.total), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiskPartitionLayout_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepartition)
				return new HostDiskPartitionBlockRange_closure(*_obj.partition[i]);
			else
				return 0;
		}
	case 1:
		if (_obj.total)
			return new HostDiskDimensionsLba_closure(*_obj.total);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostDiskPartitionSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiskPartitionSpec", context);
	update_member(update, "chs", "HostDiskDimensionsChs", handle_obj_ptr(_obj.chs), context);
	update_member(update, "partition", "HostDiskPartitionAttributes[]", a2s_object(_obj.partition, _obj.__sizepartition), context);
	update_member_with_version(update, "partitionFormat", "xsd:string", basic2str(_obj.partitionFormat), context, "5.0");
	update_member(update, "totalSectors", "xsd:long", basic2str(_obj.totalSectors), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDiskPartitionSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.chs)
			return new HostDiskDimensionsChs_closure(*_obj.chs);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepartition)
				return new HostDiskPartitionAttributes_closure(*_obj.partition[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostDnsConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDnsConfig", context);
	update_member(update, "address", "xsd:string[]", a2s_basic(*_obj.address, _obj.__sizeaddress), context);
	update_member(update, "dhcp", "xsd:boolean", basic2str(_obj.dhcp), context);
	update_member(update, "domainName", "xsd:string", basic2str(_obj.domainName), context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update_member(update, "searchDomain", "xsd:string[]", a2s_basic(*_obj.searchDomain, _obj.__sizesearchDomain), context);
	update_member(update, "virtualNicDevice", "xsd:string", basic2str(_obj.virtualNicDevice), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDnsConfig_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostDnsConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDnsConfigSpec", context);
	update_member(update, "virtualNicConnection", "HostVirtualNicConnection", handle_obj_ptr(_obj.virtualNicConnection), context);
	update("Base", "HostDnsConfig", context);
	HostDnsConfig_closure(dynamic_cast<const vw1__HostDnsConfig&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDnsConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.virtualNicConnection)
			return new HostVirtualNicConnection_closure(*_obj.virtualNicConnection);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostDnsConfig_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostEnableAdminFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostEnableAdminFailedEvent", context);
	update_member(update, "permissions", "Permission[]", a2s_object(_obj.permissions, _obj.__sizepermissions), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostEnableAdminFailedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepermissions)
				return new Permission_closure(*_obj.permissions[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostEsxAgentHostManagerConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostEsxAgentHostManagerConfigInfo", context);
	update_member(update, "agentVmDatastore", "Datastore", handle_obj_ptr(_obj.agentVmDatastore), context);
	update_member(update, "agentVmNetwork", "Network", handle_obj_ptr(_obj.agentVmNetwork), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostEsxAgentHostManagerConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.agentVmDatastore? 
			get_closure_from_mor(Datastore(_obj.agentVmDatastore)) : 0;
	case 1:
		return _obj.agentVmNetwork? 
			get_closure_from_mor(Network(_obj.agentVmNetwork)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostEvent", context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostEventArgument", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update("Base", "EntityEventArgument", context);
	EntityEventArgument_closure(dynamic_cast<const vw1__EntityEventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostEventArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return EntityEventArgument_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostExtraNetworksEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostExtraNetworksEvent", context);
	update_member(update, "ips", "xsd:string", basic2str(_obj.ips), context);
	update("Base", "HostDasEvent", context);
	HostDasEvent_closure(dynamic_cast<const vw1__HostDasEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostExtraNetworksEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostFeatureVersionInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFeatureVersionInfo", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFeatureVersionInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostFibreChannelHba_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFibreChannelHba", context);
	update_member(update, "nodeWorldWideName", "xsd:long", basic2str(_obj.nodeWorldWideName), context);
	update_member(update, "portType", "FibreChannelPortType", handle_obj(_obj.portType), context);
	update_member(update, "portWorldWideName", "xsd:long", basic2str(_obj.portWorldWideName), context);
	update_member(update, "speed", "xsd:long", basic2str(_obj.speed), context);
	update("Base", "HostHostBusAdapter", context);
	HostHostBusAdapter_closure(dynamic_cast<const vw1__HostHostBusAdapter&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFibreChannelHba_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostFibreChannelOverEthernetHba_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFibreChannelOverEthernetHba", context);
	update_member(update, "isSoftwareFcoe", "xsd:boolean", basic2str(_obj.isSoftwareFcoe), context);
	update_member(update, "linkInfo", "HostFibreChannelOverEthernetHbaLinkInfo", handle_obj_ptr(_obj.linkInfo), context);
	update_member(update, "markedForRemoval", "xsd:boolean", basic2str(_obj.markedForRemoval), context);
	update_member(update, "underlyingNic", "xsd:string", basic2str(_obj.underlyingNic), context);
	update("Base", "HostFibreChannelHba", context);
	HostFibreChannelHba_closure(dynamic_cast<const vw1__HostFibreChannelHba&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFibreChannelOverEthernetHba_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.linkInfo)
			return new HostFibreChannelOverEthernetHbaLinkInfo_closure(*_obj.linkInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostFibreChannelHba_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostFibreChannelOverEthernetHbaLinkInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFibreChannelOverEthernetHbaLinkInfo", context);
	update_member(update, "fcfMac", "xsd:string", basic2str(_obj.fcfMac), context);
	update_member(update, "vlanId", "xsd:int", basic2str(_obj.vlanId), context);
	update_member(update, "vnportMac", "xsd:string", basic2str(_obj.vnportMac), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFibreChannelOverEthernetHbaLinkInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostFibreChannelOverEthernetTargetTransport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFibreChannelOverEthernetTargetTransport", context);
	update_member(update, "fcfMac", "xsd:string", basic2str(_obj.fcfMac), context);
	update_member(update, "vlanId", "xsd:int", basic2str(_obj.vlanId), context);
	update_member(update, "vnportMac", "xsd:string", basic2str(_obj.vnportMac), context);
	update("Base", "HostFibreChannelTargetTransport", context);
	HostFibreChannelTargetTransport_closure(dynamic_cast<const vw1__HostFibreChannelTargetTransport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFibreChannelOverEthernetTargetTransport_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostFibreChannelTargetTransport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFibreChannelTargetTransport", context);
	update_member(update, "nodeWorldWideName", "xsd:long", basic2str(_obj.nodeWorldWideName), context);
	update_member(update, "portWorldWideName", "xsd:long", basic2str(_obj.portWorldWideName), context);
	update("Base", "HostTargetTransport", context);
	HostTargetTransport_closure(dynamic_cast<const vw1__HostTargetTransport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFibreChannelTargetTransport_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostFileAccess_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFileAccess", context);
	update_member(update, "what", "xsd:string", basic2str(_obj.what), context);
	update_member(update, "who", "xsd:string", basic2str(_obj.who), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFileAccess_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostFileSystemMountInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFileSystemMountInfo", context);
	update_member(update, "mountInfo", "HostMountInfo", handle_obj_ptr(_obj.mountInfo), context);
	update_member(update, "volume", "HostFileSystemVolume", handle_obj_ptr(_obj.volume), context);
	update_member_with_version(update, "vStorageSupport", "xsd:string", basic2str(_obj.vStorageSupport), context, "4.1");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFileSystemMountInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.mountInfo)
			return new HostMountInfo_closure(*_obj.mountInfo);
		else
			return 0;
	case 1:
		if (_obj.volume)
			return new HostFileSystemVolume_closure(*_obj.volume);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostFileSystemVolume_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFileSystemVolume", context);
	update_member(update, "capacity", "xsd:long", basic2str(_obj.capacity), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFileSystemVolume_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostFileSystemVolumeInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFileSystemVolumeInfo", context);
	update_member(update, "mountInfo", "HostFileSystemMountInfo[]", a2s_object(_obj.mountInfo, _obj.__sizemountInfo), context);
	update_member(update, "volumeTypeList", "xsd:string[]", a2s_basic(*_obj.volumeTypeList, _obj.__sizevolumeTypeList), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFileSystemVolumeInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemountInfo)
				return new HostFileSystemMountInfo_closure(*_obj.mountInfo[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostFirewallConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFirewallConfig", context);
	update_member(update, "defaultBlockingPolicy", "HostFirewallDefaultPolicy", handle_obj_ptr(_obj.defaultBlockingPolicy), context);
	update_member(update, "rule", "HostFirewallConfigRuleSetConfig[]", a2s_object(_obj.rule, _obj.__sizerule), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFirewallConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.defaultBlockingPolicy)
			return new HostFirewallDefaultPolicy_closure(*_obj.defaultBlockingPolicy);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerule)
				return new HostFirewallConfigRuleSetConfig_closure(*_obj.rule[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostFirewallConfigRuleSetConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFirewallConfigRuleSetConfig", context);
	update_member_with_version(update, "allowedHosts", "HostFirewallRulesetIpList", handle_obj_ptr(_obj.allowedHosts), context, "5.0");
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "rulesetId", "xsd:string", basic2str(_obj.rulesetId), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFirewallConfigRuleSetConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.allowedHosts)
			return new HostFirewallRulesetIpList_closure(*_obj.allowedHosts);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostFirewallDefaultPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFirewallDefaultPolicy", context);
	update_member(update, "incomingBlocked", "xsd:boolean", basic2str(_obj.incomingBlocked), context);
	update_member(update, "outgoingBlocked", "xsd:boolean", basic2str(_obj.outgoingBlocked), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFirewallDefaultPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostFirewallInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFirewallInfo", context);
	update_member(update, "defaultPolicy", "HostFirewallDefaultPolicy", handle_obj_ptr(_obj.defaultPolicy), context);
	update_member(update, "ruleset", "HostFirewallRuleset[]", a2s_object(_obj.ruleset, _obj.__sizeruleset), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFirewallInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.defaultPolicy)
			return new HostFirewallDefaultPolicy_closure(*_obj.defaultPolicy);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeruleset)
				return new HostFirewallRuleset_closure(*_obj.ruleset[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostFirewallRule_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFirewallRule", context);
	update_member(update, "direction", "HostFirewallRuleDirection", handle_obj(_obj.direction), context);
	update_member(update, "endPort", "xsd:int", basic2str(_obj.endPort), context);
	update_member(update, "port", "xsd:int", basic2str(_obj.port), context);
	update_member_with_version(update, "portType", "HostFirewallRulePortType", handle_obj_ptr(_obj.portType), context, "5.0");
	update_member(update, "protocol", "xsd:string", basic2str(_obj.protocol), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFirewallRule_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostFirewallRuleset_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFirewallRuleset", context);
	update_member_with_version(update, "allowedHosts", "HostFirewallRulesetIpList", handle_obj_ptr(_obj.allowedHosts), context, "5.0");
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "label", "xsd:string", basic2str(_obj.label), context);
	update_member(update, "required", "xsd:boolean", basic2str(_obj.required), context);
	update_member(update, "rule", "HostFirewallRule[]", a2s_object(_obj.rule, _obj.__sizerule), context);
	update_member(update, "service", "xsd:string", basic2str(_obj.service), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFirewallRuleset_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.allowedHosts)
			return new HostFirewallRulesetIpList_closure(*_obj.allowedHosts);
		else
			return 0;
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerule)
				return new HostFirewallRule_closure(*_obj.rule[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void HostFirewallRulesetIpList_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFirewallRulesetIpList", context);
	update_member(update, "allIp", "xsd:boolean", basic2str(_obj.allIp), context);
	update_member(update, "ipAddress", "xsd:string[]", a2s_basic(*_obj.ipAddress, _obj.__sizeipAddress), context);
	update_member(update, "ipNetwork", "HostFirewallRulesetIpNetwork[]", a2s_object(_obj.ipNetwork, _obj.__sizeipNetwork), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFirewallRulesetIpList_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeipNetwork)
				return new HostFirewallRulesetIpNetwork_closure(*_obj.ipNetwork[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostFirewallRulesetIpNetwork_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFirewallRulesetIpNetwork", context);
	update_member(update, "network", "xsd:string", basic2str(_obj.network), context);
	update_member(update, "prefixLength", "xsd:int", basic2str(_obj.prefixLength), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFirewallRulesetIpNetwork_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostFirewallRulesetRulesetSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFirewallRulesetRulesetSpec", context);
	update_member(update, "allowedHosts", "HostFirewallRulesetIpList", handle_obj_ptr(_obj.allowedHosts), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFirewallRulesetRulesetSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.allowedHosts)
			return new HostFirewallRulesetIpList_closure(*_obj.allowedHosts);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostFlagInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFlagInfo", context);
	update_member(update, "backgroundSnapshotsEnabled", "xsd:boolean", basic2str(_obj.backgroundSnapshotsEnabled), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFlagInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostForceMountedInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostForceMountedInfo", context);
	update_member(update, "mounted", "xsd:boolean", basic2str(_obj.mounted), context);
	update_member(update, "persist", "xsd:boolean", basic2str(_obj.persist), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostForceMountedInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostGetShortNameFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostGetShortNameFailedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostGetShortNameFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostHardwareElementInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostHardwareElementInfo", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "status", "ElementDescription", handle_obj_ptr(_obj.status), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostHardwareElementInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.status)
			return new ElementDescription_closure(*_obj.status);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostHardwareInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostHardwareInfo", context);
	update_member_with_version(update, "biosInfo", "HostBIOSInfo", handle_obj_ptr(_obj.biosInfo), context, "2.5");
	update_member(update, "cpuFeature", "HostCpuIdInfo[]", a2s_object(_obj.cpuFeature, _obj.__sizecpuFeature), context);
	update_member(update, "cpuInfo", "HostCpuInfo", handle_obj_ptr(_obj.cpuInfo), context);
	update_member(update, "cpuPkg", "HostCpuPackage[]", a2s_object(_obj.cpuPkg, _obj.__sizecpuPkg), context);
	update_member_with_version(update, "cpuPowerManagementInfo", "HostCpuPowerManagementInfo", handle_obj_ptr(_obj.cpuPowerManagementInfo), context, "4.0");
	update_member(update, "memorySize", "xsd:long", basic2str(_obj.memorySize), context);
	update_member(update, "numaInfo", "HostNumaInfo", handle_obj_ptr(_obj.numaInfo), context);
	update_member(update, "pciDevice", "HostPciDevice[]", a2s_object(_obj.pciDevice, _obj.__sizepciDevice), context);
	update_member_with_version(update, "smcPresent", "xsd:boolean", basic2str(_obj.smcPresent), context, "5.0");
	update_member(update, "systemInfo", "HostSystemInfo", handle_obj_ptr(_obj.systemInfo), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostHardwareInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.biosInfo)
			return new HostBIOSInfo_closure(*_obj.biosInfo);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecpuFeature)
				return new HostCpuIdInfo_closure(*_obj.cpuFeature[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.cpuInfo)
			return new HostCpuInfo_closure(*_obj.cpuInfo);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecpuPkg)
				return new HostCpuPackage_closure(*_obj.cpuPkg[i]);
			else
				return 0;
		}
	case 4:
		if (_obj.cpuPowerManagementInfo)
			return new HostCpuPowerManagementInfo_closure(*_obj.cpuPowerManagementInfo);
		else
			return 0;
	case 6:
		if (_obj.numaInfo)
			return new HostNumaInfo_closure(*_obj.numaInfo);
		else
			return 0;
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepciDevice)
				return new HostPciDevice_closure(*_obj.pciDevice[i]);
			else
				return 0;
		}
	case 9:
		if (_obj.systemInfo)
			return new HostSystemInfo_closure(*_obj.systemInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 10) << 16) + arr_index);
	}
	return 0;
}

void HostHardwareStatusInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostHardwareStatusInfo", context);
	update_member(update, "cpuStatusInfo", "HostHardwareElementInfo[]", a2s_object(_obj.cpuStatusInfo, _obj.__sizecpuStatusInfo), context);
	update_member(update, "memoryStatusInfo", "HostHardwareElementInfo[]", a2s_object(_obj.memoryStatusInfo, _obj.__sizememoryStatusInfo), context);
	update_member(update, "storageStatusInfo", "HostStorageElementInfo[]", a2s_object(_obj.storageStatusInfo, _obj.__sizestorageStatusInfo), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostHardwareStatusInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecpuStatusInfo)
				return new HostHardwareElementInfo_closure(*_obj.cpuStatusInfo[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizememoryStatusInfo)
				return new HostHardwareElementInfo_closure(*_obj.memoryStatusInfo[i]);
			else
				return 0;
		}
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizestorageStatusInfo)
				return new HostStorageElementInfo_closure(*_obj.storageStatusInfo[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostHardwareSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostHardwareSummary", context);
	update_member(update, "cpuMhz", "xsd:int", basic2str(_obj.cpuMhz), context);
	update_member(update, "cpuModel", "xsd:string", basic2str(_obj.cpuModel), context);
	update_member(update, "memorySize", "xsd:long", basic2str(_obj.memorySize), context);
	update_member(update, "model", "xsd:string", basic2str(_obj.model), context);
	update_member(update, "numCpuCores", "xsd:short", basic2str(_obj.numCpuCores), context);
	update_member(update, "numCpuPkgs", "xsd:short", basic2str(_obj.numCpuPkgs), context);
	update_member(update, "numCpuThreads", "xsd:short", basic2str(_obj.numCpuThreads), context);
	update_member(update, "numHBAs", "xsd:int", basic2str(_obj.numHBAs), context);
	update_member(update, "numNics", "xsd:int", basic2str(_obj.numNics), context);
	update_member_with_version(update, "otherIdentifyingInfo", "HostSystemIdentificationInfo[]", a2s_object(_obj.otherIdentifyingInfo, _obj.__sizeotherIdentifyingInfo), context, "2.5");
	update_member(update, "uuid", "xsd:string", basic2str(_obj.uuid), context);
	update_member(update, "vendor", "xsd:string", basic2str(_obj.vendor), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostHardwareSummary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 9:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeotherIdentifyingInfo)
				return new HostSystemIdentificationInfo_closure(*_obj.otherIdentifyingInfo[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 12) << 16) + arr_index);
	}
	return 0;
}

void HostHostBusAdapter_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostHostBusAdapter", context);
	update_member(update, "bus", "xsd:int", basic2str(_obj.bus), context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update_member(update, "driver", "xsd:string", basic2str(_obj.driver), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "model", "xsd:string", basic2str(_obj.model), context);
	update_member(update, "pci", "xsd:string", basic2str(_obj.pci), context);
	update_member(update, "status", "xsd:string", basic2str(_obj.status), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostHostBusAdapter_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostHyperThreadScheduleInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostHyperThreadScheduleInfo", context);
	update_member(update, "active", "xsd:boolean", basic2str(_obj.active), context);
	update_member(update, "available", "xsd:boolean", basic2str(_obj.available), context);
	update_member(update, "config", "xsd:boolean", basic2str(_obj.config), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostHyperThreadScheduleInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostImageProfileSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostImageProfileSummary", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "vendor", "xsd:string", basic2str(_obj.vendor), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostImageProfileSummary_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInAuditModeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInAuditModeEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInAuditModeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInternetScsiHba_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInternetScsiHba", context);
	update_member_with_version(update, "advancedOptions", "HostInternetScsiHbaParamValue[]", a2s_object(_obj.advancedOptions, _obj.__sizeadvancedOptions), context, "4.0");
	update_member(update, "authenticationCapabilities", "HostInternetScsiHbaAuthenticationCapabilities", handle_obj_ptr(_obj.authenticationCapabilities), context);
	update_member(update, "authenticationProperties", "HostInternetScsiHbaAuthenticationProperties", handle_obj_ptr(_obj.authenticationProperties), context);
	update_member_with_version(update, "canBeDisabled", "xsd:boolean", basic2str(_obj.canBeDisabled), context, "5.0");
	update_member(update, "configuredSendTarget", "HostInternetScsiHbaSendTarget[]", a2s_object(_obj.configuredSendTarget, _obj.__sizeconfiguredSendTarget), context);
	update_member(update, "configuredStaticTarget", "HostInternetScsiHbaStaticTarget[]", a2s_object(_obj.configuredStaticTarget, _obj.__sizeconfiguredStaticTarget), context);
	update_member(update, "currentSpeedMb", "xsd:int", basic2str(_obj.currentSpeedMb), context);
	update_member_with_version(update, "digestCapabilities", "HostInternetScsiHbaDigestCapabilities", handle_obj_ptr(_obj.digestCapabilities), context, "4.0");
	update_member_with_version(update, "digestProperties", "HostInternetScsiHbaDigestProperties", handle_obj_ptr(_obj.digestProperties), context, "4.0");
	update_member(update, "discoveryCapabilities", "HostInternetScsiHbaDiscoveryCapabilities", handle_obj_ptr(_obj.discoveryCapabilities), context);
	update_member(update, "discoveryProperties", "HostInternetScsiHbaDiscoveryProperties", handle_obj_ptr(_obj.discoveryProperties), context);
	update_member(update, "ipCapabilities", "HostInternetScsiHbaIPCapabilities", handle_obj_ptr(_obj.ipCapabilities), context);
	update_member(update, "ipProperties", "HostInternetScsiHbaIPProperties", handle_obj_ptr(_obj.ipProperties), context);
	update_member(update, "iScsiAlias", "xsd:string", basic2str(_obj.iScsiAlias), context);
	update_member(update, "iScsiName", "xsd:string", basic2str(_obj.iScsiName), context);
	update_member(update, "isSoftwareBased", "xsd:boolean", basic2str(_obj.isSoftwareBased), context);
	update_member(update, "maxSpeedMb", "xsd:int", basic2str(_obj.maxSpeedMb), context);
	update_member_with_version(update, "networkBindingSupport", "HostInternetScsiHbaNetworkBindingSupportType", handle_obj_ptr(_obj.networkBindingSupport), context, "5.0");
	update_member_with_version(update, "supportedAdvancedOptions", "OptionDef[]", a2s_object(_obj.supportedAdvancedOptions, _obj.__sizesupportedAdvancedOptions), context, "4.0");
	update("Base", "HostHostBusAdapter", context);
	HostHostBusAdapter_closure(dynamic_cast<const vw1__HostHostBusAdapter&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInternetScsiHba_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeadvancedOptions)
				return new HostInternetScsiHbaParamValue_closure(*_obj.advancedOptions[i]);
			else
				return 0;
		}
	case 1:
		if (_obj.authenticationCapabilities)
			return new HostInternetScsiHbaAuthenticationCapabilities_closure(*_obj.authenticationCapabilities);
		else
			return 0;
	case 2:
		if (_obj.authenticationProperties)
			return new HostInternetScsiHbaAuthenticationProperties_closure(*_obj.authenticationProperties);
		else
			return 0;
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeconfiguredSendTarget)
				return new HostInternetScsiHbaSendTarget_closure(*_obj.configuredSendTarget[i]);
			else
				return 0;
		}
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeconfiguredStaticTarget)
				return new HostInternetScsiHbaStaticTarget_closure(*_obj.configuredStaticTarget[i]);
			else
				return 0;
		}
	case 7:
		if (_obj.digestCapabilities)
			return new HostInternetScsiHbaDigestCapabilities_closure(*_obj.digestCapabilities);
		else
			return 0;
	case 8:
		if (_obj.digestProperties)
			return new HostInternetScsiHbaDigestProperties_closure(*_obj.digestProperties);
		else
			return 0;
	case 9:
		if (_obj.discoveryCapabilities)
			return new HostInternetScsiHbaDiscoveryCapabilities_closure(*_obj.discoveryCapabilities);
		else
			return 0;
	case 10:
		if (_obj.discoveryProperties)
			return new HostInternetScsiHbaDiscoveryProperties_closure(*_obj.discoveryProperties);
		else
			return 0;
	case 11:
		if (_obj.ipCapabilities)
			return new HostInternetScsiHbaIPCapabilities_closure(*_obj.ipCapabilities);
		else
			return 0;
	case 12:
		if (_obj.ipProperties)
			return new HostInternetScsiHbaIPProperties_closure(*_obj.ipProperties);
		else
			return 0;
	case 18:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesupportedAdvancedOptions)
				return new OptionDef_closure(*_obj.supportedAdvancedOptions[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return HostHostBusAdapter_closure(_obj).get_sub_closure(((prop_index - 19) << 16) + arr_index);
	}
	return 0;
}

void HostInternetScsiHbaAuthenticationCapabilities_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInternetScsiHbaAuthenticationCapabilities", context);
	update_member(update, "chapAuthSettable", "xsd:boolean", basic2str(_obj.chapAuthSettable), context);
	update_member(update, "krb5AuthSettable", "xsd:boolean", basic2str(_obj.krb5AuthSettable), context);
	update_member_with_version(update, "mutualChapSettable", "xsd:boolean", basic2str(_obj.mutualChapSettable), context, "4.0");
	update_member(update, "spkmAuthSettable", "xsd:boolean", basic2str(_obj.spkmAuthSettable), context);
	update_member(update, "srpAuthSettable", "xsd:boolean", basic2str(_obj.srpAuthSettable), context);
	update_member_with_version(update, "targetChapSettable", "xsd:boolean", basic2str(_obj.targetChapSettable), context, "4.0");
	update_member_with_version(update, "targetMutualChapSettable", "xsd:boolean", basic2str(_obj.targetMutualChapSettable), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInternetScsiHbaAuthenticationCapabilities_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInternetScsiHbaAuthenticationProperties_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInternetScsiHbaAuthenticationProperties", context);
	update_member(update, "chapAuthEnabled", "xsd:boolean", basic2str(_obj.chapAuthEnabled), context);
	update_member_with_version(update, "chapAuthenticationType", "xsd:string", basic2str(_obj.chapAuthenticationType), context, "4.0");
	update_member_with_version(update, "chapInherited", "xsd:boolean", basic2str(_obj.chapInherited), context, "4.0");
	update_member(update, "chapName", "xsd:string", basic2str(_obj.chapName), context);
	update_member(update, "chapSecret", "xsd:string", basic2str(_obj.chapSecret), context);
	update_member_with_version(update, "mutualChapAuthenticationType", "xsd:string", basic2str(_obj.mutualChapAuthenticationType), context, "4.0");
	update_member_with_version(update, "mutualChapInherited", "xsd:boolean", basic2str(_obj.mutualChapInherited), context, "4.0");
	update_member_with_version(update, "mutualChapName", "xsd:string", basic2str(_obj.mutualChapName), context, "4.0");
	update_member_with_version(update, "mutualChapSecret", "xsd:string", basic2str(_obj.mutualChapSecret), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInternetScsiHbaAuthenticationProperties_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInternetScsiHbaDigestCapabilities_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInternetScsiHbaDigestCapabilities", context);
	update_member(update, "dataDigestSettable", "xsd:boolean", basic2str(_obj.dataDigestSettable), context);
	update_member(update, "headerDigestSettable", "xsd:boolean", basic2str(_obj.headerDigestSettable), context);
	update_member(update, "targetDataDigestSettable", "xsd:boolean", basic2str(_obj.targetDataDigestSettable), context);
	update_member(update, "targetHeaderDigestSettable", "xsd:boolean", basic2str(_obj.targetHeaderDigestSettable), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInternetScsiHbaDigestCapabilities_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInternetScsiHbaDigestProperties_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInternetScsiHbaDigestProperties", context);
	update_member(update, "dataDigestInherited", "xsd:boolean", basic2str(_obj.dataDigestInherited), context);
	update_member(update, "dataDigestType", "xsd:string", basic2str(_obj.dataDigestType), context);
	update_member(update, "headerDigestInherited", "xsd:boolean", basic2str(_obj.headerDigestInherited), context);
	update_member(update, "headerDigestType", "xsd:string", basic2str(_obj.headerDigestType), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInternetScsiHbaDigestProperties_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInternetScsiHbaDiscoveryCapabilities_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInternetScsiHbaDiscoveryCapabilities", context);
	update_member(update, "iSnsDiscoverySettable", "xsd:boolean", basic2str(_obj.iSnsDiscoverySettable), context);
	update_member(update, "sendTargetsDiscoverySettable", "xsd:boolean", basic2str(_obj.sendTargetsDiscoverySettable), context);
	update_member(update, "slpDiscoverySettable", "xsd:boolean", basic2str(_obj.slpDiscoverySettable), context);
	update_member(update, "staticTargetDiscoverySettable", "xsd:boolean", basic2str(_obj.staticTargetDiscoverySettable), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInternetScsiHbaDiscoveryCapabilities_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInternetScsiHbaDiscoveryProperties_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInternetScsiHbaDiscoveryProperties", context);
	update_member(update, "iSnsDiscoveryEnabled", "xsd:boolean", basic2str(_obj.iSnsDiscoveryEnabled), context);
	update_member(update, "iSnsDiscoveryMethod", "xsd:string", basic2str(_obj.iSnsDiscoveryMethod), context);
	update_member(update, "iSnsHost", "xsd:string", basic2str(_obj.iSnsHost), context);
	update_member(update, "sendTargetsDiscoveryEnabled", "xsd:boolean", basic2str(_obj.sendTargetsDiscoveryEnabled), context);
	update_member(update, "slpDiscoveryEnabled", "xsd:boolean", basic2str(_obj.slpDiscoveryEnabled), context);
	update_member(update, "slpDiscoveryMethod", "xsd:string", basic2str(_obj.slpDiscoveryMethod), context);
	update_member(update, "slpHost", "xsd:string", basic2str(_obj.slpHost), context);
	update_member(update, "staticTargetDiscoveryEnabled", "xsd:boolean", basic2str(_obj.staticTargetDiscoveryEnabled), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInternetScsiHbaDiscoveryProperties_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInternetScsiHbaIPCapabilities_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInternetScsiHbaIPCapabilities", context);
	update_member(update, "addressSettable", "xsd:boolean", basic2str(_obj.addressSettable), context);
	update_member(update, "alternateDnsServerAddressSettable", "xsd:boolean", basic2str(_obj.alternateDnsServerAddressSettable), context);
	update_member_with_version(update, "arpRedirectSettable", "xsd:boolean", basic2str(_obj.arpRedirectSettable), context, "4.0");
	update_member(update, "defaultGatewaySettable", "xsd:boolean", basic2str(_obj.defaultGatewaySettable), context);
	update_member_with_version(update, "hostNameAsTargetAddress", "xsd:boolean", basic2str(_obj.hostNameAsTargetAddress), context, "4.0");
	update_member(update, "ipConfigurationMethodSettable", "xsd:boolean", basic2str(_obj.ipConfigurationMethodSettable), context);
	update_member_with_version(update, "ipv6Supported", "xsd:boolean", basic2str(_obj.ipv6Supported), context, "4.0");
	update_member_with_version(update, "mtuSettable", "xsd:boolean", basic2str(_obj.mtuSettable), context, "4.0");
	update_member_with_version(update, "nameAliasSettable", "xsd:boolean", basic2str(_obj.nameAliasSettable), context, "4.1");
	update_member(update, "primaryDnsServerAddressSettable", "xsd:boolean", basic2str(_obj.primaryDnsServerAddressSettable), context);
	update_member(update, "subnetMaskSettable", "xsd:boolean", basic2str(_obj.subnetMaskSettable), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInternetScsiHbaIPCapabilities_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInternetScsiHbaIPProperties_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInternetScsiHbaIPProperties", context);
	update_member(update, "address", "xsd:string", basic2str(_obj.address), context);
	update_member(update, "alternateDnsServerAddress", "xsd:string", basic2str(_obj.alternateDnsServerAddress), context);
	update_member_with_version(update, "arpRedirectEnabled", "xsd:boolean", basic2str(_obj.arpRedirectEnabled), context, "4.0");
	update_member(update, "defaultGateway", "xsd:string", basic2str(_obj.defaultGateway), context);
	update_member(update, "dhcpConfigurationEnabled", "xsd:boolean", basic2str(_obj.dhcpConfigurationEnabled), context);
	update_member_with_version(update, "ipv6Address", "xsd:string", basic2str(_obj.ipv6Address), context, "4.0");
	update_member_with_version(update, "ipv6DefaultGateway", "xsd:string", basic2str(_obj.ipv6DefaultGateway), context, "4.0");
	update_member_with_version(update, "ipv6SubnetMask", "xsd:string", basic2str(_obj.ipv6SubnetMask), context, "4.0");
	update_member_with_version(update, "jumboFramesEnabled", "xsd:boolean", basic2str(_obj.jumboFramesEnabled), context, "4.0");
	update_member(update, "mac", "xsd:string", basic2str(_obj.mac), context);
	update_member_with_version(update, "mtu", "xsd:int", basic2str(_obj.mtu), context, "4.0");
	update_member(update, "primaryDnsServerAddress", "xsd:string", basic2str(_obj.primaryDnsServerAddress), context);
	update_member(update, "subnetMask", "xsd:string", basic2str(_obj.subnetMask), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInternetScsiHbaIPProperties_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInternetScsiHbaParamValue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInternetScsiHbaParamValue", context);
	update_member(update, "isInherited", "xsd:boolean", basic2str(_obj.isInherited), context);
	update("Base", "OptionValue", context);
	OptionValue_closure(dynamic_cast<const vw1__OptionValue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInternetScsiHbaParamValue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInternetScsiHbaSendTarget_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInternetScsiHbaSendTarget", context);
	update_member(update, "address", "xsd:string", basic2str(_obj.address), context);
	update_member_with_version(update, "advancedOptions", "HostInternetScsiHbaParamValue[]", a2s_object(_obj.advancedOptions, _obj.__sizeadvancedOptions), context, "4.0");
	update_member_with_version(update, "authenticationProperties", "HostInternetScsiHbaAuthenticationProperties", handle_obj_ptr(_obj.authenticationProperties), context, "4.0");
	update_member_with_version(update, "digestProperties", "HostInternetScsiHbaDigestProperties", handle_obj_ptr(_obj.digestProperties), context, "4.0");
	update_member_with_version(update, "parent", "xsd:string", basic2str(_obj.parent), context, "4.0");
	update_member(update, "port", "xsd:int", basic2str(_obj.port), context);
	update_member_with_version(update, "supportedAdvancedOptions", "OptionDef[]", a2s_object(_obj.supportedAdvancedOptions, _obj.__sizesupportedAdvancedOptions), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInternetScsiHbaSendTarget_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeadvancedOptions)
				return new HostInternetScsiHbaParamValue_closure(*_obj.advancedOptions[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.authenticationProperties)
			return new HostInternetScsiHbaAuthenticationProperties_closure(*_obj.authenticationProperties);
		else
			return 0;
	case 3:
		if (_obj.digestProperties)
			return new HostInternetScsiHbaDigestProperties_closure(*_obj.digestProperties);
		else
			return 0;
	case 6:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesupportedAdvancedOptions)
				return new OptionDef_closure(*_obj.supportedAdvancedOptions[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void HostInternetScsiHbaStaticTarget_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInternetScsiHbaStaticTarget", context);
	update_member(update, "address", "xsd:string", basic2str(_obj.address), context);
	update_member_with_version(update, "advancedOptions", "HostInternetScsiHbaParamValue[]", a2s_object(_obj.advancedOptions, _obj.__sizeadvancedOptions), context, "4.0");
	update_member_with_version(update, "authenticationProperties", "HostInternetScsiHbaAuthenticationProperties", handle_obj_ptr(_obj.authenticationProperties), context, "4.0");
	update_member_with_version(update, "digestProperties", "HostInternetScsiHbaDigestProperties", handle_obj_ptr(_obj.digestProperties), context, "4.0");
	update_member(update, "iScsiName", "xsd:string", basic2str(_obj.iScsiName), context);
	update_member_with_version(update, "parent", "xsd:string", basic2str(_obj.parent), context, "4.0");
	update_member(update, "port", "xsd:int", basic2str(_obj.port), context);
	update_member_with_version(update, "supportedAdvancedOptions", "OptionDef[]", a2s_object(_obj.supportedAdvancedOptions, _obj.__sizesupportedAdvancedOptions), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInternetScsiHbaStaticTarget_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeadvancedOptions)
				return new HostInternetScsiHbaParamValue_closure(*_obj.advancedOptions[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.authenticationProperties)
			return new HostInternetScsiHbaAuthenticationProperties_closure(*_obj.authenticationProperties);
		else
			return 0;
	case 3:
		if (_obj.digestProperties)
			return new HostInternetScsiHbaDigestProperties_closure(*_obj.digestProperties);
		else
			return 0;
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesupportedAdvancedOptions)
				return new OptionDef_closure(*_obj.supportedAdvancedOptions[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void HostInternetScsiHbaTargetSet_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInternetScsiHbaTargetSet", context);
	update_member(update, "sendTargets", "HostInternetScsiHbaSendTarget[]", a2s_object(_obj.sendTargets, _obj.__sizesendTargets), context);
	update_member(update, "staticTargets", "HostInternetScsiHbaStaticTarget[]", a2s_object(_obj.staticTargets, _obj.__sizestaticTargets), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInternetScsiHbaTargetSet_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesendTargets)
				return new HostInternetScsiHbaSendTarget_closure(*_obj.sendTargets[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizestaticTargets)
				return new HostInternetScsiHbaStaticTarget_closure(*_obj.staticTargets[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostInternetScsiTargetTransport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInternetScsiTargetTransport", context);
	update_member(update, "address", "xsd:string[]", a2s_basic(*_obj.address, _obj.__sizeaddress), context);
	update_member(update, "iScsiAlias", "xsd:string", basic2str(_obj.iScsiAlias), context);
	update_member(update, "iScsiName", "xsd:string", basic2str(_obj.iScsiName), context);
	update("Base", "HostTargetTransport", context);
	HostTargetTransport_closure(dynamic_cast<const vw1__HostTargetTransport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInternetScsiTargetTransport_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInventoryFullEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInventoryFullEvent", context);
	update_member(update, "capacity", "xsd:int", basic2str(_obj.capacity), context);
	update("Base", "LicenseEvent", context);
	LicenseEvent_closure(dynamic_cast<const vw1__LicenseEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInventoryFullEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInventoryUnreadableEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInventoryUnreadableEvent", context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInventoryUnreadableEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostIpChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIpChangedEvent", context);
	update_member(update, "newIP", "xsd:string", basic2str(_obj.newIP), context);
	update_member(update, "oldIP", "xsd:string", basic2str(_obj.oldIP), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIpChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostIpConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIpConfig", context);
	update_member(update, "dhcp", "xsd:boolean", basic2str(_obj.dhcp), context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update_member_with_version(update, "ipV6Config", "HostIpConfigIpV6AddressConfiguration", handle_obj_ptr(_obj.ipV6Config), context, "4.0");
	update_member(update, "subnetMask", "xsd:string", basic2str(_obj.subnetMask), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIpConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.ipV6Config)
			return new HostIpConfigIpV6AddressConfiguration_closure(*_obj.ipV6Config);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostIpConfigIpV6Address_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIpConfigIpV6Address", context);
	update_member(update, "dadState", "xsd:string", basic2str(_obj.dadState), context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update_member(update, "lifetime", "xsd:dateTime", basic2str(_obj.lifetime), context);
	update_member(update, "operation", "xsd:string", basic2str(_obj.operation), context);
	update_member(update, "origin", "xsd:string", basic2str(_obj.origin), context);
	update_member(update, "prefixLength", "xsd:int", basic2str(_obj.prefixLength), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIpConfigIpV6Address_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostIpConfigIpV6AddressConfiguration_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIpConfigIpV6AddressConfiguration", context);
	update_member(update, "autoConfigurationEnabled", "xsd:boolean", basic2str(_obj.autoConfigurationEnabled), context);
	update_member(update, "dhcpV6Enabled", "xsd:boolean", basic2str(_obj.dhcpV6Enabled), context);
	update_member(update, "ipV6Address", "HostIpConfigIpV6Address[]", a2s_object(_obj.ipV6Address, _obj.__sizeipV6Address), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIpConfigIpV6AddressConfiguration_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeipV6Address)
				return new HostIpConfigIpV6Address_closure(*_obj.ipV6Address[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostIpInconsistentEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIpInconsistentEvent", context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update_member(update, "ipAddress2", "xsd:string", basic2str(_obj.ipAddress2), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIpInconsistentEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostIpRouteConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIpRouteConfig", context);
	update_member(update, "defaultGateway", "xsd:string", basic2str(_obj.defaultGateway), context);
	update_member(update, "gatewayDevice", "xsd:string", basic2str(_obj.gatewayDevice), context);
	update_member_with_version(update, "ipV6DefaultGateway", "xsd:string", basic2str(_obj.ipV6DefaultGateway), context, "4.0");
	update_member_with_version(update, "ipV6GatewayDevice", "xsd:string", basic2str(_obj.ipV6GatewayDevice), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIpRouteConfig_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostIpRouteConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIpRouteConfigSpec", context);
	update_member(update, "gatewayDeviceConnection", "HostVirtualNicConnection", handle_obj_ptr(_obj.gatewayDeviceConnection), context);
	update_member(update, "ipV6GatewayDeviceConnection", "HostVirtualNicConnection", handle_obj_ptr(_obj.ipV6GatewayDeviceConnection), context);
	update("Base", "HostIpRouteConfig", context);
	HostIpRouteConfig_closure(dynamic_cast<const vw1__HostIpRouteConfig&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIpRouteConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.gatewayDeviceConnection)
			return new HostVirtualNicConnection_closure(*_obj.gatewayDeviceConnection);
		else
			return 0;
	case 1:
		if (_obj.ipV6GatewayDeviceConnection)
			return new HostVirtualNicConnection_closure(*_obj.ipV6GatewayDeviceConnection);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostIpRouteConfig_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostIpRouteEntry_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIpRouteEntry", context);
	update_member_with_version(update, "deviceName", "xsd:string", basic2str(_obj.deviceName), context, "4.1");
	update_member(update, "gateway", "xsd:string", basic2str(_obj.gateway), context);
	update_member(update, "network", "xsd:string", basic2str(_obj.network), context);
	update_member(update, "prefixLength", "xsd:int", basic2str(_obj.prefixLength), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIpRouteEntry_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostIpRouteOp_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIpRouteOp", context);
	update_member(update, "changeOperation", "xsd:string", basic2str(_obj.changeOperation), context);
	update_member(update, "route", "HostIpRouteEntry", handle_obj_ptr(_obj.route), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIpRouteOp_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.route)
			return new HostIpRouteEntry_closure(*_obj.route);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostIpRouteTableConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIpRouteTableConfig", context);
	update_member(update, "ipRoute", "HostIpRouteOp[]", a2s_object(_obj.ipRoute, _obj.__sizeipRoute), context);
	update_member(update, "ipv6Route", "HostIpRouteOp[]", a2s_object(_obj.ipv6Route, _obj.__sizeipv6Route), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIpRouteTableConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeipRoute)
				return new HostIpRouteOp_closure(*_obj.ipRoute[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeipv6Route)
				return new HostIpRouteOp_closure(*_obj.ipv6Route[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostIpRouteTableInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIpRouteTableInfo", context);
	update_member(update, "ipRoute", "HostIpRouteEntry[]", a2s_object(_obj.ipRoute, _obj.__sizeipRoute), context);
	update_member(update, "ipv6Route", "HostIpRouteEntry[]", a2s_object(_obj.ipv6Route, _obj.__sizeipv6Route), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIpRouteTableInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeipRoute)
				return new HostIpRouteEntry_closure(*_obj.ipRoute[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeipv6Route)
				return new HostIpRouteEntry_closure(*_obj.ipv6Route[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostIpToShortNameFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIpToShortNameFailedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIpToShortNameFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostIpmiInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIpmiInfo", context);
	update_member(update, "bmcIpAddress", "xsd:string", basic2str(_obj.bmcIpAddress), context);
	update_member(update, "bmcMacAddress", "xsd:string", basic2str(_obj.bmcMacAddress), context);
	update_member(update, "login", "xsd:string", basic2str(_obj.login), context);
	update_member(update, "password", "xsd:string", basic2str(_obj.password), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIpmiInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostIsolationIpPingFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIsolationIpPingFailedEvent", context);
	update_member(update, "isolationIp", "xsd:string", basic2str(_obj.isolationIp), context);
	update("Base", "HostDasEvent", context);
	HostDasEvent_closure(dynamic_cast<const vw1__HostDasEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIsolationIpPingFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostLicensableResourceInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostLicensableResourceInfo", context);
	update_member(update, "resource", "KeyAnyValue[]", a2s_object(_obj.resource, _obj.__sizeresource), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostLicensableResourceInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeresource)
				return new KeyAnyValue_closure(*_obj.resource[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostLicenseConnectInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostLicenseConnectInfo", context);
	update_member(update, "evaluation", "LicenseManagerEvaluationInfo", handle_obj_ptr(_obj.evaluation), context);
	update_member(update, "license", "LicenseManagerLicenseInfo", handle_obj_ptr(_obj.license), context);
	update_member_with_version(update, "resource", "HostLicensableResourceInfo", handle_obj_ptr(_obj.resource), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostLicenseConnectInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.evaluation)
			return new LicenseManagerEvaluationInfo_closure(*_obj.evaluation);
		else
			return 0;
	case 1:
		if (_obj.license)
			return new LicenseManagerLicenseInfo_closure(*_obj.license);
		else
			return 0;
	case 2:
		if (_obj.resource)
			return new HostLicensableResourceInfo_closure(*_obj.resource);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostLicenseExpiredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostLicenseExpiredEvent", context);
	update("Base", "LicenseEvent", context);
	LicenseEvent_closure(dynamic_cast<const vw1__LicenseEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostLicenseExpiredEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostLicenseSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostLicenseSpec", context);
	update_member(update, "disabledFeatureKey", "xsd:string[]", a2s_basic(*_obj.disabledFeatureKey, _obj.__sizedisabledFeatureKey), context);
	update_member(update, "editionKey", "xsd:string", basic2str(_obj.editionKey), context);
	update_member(update, "enabledFeatureKey", "xsd:string[]", a2s_basic(*_obj.enabledFeatureKey, _obj.__sizeenabledFeatureKey), context);
	update_member(update, "source", "LicenseSource", handle_obj_ptr(_obj.source), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostLicenseSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		if (_obj.source)
			return new LicenseSource_closure(*_obj.source);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostListSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostListSummary", context);
	update_member(update, "config", "HostConfigSummary", handle_obj_ptr(_obj.config), context);
	update_member_with_version(update, "currentEVCModeKey", "xsd:string", basic2str(_obj.currentEVCModeKey), context, "4.0");
	update_member(update, "customValue", "CustomFieldValue[]", a2s_object(_obj.customValue, _obj.__sizecustomValue), context);
	update_member(update, "hardware", "HostHardwareSummary", handle_obj_ptr(_obj.hardware), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member_with_version(update, "managementServerIp", "xsd:string", basic2str(_obj.managementServerIp), context, "2.5");
	update_member_with_version(update, "maxEVCModeKey", "xsd:string", basic2str(_obj.maxEVCModeKey), context, "4.0");
	update_member(update, "overallStatus", "ManagedEntityStatus", handle_obj(_obj.overallStatus), context);
	update_member(update, "quickStats", "HostListSummaryQuickStats", handle_obj_ptr(_obj.quickStats), context);
	update_member(update, "rebootRequired", "xsd:boolean", basic2str(_obj.rebootRequired), context);
	update_member(update, "runtime", "HostRuntimeInfo", handle_obj_ptr(_obj.runtime), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostListSummary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.config)
			return new HostConfigSummary_closure(*_obj.config);
		else
			return 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecustomValue)
				return new CustomFieldValue_closure(*_obj.customValue[i]);
			else
				return 0;
		}
	case 3:
		if (_obj.hardware)
			return new HostHardwareSummary_closure(*_obj.hardware);
		else
			return 0;
	case 4:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	case 8:
		if (_obj.quickStats)
			return new HostListSummaryQuickStats_closure(*_obj.quickStats);
		else
			return 0;
	case 10:
		if (_obj.runtime)
			return new HostRuntimeInfo_closure(*_obj.runtime);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void HostListSummaryQuickStats_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostListSummaryQuickStats", context);
	update_member(update, "distributedCpuFairness", "xsd:int", basic2str(_obj.distributedCpuFairness), context);
	update_member(update, "distributedMemoryFairness", "xsd:int", basic2str(_obj.distributedMemoryFairness), context);
	update_member(update, "overallCpuUsage", "xsd:int", basic2str(_obj.overallCpuUsage), context);
	update_member(update, "overallMemoryUsage", "xsd:int", basic2str(_obj.overallMemoryUsage), context);
	update_member_with_version(update, "uptime", "xsd:int", basic2str(_obj.uptime), context, "4.1");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostListSummaryQuickStats_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostLocalAuthenticationInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostLocalAuthenticationInfo", context);
	update("Base", "HostAuthenticationStoreInfo", context);
	HostAuthenticationStoreInfo_closure(dynamic_cast<const vw1__HostAuthenticationStoreInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostLocalAuthenticationInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostLocalFileSystemVolume_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostLocalFileSystemVolume", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update("Base", "HostFileSystemVolume", context);
	HostFileSystemVolume_closure(dynamic_cast<const vw1__HostFileSystemVolume&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostLocalFileSystemVolume_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostLocalFileSystemVolumeSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostLocalFileSystemVolumeSpec", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update_member(update, "localPath", "xsd:string", basic2str(_obj.localPath), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostLocalFileSystemVolumeSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostLowLevelProvisioningManagerDiskLayoutSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostLowLevelProvisioningManagerDiskLayoutSpec", context);
	update_member(update, "busNumber", "xsd:int", basic2str(_obj.busNumber), context);
	update_member(update, "controllerType", "xsd:string", basic2str(_obj.controllerType), context);
	update_member(update, "dstFilename", "xsd:string", basic2str(_obj.dstFilename), context);
	update_member(update, "srcFilename", "xsd:string", basic2str(_obj.srcFilename), context);
	update_member(update, "unitNumber", "xsd:int", basic2str(_obj.unitNumber), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostLowLevelProvisioningManagerDiskLayoutSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostLowLevelProvisioningManagerSnapshotLayoutSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostLowLevelProvisioningManagerSnapshotLayoutSpec", context);
	update_member(update, "disk", "HostLowLevelProvisioningManagerDiskLayoutSpec[]", a2s_object(_obj.disk, _obj.__sizedisk), context);
	update_member(update, "dstFilename", "xsd:string", basic2str(_obj.dstFilename), context);
	update_member(update, "id", "xsd:int", basic2str(_obj.id), context);
	update_member(update, "srcFilename", "xsd:string", basic2str(_obj.srcFilename), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostLowLevelProvisioningManagerSnapshotLayoutSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedisk)
				return new HostLowLevelProvisioningManagerDiskLayoutSpec_closure(*_obj.disk[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostMemoryProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostMemoryProfile", context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostMemoryProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostMemorySpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostMemorySpec", context);
	update_member(update, "serviceConsoleReservation", "xsd:long", basic2str(_obj.serviceConsoleReservation), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostMemorySpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostMissingNetworksEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostMissingNetworksEvent", context);
	update_member(update, "ips", "xsd:string", basic2str(_obj.ips), context);
	update("Base", "HostDasEvent", context);
	HostDasEvent_closure(dynamic_cast<const vw1__HostDasEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostMissingNetworksEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostMonitoringStateChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostMonitoringStateChangedEvent", context);
	update_member(update, "state", "xsd:string", basic2str(_obj.state), context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostMonitoringStateChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostMountInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostMountInfo", context);
	update_member_with_version(update, "accessible", "xsd:boolean", basic2str(_obj.accessible), context, "2.5");
	update_member(update, "accessMode", "xsd:string", basic2str(_obj.accessMode), context);
	update_member_with_version(update, "mounted", "xsd:boolean", basic2str(_obj.mounted), context, "5.0");
	update_member(update, "path", "xsd:string", basic2str(_obj.path), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostMountInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostMultipathInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostMultipathInfo", context);
	update_member(update, "lun", "HostMultipathInfoLogicalUnit[]", a2s_object(_obj.lun, _obj.__sizelun), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostMultipathInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizelun)
				return new HostMultipathInfoLogicalUnit_closure(*_obj.lun[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostMultipathInfoFixedLogicalUnitPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostMultipathInfoFixedLogicalUnitPolicy", context);
	update_member(update, "prefer", "xsd:string", basic2str(_obj.prefer), context);
	update("Base", "HostMultipathInfoLogicalUnitPolicy", context);
	HostMultipathInfoLogicalUnitPolicy_closure(dynamic_cast<const vw1__HostMultipathInfoLogicalUnitPolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostMultipathInfoFixedLogicalUnitPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostMultipathInfoLogicalUnit_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostMultipathInfoLogicalUnit", context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "lun", "xsd:string", basic2str(_obj.lun), context);
	update_member(update, "path", "HostMultipathInfoPath[]", a2s_object(_obj.path, _obj.__sizepath), context);
	update_member(update, "policy", "HostMultipathInfoLogicalUnitPolicy", handle_obj_ptr(_obj.policy), context);
	update_member_with_version(update, "storageArrayTypePolicy", "HostMultipathInfoLogicalUnitStorageArrayTypePolicy", handle_obj_ptr(_obj.storageArrayTypePolicy), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostMultipathInfoLogicalUnit_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepath)
				return new HostMultipathInfoPath_closure(*_obj.path[i]);
			else
				return 0;
		}
	case 4:
		if (_obj.policy)
			return new HostMultipathInfoLogicalUnitPolicy_closure(*_obj.policy);
		else
			return 0;
	case 5:
		if (_obj.storageArrayTypePolicy)
			return new HostMultipathInfoLogicalUnitStorageArrayTypePolicy_closure(*_obj.storageArrayTypePolicy);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void HostMultipathInfoLogicalUnitPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostMultipathInfoLogicalUnitPolicy", context);
	update_member(update, "policy", "xsd:string", basic2str(_obj.policy), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostMultipathInfoLogicalUnitPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostMultipathInfoLogicalUnitStorageArrayTypePolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostMultipathInfoLogicalUnitStorageArrayTypePolicy", context);
	update_member(update, "policy", "xsd:string", basic2str(_obj.policy), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostMultipathInfoLogicalUnitStorageArrayTypePolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostMultipathInfoPath_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostMultipathInfoPath", context);
	update_member(update, "adapter", "xsd:string", basic2str(_obj.adapter), context);
	update_member_with_version(update, "isWorkingPath", "xsd:boolean", basic2str(_obj.isWorkingPath), context, "4.0");
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "lun", "xsd:string", basic2str(_obj.lun), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "pathState", "xsd:string", basic2str(_obj.pathState), context);
	update_member_with_version(update, "state", "xsd:string", basic2str(_obj.state), context, "4.0");
	update_member(update, "transport", "HostTargetTransport", handle_obj_ptr(_obj.transport), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostMultipathInfoPath_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 7:
		if (_obj.transport)
			return new HostTargetTransport_closure(*_obj.transport);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void HostMultipathStateInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostMultipathStateInfo", context);
	update_member(update, "path", "HostMultipathStateInfoPath[]", a2s_object(_obj.path, _obj.__sizepath), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostMultipathStateInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepath)
				return new HostMultipathStateInfoPath_closure(*_obj.path[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostMultipathStateInfoPath_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostMultipathStateInfoPath", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "pathState", "xsd:string", basic2str(_obj.pathState), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostMultipathStateInfoPath_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNasVolume_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNasVolume", context);
	update_member(update, "remoteHost", "xsd:string", basic2str(_obj.remoteHost), context);
	update_member(update, "remotePath", "xsd:string", basic2str(_obj.remotePath), context);
	update_member_with_version(update, "userName", "xsd:string", basic2str(_obj.userName), context, "2.5");
	update("Base", "HostFileSystemVolume", context);
	HostFileSystemVolume_closure(dynamic_cast<const vw1__HostFileSystemVolume&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNasVolume_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNasVolumeConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNasVolumeConfig", context);
	update_member(update, "changeOperation", "xsd:string", basic2str(_obj.changeOperation), context);
	update_member(update, "spec", "HostNasVolumeSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNasVolumeConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.spec)
			return new HostNasVolumeSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostNasVolumeSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNasVolumeSpec", context);
	update_member(update, "accessMode", "xsd:string", basic2str(_obj.accessMode), context);
	update_member(update, "localPath", "xsd:string", basic2str(_obj.localPath), context);
	update_member_with_version(update, "password", "xsd:string", basic2str(_obj.password), context, "2.5");
	update_member(update, "remoteHost", "xsd:string", basic2str(_obj.remoteHost), context);
	update_member(update, "remotePath", "xsd:string", basic2str(_obj.remotePath), context);
	update_member_with_version(update, "type", "xsd:string", basic2str(_obj.type), context, "2.5");
	update_member_with_version(update, "userName", "xsd:string", basic2str(_obj.userName), context, "2.5");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNasVolumeSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNatService_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNatService", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "spec", "HostNatServiceSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNatService_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.spec)
			return new HostNatServiceSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostNatServiceConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNatServiceConfig", context);
	update_member(update, "changeOperation", "xsd:string", basic2str(_obj.changeOperation), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "spec", "HostNatServiceSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNatServiceConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.spec)
			return new HostNatServiceSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostNatServiceNameServiceSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNatServiceNameServiceSpec", context);
	update_member(update, "dnsAutoDetect", "xsd:boolean", basic2str(_obj.dnsAutoDetect), context);
	update_member(update, "dnsNameServer", "xsd:string[]", a2s_basic(*_obj.dnsNameServer, _obj.__sizednsNameServer), context);
	update_member(update, "dnsPolicy", "xsd:string", basic2str(_obj.dnsPolicy), context);
	update_member(update, "dnsRetries", "xsd:int", basic2str(_obj.dnsRetries), context);
	update_member(update, "dnsTimeout", "xsd:int", basic2str(_obj.dnsTimeout), context);
	update_member(update, "nbdsTimeout", "xsd:int", basic2str(_obj.nbdsTimeout), context);
	update_member(update, "nbnsRetries", "xsd:int", basic2str(_obj.nbnsRetries), context);
	update_member(update, "nbnsTimeout", "xsd:int", basic2str(_obj.nbnsTimeout), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNatServiceNameServiceSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNatServicePortForwardSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNatServicePortForwardSpec", context);
	update_member(update, "guestIpAddress", "xsd:string", basic2str(_obj.guestIpAddress), context);
	update_member(update, "guestPort", "xsd:int", basic2str(_obj.guestPort), context);
	update_member(update, "hostPort", "xsd:int", basic2str(_obj.hostPort), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNatServicePortForwardSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNatServiceSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNatServiceSpec", context);
	update_member(update, "activeFtp", "xsd:boolean", basic2str(_obj.activeFtp), context);
	update_member(update, "allowAnyOui", "xsd:boolean", basic2str(_obj.allowAnyOui), context);
	update_member(update, "configPort", "xsd:boolean", basic2str(_obj.configPort), context);
	update_member(update, "ipGatewayAddress", "xsd:string", basic2str(_obj.ipGatewayAddress), context);
	update_member(update, "nameService", "HostNatServiceNameServiceSpec", handle_obj_ptr(_obj.nameService), context);
	update_member(update, "portForward", "HostNatServicePortForwardSpec[]", a2s_object(_obj.portForward, _obj.__sizeportForward), context);
	update_member(update, "udpTimeout", "xsd:int", basic2str(_obj.udpTimeout), context);
	update_member(update, "virtualSwitch", "xsd:string", basic2str(_obj.virtualSwitch), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNatServiceSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 4:
		if (_obj.nameService)
			return new HostNatServiceNameServiceSpec_closure(*_obj.nameService);
		else
			return 0;
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeportForward)
				return new HostNatServicePortForwardSpec_closure(*_obj.portForward[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void HostNetCapabilities_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNetCapabilities", context);
	update_member(update, "canSetPhysicalNicLinkSpeed", "xsd:boolean", basic2str(_obj.canSetPhysicalNicLinkSpeed), context);
	update_member_with_version(update, "dhcpOnVnicSupported", "xsd:boolean", basic2str(_obj.dhcpOnVnicSupported), context, "2.5");
	update_member_with_version(update, "dnsConfigSupported", "xsd:boolean", basic2str(_obj.dnsConfigSupported), context, "2.5");
	update_member_with_version(update, "ipRouteConfigSupported", "xsd:boolean", basic2str(_obj.ipRouteConfigSupported), context, "2.5");
	update_member_with_version(update, "ipV6Supported", "xsd:boolean", basic2str(_obj.ipV6Supported), context, "4.0");
	update_member_with_version(update, "maxPortGroupsPerVswitch", "xsd:int", basic2str(_obj.maxPortGroupsPerVswitch), context, "2.5");
	update_member(update, "nicTeamingPolicy", "xsd:string[]", a2s_basic(*_obj.nicTeamingPolicy, _obj.__sizenicTeamingPolicy), context);
	update_member(update, "supportsNetworkHints", "xsd:boolean", basic2str(_obj.supportsNetworkHints), context);
	update_member(update, "supportsNicTeaming", "xsd:boolean", basic2str(_obj.supportsNicTeaming), context);
	update_member(update, "supportsVlan", "xsd:boolean", basic2str(_obj.supportsVlan), context);
	update_member(update, "usesServiceConsoleNic", "xsd:boolean", basic2str(_obj.usesServiceConsoleNic), context);
	update_member_with_version(update, "vnicConfigSupported", "xsd:boolean", basic2str(_obj.vnicConfigSupported), context, "2.5");
	update_member_with_version(update, "vswitchConfigSupported", "xsd:boolean", basic2str(_obj.vswitchConfigSupported), context, "2.5");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNetCapabilities_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNetOffloadCapabilities_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNetOffloadCapabilities", context);
	update_member(update, "csumOffload", "xsd:boolean", basic2str(_obj.csumOffload), context);
	update_member(update, "tcpSegmentation", "xsd:boolean", basic2str(_obj.tcpSegmentation), context);
	update_member(update, "zeroCopyXmit", "xsd:boolean", basic2str(_obj.zeroCopyXmit), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNetOffloadCapabilities_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNetworkConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNetworkConfig", context);
	update_member(update, "consoleIpRouteConfig", "HostIpRouteConfig", handle_obj_ptr(_obj.consoleIpRouteConfig), context);
	update_member(update, "consoleVnic", "HostVirtualNicConfig[]", a2s_object(_obj.consoleVnic, _obj.__sizeconsoleVnic), context);
	update_member_with_version(update, "dhcp", "HostDhcpServiceConfig[]", a2s_object(_obj.dhcp, _obj.__sizedhcp), context, "2.5");
	update_member(update, "dnsConfig", "HostDnsConfig", handle_obj_ptr(_obj.dnsConfig), context);
	update_member(update, "ipRouteConfig", "HostIpRouteConfig", handle_obj_ptr(_obj.ipRouteConfig), context);
	update_member_with_version(update, "ipV6Enabled", "xsd:boolean", basic2str(_obj.ipV6Enabled), context, "4.0");
	update_member_with_version(update, "nat", "HostNatServiceConfig[]", a2s_object(_obj.nat, _obj.__sizenat), context, "2.5");
	update_member(update, "pnic", "PhysicalNicConfig[]", a2s_object(_obj.pnic, _obj.__sizepnic), context);
	update_member(update, "portgroup", "HostPortGroupConfig[]", a2s_object(_obj.portgroup, _obj.__sizeportgroup), context);
	update_member_with_version(update, "proxySwitch", "HostProxySwitchConfig[]", a2s_object(_obj.proxySwitch, _obj.__sizeproxySwitch), context, "4.0");
	update_member_with_version(update, "routeTableConfig", "HostIpRouteTableConfig", handle_obj_ptr(_obj.routeTableConfig), context, "4.0");
	update_member(update, "vnic", "HostVirtualNicConfig[]", a2s_object(_obj.vnic, _obj.__sizevnic), context);
	update_member(update, "vswitch", "HostVirtualSwitchConfig[]", a2s_object(_obj.vswitch, _obj.__sizevswitch), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNetworkConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.consoleIpRouteConfig)
			return new HostIpRouteConfig_closure(*_obj.consoleIpRouteConfig);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeconsoleVnic)
				return new HostVirtualNicConfig_closure(*_obj.consoleVnic[i]);
			else
				return 0;
		}
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedhcp)
				return new HostDhcpServiceConfig_closure(*_obj.dhcp[i]);
			else
				return 0;
		}
	case 3:
		if (_obj.dnsConfig)
			return new HostDnsConfig_closure(*_obj.dnsConfig);
		else
			return 0;
	case 4:
		if (_obj.ipRouteConfig)
			return new HostIpRouteConfig_closure(*_obj.ipRouteConfig);
		else
			return 0;
	case 6:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenat)
				return new HostNatServiceConfig_closure(*_obj.nat[i]);
			else
				return 0;
		}
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepnic)
				return new PhysicalNicConfig_closure(*_obj.pnic[i]);
			else
				return 0;
		}
	case 8:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeportgroup)
				return new HostPortGroupConfig_closure(*_obj.portgroup[i]);
			else
				return 0;
		}
	case 9:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeproxySwitch)
				return new HostProxySwitchConfig_closure(*_obj.proxySwitch[i]);
			else
				return 0;
		}
	case 10:
		if (_obj.routeTableConfig)
			return new HostIpRouteTableConfig_closure(*_obj.routeTableConfig);
		else
			return 0;
	case 11:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevnic)
				return new HostVirtualNicConfig_closure(*_obj.vnic[i]);
			else
				return 0;
		}
	case 12:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevswitch)
				return new HostVirtualSwitchConfig_closure(*_obj.vswitch[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 13) << 16) + arr_index);
	}
	return 0;
}

void HostNetworkConfigResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNetworkConfigResult", context);
	update_member(update, "consoleVnicDevice", "xsd:string[]", a2s_basic(*_obj.consoleVnicDevice, _obj.__sizeconsoleVnicDevice), context);
	update_member(update, "vnicDevice", "xsd:string[]", a2s_basic(*_obj.vnicDevice, _obj.__sizevnicDevice), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNetworkConfigResult_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNetworkInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNetworkInfo", context);
	update_member_with_version(update, "atBootIpV6Enabled", "xsd:boolean", basic2str(_obj.atBootIpV6Enabled), context, "4.1");
	update_member(update, "consoleIpRouteConfig", "HostIpRouteConfig", handle_obj_ptr(_obj.consoleIpRouteConfig), context);
	update_member(update, "consoleVnic", "HostVirtualNic[]", a2s_object(_obj.consoleVnic, _obj.__sizeconsoleVnic), context);
	update_member_with_version(update, "dhcp", "HostDhcpService[]", a2s_object(_obj.dhcp, _obj.__sizedhcp), context, "2.5");
	update_member(update, "dnsConfig", "HostDnsConfig", handle_obj_ptr(_obj.dnsConfig), context);
	update_member(update, "ipRouteConfig", "HostIpRouteConfig", handle_obj_ptr(_obj.ipRouteConfig), context);
	update_member_with_version(update, "ipV6Enabled", "xsd:boolean", basic2str(_obj.ipV6Enabled), context, "4.0");
	update_member_with_version(update, "nat", "HostNatService[]", a2s_object(_obj.nat, _obj.__sizenat), context, "2.5");
	update_member(update, "pnic", "PhysicalNic[]", a2s_object(_obj.pnic, _obj.__sizepnic), context);
	update_member(update, "portgroup", "HostPortGroup[]", a2s_object(_obj.portgroup, _obj.__sizeportgroup), context);
	update_member_with_version(update, "proxySwitch", "HostProxySwitch[]", a2s_object(_obj.proxySwitch, _obj.__sizeproxySwitch), context, "4.0");
	update_member_with_version(update, "routeTableInfo", "HostIpRouteTableInfo", handle_obj_ptr(_obj.routeTableInfo), context, "4.0");
	update_member(update, "vnic", "HostVirtualNic[]", a2s_object(_obj.vnic, _obj.__sizevnic), context);
	update_member(update, "vswitch", "HostVirtualSwitch[]", a2s_object(_obj.vswitch, _obj.__sizevswitch), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNetworkInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.consoleIpRouteConfig)
			return new HostIpRouteConfig_closure(*_obj.consoleIpRouteConfig);
		else
			return 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeconsoleVnic)
				return new HostVirtualNic_closure(*_obj.consoleVnic[i]);
			else
				return 0;
		}
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedhcp)
				return new HostDhcpService_closure(*_obj.dhcp[i]);
			else
				return 0;
		}
	case 4:
		if (_obj.dnsConfig)
			return new HostDnsConfig_closure(*_obj.dnsConfig);
		else
			return 0;
	case 5:
		if (_obj.ipRouteConfig)
			return new HostIpRouteConfig_closure(*_obj.ipRouteConfig);
		else
			return 0;
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenat)
				return new HostNatService_closure(*_obj.nat[i]);
			else
				return 0;
		}
	case 8:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepnic)
				return new PhysicalNic_closure(*_obj.pnic[i]);
			else
				return 0;
		}
	case 9:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeportgroup)
				return new HostPortGroup_closure(*_obj.portgroup[i]);
			else
				return 0;
		}
	case 10:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeproxySwitch)
				return new HostProxySwitch_closure(*_obj.proxySwitch[i]);
			else
				return 0;
		}
	case 11:
		if (_obj.routeTableInfo)
			return new HostIpRouteTableInfo_closure(*_obj.routeTableInfo);
		else
			return 0;
	case 12:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevnic)
				return new HostVirtualNic_closure(*_obj.vnic[i]);
			else
				return 0;
		}
	case 13:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevswitch)
				return new HostVirtualSwitch_closure(*_obj.vswitch[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 14) << 16) + arr_index);
	}
	return 0;
}

void HostNetworkPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNetworkPolicy", context);
	update_member(update, "nicTeaming", "HostNicTeamingPolicy", handle_obj_ptr(_obj.nicTeaming), context);
	update_member(update, "offloadPolicy", "HostNetOffloadCapabilities", handle_obj_ptr(_obj.offloadPolicy), context);
	update_member(update, "security", "HostNetworkSecurityPolicy", handle_obj_ptr(_obj.security), context);
	update_member(update, "shapingPolicy", "HostNetworkTrafficShapingPolicy", handle_obj_ptr(_obj.shapingPolicy), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNetworkPolicy_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.nicTeaming)
			return new HostNicTeamingPolicy_closure(*_obj.nicTeaming);
		else
			return 0;
	case 1:
		if (_obj.offloadPolicy)
			return new HostNetOffloadCapabilities_closure(*_obj.offloadPolicy);
		else
			return 0;
	case 2:
		if (_obj.security)
			return new HostNetworkSecurityPolicy_closure(*_obj.security);
		else
			return 0;
	case 3:
		if (_obj.shapingPolicy)
			return new HostNetworkTrafficShapingPolicy_closure(*_obj.shapingPolicy);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostNetworkSecurityPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNetworkSecurityPolicy", context);
	update_member(update, "allowPromiscuous", "xsd:boolean", basic2str(_obj.allowPromiscuous), context);
	update_member(update, "forgedTransmits", "xsd:boolean", basic2str(_obj.forgedTransmits), context);
	update_member(update, "macChanges", "xsd:boolean", basic2str(_obj.macChanges), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNetworkSecurityPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNetworkTrafficShapingPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNetworkTrafficShapingPolicy", context);
	update_member(update, "averageBandwidth", "xsd:long", basic2str(_obj.averageBandwidth), context);
	update_member(update, "burstSize", "xsd:long", basic2str(_obj.burstSize), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "peakBandwidth", "xsd:long", basic2str(_obj.peakBandwidth), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNetworkTrafficShapingPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNewNetworkConnectInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNewNetworkConnectInfo", context);
	update("Base", "HostConnectInfoNetworkInfo", context);
	HostConnectInfoNetworkInfo_closure(dynamic_cast<const vw1__HostConnectInfoNetworkInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNewNetworkConnectInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNicFailureCriteria_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNicFailureCriteria", context);
	update_member(update, "checkBeacon", "xsd:boolean", basic2str(_obj.checkBeacon), context);
	update_member(update, "checkDuplex", "xsd:boolean", basic2str(_obj.checkDuplex), context);
	update_member(update, "checkErrorPercent", "xsd:boolean", basic2str(_obj.checkErrorPercent), context);
	update_member(update, "checkSpeed", "xsd:string", basic2str(_obj.checkSpeed), context);
	update_member(update, "fullDuplex", "xsd:boolean", basic2str(_obj.fullDuplex), context);
	update_member(update, "percentage", "xsd:int", basic2str(_obj.percentage), context);
	update_member(update, "speed", "xsd:int", basic2str(_obj.speed), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNicFailureCriteria_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNicOrderPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNicOrderPolicy", context);
	update_member(update, "activeNic", "xsd:string[]", a2s_basic(*_obj.activeNic, _obj.__sizeactiveNic), context);
	update_member(update, "standbyNic", "xsd:string[]", a2s_basic(*_obj.standbyNic, _obj.__sizestandbyNic), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNicOrderPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNicTeamingPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNicTeamingPolicy", context);
	update_member(update, "failureCriteria", "HostNicFailureCriteria", handle_obj_ptr(_obj.failureCriteria), context);
	update_member(update, "nicOrder", "HostNicOrderPolicy", handle_obj_ptr(_obj.nicOrder), context);
	update_member(update, "notifySwitches", "xsd:boolean", basic2str(_obj.notifySwitches), context);
	update_member(update, "policy", "xsd:string", basic2str(_obj.policy), context);
	update_member(update, "reversePolicy", "xsd:boolean", basic2str(_obj.reversePolicy), context);
	update_member(update, "rollingOrder", "xsd:boolean", basic2str(_obj.rollingOrder), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNicTeamingPolicy_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.failureCriteria)
			return new HostNicFailureCriteria_closure(*_obj.failureCriteria);
		else
			return 0;
	case 1:
		if (_obj.nicOrder)
			return new HostNicOrderPolicy_closure(*_obj.nicOrder);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void HostNoAvailableNetworksEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNoAvailableNetworksEvent", context);
	update_member(update, "ips", "xsd:string", basic2str(_obj.ips), context);
	update("Base", "HostDasEvent", context);
	HostDasEvent_closure(dynamic_cast<const vw1__HostDasEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNoAvailableNetworksEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNoHAEnabledPortGroupsEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNoHAEnabledPortGroupsEvent", context);
	update("Base", "HostDasEvent", context);
	HostDasEvent_closure(dynamic_cast<const vw1__HostDasEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNoHAEnabledPortGroupsEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNoRedundantManagementNetworkEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNoRedundantManagementNetworkEvent", context);
	update("Base", "HostDasEvent", context);
	HostDasEvent_closure(dynamic_cast<const vw1__HostDasEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNoRedundantManagementNetworkEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNonCompliantEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNonCompliantEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNonCompliantEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNotInClusterEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNotInClusterEvent", context);
	update("Base", "HostDasEvent", context);
	HostDasEvent_closure(dynamic_cast<const vw1__HostDasEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNotInClusterEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNtpConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNtpConfig", context);
	update_member(update, "server", "xsd:string[]", a2s_basic(*_obj.server, _obj.__sizeserver), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNtpConfig_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNumaInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNumaInfo", context);
	update_member(update, "numaNode", "HostNumaNode[]", a2s_object(_obj.numaNode, _obj.__sizenumaNode), context);
	update_member(update, "numNodes", "xsd:int", basic2str(_obj.numNodes), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNumaInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenumaNode)
				return new HostNumaNode_closure(*_obj.numaNode[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostNumaNode_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNumaNode", context);
	update_member(update, "cpuID", "xsd:short[]", a2s_basic(_obj.cpuID, _obj.__sizecpuID), context);
	update_member(update, "memoryRangeBegin", "xsd:long", basic2str(_obj.memoryRangeBegin), context);
	update_member(update, "memoryRangeLength", "xsd:long", basic2str(_obj.memoryRangeLength), context);
	update_member(update, "typeId", "xsd:byte", basic2str(_obj.typeId), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNumaNode_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNumericSensorInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNumericSensorInfo", context);
	update_member(update, "baseUnits", "xsd:string", basic2str(_obj.baseUnits), context);
	update_member(update, "currentReading", "xsd:long", basic2str(_obj.currentReading), context);
	update_member(update, "healthState", "ElementDescription", handle_obj_ptr(_obj.healthState), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "rateUnits", "xsd:string", basic2str(_obj.rateUnits), context);
	update_member(update, "sensorType", "xsd:string", basic2str(_obj.sensorType), context);
	update_member(update, "unitModifier", "xsd:int", basic2str(_obj.unitModifier), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNumericSensorInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.healthState)
			return new ElementDescription_closure(*_obj.healthState);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void HostOvercommittedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostOvercommittedEvent", context);
	update("Base", "ClusterOvercommittedEvent", context);
	ClusterOvercommittedEvent_closure(dynamic_cast<const vw1__ClusterOvercommittedEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostOvercommittedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostParallelScsiHba_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostParallelScsiHba", context);
	update("Base", "HostHostBusAdapter", context);
	HostHostBusAdapter_closure(dynamic_cast<const vw1__HostHostBusAdapter&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostParallelScsiHba_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostParallelScsiTargetTransport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostParallelScsiTargetTransport", context);
	update("Base", "HostTargetTransport", context);
	HostTargetTransport_closure(dynamic_cast<const vw1__HostTargetTransport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostParallelScsiTargetTransport_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPatchManagerLocator_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPatchManagerLocator", context);
	update_member(update, "proxy", "xsd:string", basic2str(_obj.proxy), context);
	update_member(update, "url", "xsd:string", basic2str(_obj.url), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPatchManagerLocator_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPatchManagerPatchManagerOperationSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPatchManagerPatchManagerOperationSpec", context);
	update_member(update, "cmdOption", "xsd:string", basic2str(_obj.cmdOption), context);
	update_member(update, "password", "xsd:string", basic2str(_obj.password), context);
	update_member(update, "port", "xsd:int", basic2str(_obj.port), context);
	update_member(update, "proxy", "xsd:string", basic2str(_obj.proxy), context);
	update_member(update, "userName", "xsd:string", basic2str(_obj.userName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPatchManagerPatchManagerOperationSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPatchManagerResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPatchManagerResult", context);
	update_member(update, "status", "HostPatchManagerStatus[]", a2s_object(_obj.status, _obj.__sizestatus), context);
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update_member(update, "xmlResult", "xsd:string", basic2str(_obj.xmlResult), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPatchManagerResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizestatus)
				return new HostPatchManagerStatus_closure(*_obj.status[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostPatchManagerStatus_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPatchManagerStatus", context);
	update_member(update, "applicable", "xsd:boolean", basic2str(_obj.applicable), context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "installed", "xsd:boolean", basic2str(_obj.installed), context);
	update_member(update, "installState", "xsd:string[]", a2s_basic(*_obj.installState, _obj.__sizeinstallState), context);
	update_member(update, "integrity", "xsd:string", basic2str(_obj.integrity), context);
	update_member(update, "prerequisitePatch", "HostPatchManagerStatusPrerequisitePatch[]", a2s_object(_obj.prerequisitePatch, _obj.__sizeprerequisitePatch), context);
	update_member(update, "reason", "xsd:string[]", a2s_basic(*_obj.reason, _obj.__sizereason), context);
	update_member(update, "reconnectRequired", "xsd:boolean", basic2str(_obj.reconnectRequired), context);
	update_member(update, "restartRequired", "xsd:boolean", basic2str(_obj.restartRequired), context);
	update_member(update, "supersededPatchIds", "xsd:string[]", a2s_basic(*_obj.supersededPatchIds, _obj.__sizesupersededPatchIds), context);
	update_member(update, "vmOffRequired", "xsd:boolean", basic2str(_obj.vmOffRequired), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPatchManagerStatus_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeprerequisitePatch)
				return new HostPatchManagerStatusPrerequisitePatch_closure(*_obj.prerequisitePatch[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void HostPatchManagerStatusPrerequisitePatch_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPatchManagerStatusPrerequisitePatch", context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "installState", "xsd:string[]", a2s_basic(*_obj.installState, _obj.__sizeinstallState), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPatchManagerStatusPrerequisitePatch_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPathSelectionPolicyOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPathSelectionPolicyOption", context);
	update_member(update, "policy", "ElementDescription", handle_obj_ptr(_obj.policy), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPathSelectionPolicyOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.policy)
			return new ElementDescription_closure(*_obj.policy);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostPciDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPciDevice", context);
	update_member(update, "bus", "xsd:byte", basic2str(_obj.bus), context);
	update_member(update, "classId", "xsd:short", basic2str(_obj.classId), context);
	update_member(update, "deviceId", "xsd:short", basic2str(_obj.deviceId), context);
	update_member(update, "deviceName", "xsd:string", basic2str(_obj.deviceName), context);
	update_member(update, "function", "xsd:byte", basic2str(_obj.function), context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member_with_version(update, "parentBridge", "xsd:string", basic2str(_obj.parentBridge), context, "4.0");
	update_member(update, "slot", "xsd:byte", basic2str(_obj.slot), context);
	update_member(update, "subDeviceId", "xsd:short", basic2str(_obj.subDeviceId), context);
	update_member(update, "subVendorId", "xsd:short", basic2str(_obj.subVendorId), context);
	update_member(update, "vendorId", "xsd:short", basic2str(_obj.vendorId), context);
	update_member(update, "vendorName", "xsd:string", basic2str(_obj.vendorName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPciDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPciPassthruConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPciPassthruConfig", context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "passthruEnabled", "xsd:boolean", basic2str(_obj.passthruEnabled), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPciPassthruConfig_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPciPassthruInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPciPassthruInfo", context);
	update_member(update, "dependentDevice", "xsd:string", basic2str(_obj.dependentDevice), context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "passthruActive", "xsd:boolean", basic2str(_obj.passthruActive), context);
	update_member(update, "passthruCapable", "xsd:boolean", basic2str(_obj.passthruCapable), context);
	update_member(update, "passthruEnabled", "xsd:boolean", basic2str(_obj.passthruEnabled), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPciPassthruInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPlugStoreTopology_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPlugStoreTopology", context);
	update_member(update, "adapter", "HostPlugStoreTopologyAdapter[]", a2s_object(_obj.adapter, _obj.__sizeadapter), context);
	update_member(update, "device", "HostPlugStoreTopologyDevice[]", a2s_object(_obj.device, _obj.__sizedevice), context);
	update_member(update, "path", "HostPlugStoreTopologyPath[]", a2s_object(_obj.path, _obj.__sizepath), context);
	update_member(update, "plugin", "HostPlugStoreTopologyPlugin[]", a2s_object(_obj.plugin, _obj.__sizeplugin), context);
	update_member(update, "target", "HostPlugStoreTopologyTarget[]", a2s_object(_obj.target, _obj.__sizetarget), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPlugStoreTopology_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeadapter)
				return new HostPlugStoreTopologyAdapter_closure(*_obj.adapter[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedevice)
				return new HostPlugStoreTopologyDevice_closure(*_obj.device[i]);
			else
				return 0;
		}
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepath)
				return new HostPlugStoreTopologyPath_closure(*_obj.path[i]);
			else
				return 0;
		}
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeplugin)
				return new HostPlugStoreTopologyPlugin_closure(*_obj.plugin[i]);
			else
				return 0;
		}
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizetarget)
				return new HostPlugStoreTopologyTarget_closure(*_obj.target[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void HostPlugStoreTopologyAdapter_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPlugStoreTopologyAdapter", context);
	update_member(update, "adapter", "xsd:string", basic2str(_obj.adapter), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "path", "xsd:string[]", a2s_basic(*_obj.path, _obj.__sizepath), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPlugStoreTopologyAdapter_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPlugStoreTopologyDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPlugStoreTopologyDevice", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "lun", "xsd:string", basic2str(_obj.lun), context);
	update_member(update, "path", "xsd:string[]", a2s_basic(*_obj.path, _obj.__sizepath), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPlugStoreTopologyDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPlugStoreTopologyPath_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPlugStoreTopologyPath", context);
	update_member(update, "adapter", "xsd:string", basic2str(_obj.adapter), context);
	update_member(update, "channelNumber", "xsd:int", basic2str(_obj.channelNumber), context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "lunNumber", "xsd:int", basic2str(_obj.lunNumber), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "target", "xsd:string", basic2str(_obj.target), context);
	update_member(update, "targetNumber", "xsd:int", basic2str(_obj.targetNumber), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPlugStoreTopologyPath_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPlugStoreTopologyPlugin_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPlugStoreTopologyPlugin", context);
	update_member(update, "claimedPath", "xsd:string[]", a2s_basic(*_obj.claimedPath, _obj.__sizeclaimedPath), context);
	update_member(update, "device", "xsd:string[]", a2s_basic(*_obj.device, _obj.__sizedevice), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPlugStoreTopologyPlugin_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPlugStoreTopologyTarget_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPlugStoreTopologyTarget", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "transport", "HostTargetTransport", handle_obj_ptr(_obj.transport), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPlugStoreTopologyTarget_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.transport)
			return new HostTargetTransport_closure(*_obj.transport);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostPortGroup_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPortGroup", context);
	update_member(update, "computedPolicy", "HostNetworkPolicy", handle_obj_ptr(_obj.computedPolicy), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "port", "HostPortGroupPort[]", a2s_object(_obj.port, _obj.__sizeport), context);
	update_member(update, "spec", "HostPortGroupSpec", handle_obj_ptr(_obj.spec), context);
	update_member(update, "vswitch", "xsd:string", basic2str(_obj.vswitch), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPortGroup_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.computedPolicy)
			return new HostNetworkPolicy_closure(*_obj.computedPolicy);
		else
			return 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeport)
				return new HostPortGroupPort_closure(*_obj.port[i]);
			else
				return 0;
		}
	case 3:
		if (_obj.spec)
			return new HostPortGroupSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void HostPortGroupConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPortGroupConfig", context);
	update_member(update, "changeOperation", "xsd:string", basic2str(_obj.changeOperation), context);
	update_member(update, "spec", "HostPortGroupSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPortGroupConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.spec)
			return new HostPortGroupSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostPortGroupPort_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPortGroupPort", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "mac", "xsd:string[]", a2s_basic(*_obj.mac, _obj.__sizemac), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPortGroupPort_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPortGroupProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPortGroupProfile", context);
	update_member(update, "ipConfig", "IpAddressProfile", handle_obj_ptr(_obj.ipConfig), context);
	update("Base", "PortGroupProfile", context);
	PortGroupProfile_closure(dynamic_cast<const vw1__PortGroupProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPortGroupProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.ipConfig)
			return new IpAddressProfile_closure(*_obj.ipConfig);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return PortGroupProfile_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostPortGroupSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPortGroupSpec", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "policy", "HostNetworkPolicy", handle_obj_ptr(_obj.policy), context);
	update_member(update, "vlanId", "xsd:int", basic2str(_obj.vlanId), context);
	update_member(update, "vswitchName", "xsd:string", basic2str(_obj.vswitchName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPortGroupSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.policy)
			return new HostNetworkPolicy_closure(*_obj.policy);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostPosixAccountSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPosixAccountSpec", context);
	update_member(update, "posixId", "xsd:int", basic2str(_obj.posixId), context);
	update_member(update, "shellAccess", "xsd:boolean", basic2str(_obj.shellAccess), context);
	update("Base", "HostAccountSpec", context);
	HostAccountSpec_closure(dynamic_cast<const vw1__HostAccountSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPosixAccountSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPowerPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPowerPolicy", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "shortName", "xsd:string", basic2str(_obj.shortName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPowerPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPrimaryAgentNotShortNameEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPrimaryAgentNotShortNameEvent", context);
	update_member(update, "primaryAgent", "xsd:string", basic2str(_obj.primaryAgent), context);
	update("Base", "HostDasEvent", context);
	HostDasEvent_closure(dynamic_cast<const vw1__HostDasEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPrimaryAgentNotShortNameEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostProfileAppliedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostProfileAppliedEvent", context);
	update_member(update, "profile", "ProfileEventArgument", handle_obj_ptr(_obj.profile), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostProfileAppliedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.profile)
			return new ProfileEventArgument_closure(*_obj.profile);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostProfileCompleteConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostProfileCompleteConfigSpec", context);
	update_member(update, "applyProfile", "HostApplyProfile", handle_obj_ptr(_obj.applyProfile), context);
	update_member(update, "customComplyProfile", "ComplianceProfile", handle_obj_ptr(_obj.customComplyProfile), context);
	update_member(update, "disabledExpressionList", "xsd:string[]", a2s_basic(*_obj.disabledExpressionList, _obj.__sizedisabledExpressionList), context);
	update_member(update, "disabledExpressionListChanged", "xsd:boolean", basic2str(_obj.disabledExpressionListChanged), context);
	update_member_with_version(update, "validatorHost", "HostSystem", handle_obj_ptr(_obj.validatorHost), context, "5.0");
	update("Base", "HostProfileConfigSpec", context);
	HostProfileConfigSpec_closure(dynamic_cast<const vw1__HostProfileConfigSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostProfileCompleteConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.applyProfile)
			return new HostApplyProfile_closure(*_obj.applyProfile);
		else
			return 0;
	case 1:
		if (_obj.customComplyProfile)
			return new ComplianceProfile_closure(*_obj.customComplyProfile);
		else
			return 0;
	case 4:
		return _obj.validatorHost? 
			get_closure_from_mor(HostSystem(_obj.validatorHost)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostProfileConfigSpec_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void HostProfileConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostProfileConfigInfo", context);
	update_member(update, "applyProfile", "HostApplyProfile", handle_obj_ptr(_obj.applyProfile), context);
	update_member(update, "customComplyProfile", "ComplianceProfile", handle_obj_ptr(_obj.customComplyProfile), context);
	update_member(update, "defaultComplyLocator", "ComplianceLocator[]", a2s_object(_obj.defaultComplyLocator, _obj.__sizedefaultComplyLocator), context);
	update_member(update, "defaultComplyProfile", "ComplianceProfile", handle_obj_ptr(_obj.defaultComplyProfile), context);
	update_member(update, "disabledExpressionList", "xsd:string[]", a2s_basic(*_obj.disabledExpressionList, _obj.__sizedisabledExpressionList), context);
	update("Base", "ProfileConfigInfo", context);
	ProfileConfigInfo_closure(dynamic_cast<const vw1__ProfileConfigInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostProfileConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.applyProfile)
			return new HostApplyProfile_closure(*_obj.applyProfile);
		else
			return 0;
	case 1:
		if (_obj.customComplyProfile)
			return new ComplianceProfile_closure(*_obj.customComplyProfile);
		else
			return 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedefaultComplyLocator)
				return new ComplianceLocator_closure(*_obj.defaultComplyLocator[i]);
			else
				return 0;
		}
	case 3:
		if (_obj.defaultComplyProfile)
			return new ComplianceProfile_closure(*_obj.defaultComplyProfile);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ProfileConfigInfo_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void HostProfileConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostProfileConfigSpec", context);
	update("Base", "ProfileCreateSpec", context);
	ProfileCreateSpec_closure(dynamic_cast<const vw1__ProfileCreateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostProfileConfigSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostProfileHostBasedConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostProfileHostBasedConfigSpec", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member_with_version(update, "useHostProfileEngine", "xsd:boolean", basic2str(_obj.useHostProfileEngine), context, "5.0");
	update("Base", "HostProfileConfigSpec", context);
	HostProfileConfigSpec_closure(dynamic_cast<const vw1__HostProfileConfigSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostProfileHostBasedConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostProfileConfigSpec_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostProfileManagerConfigTaskList_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostProfileManagerConfigTaskList", context);
	update_member(update, "configSpec", "HostConfigSpec", handle_obj_ptr(_obj.configSpec), context);
	update_member(update, "taskDescription", "LocalizableMessage[]", a2s_object(_obj.taskDescription, _obj.__sizetaskDescription), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostProfileManagerConfigTaskList_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.configSpec)
			return new HostConfigSpec_closure(*_obj.configSpec);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizetaskDescription)
				return new LocalizableMessage_closure(*_obj.taskDescription[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostProfileSerializedHostProfileSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostProfileSerializedHostProfileSpec", context);
	update_member(update, "validatorHost", "HostSystem", handle_obj_ptr(_obj.validatorHost), context);
	update("Base", "ProfileSerializedCreateSpec", context);
	ProfileSerializedCreateSpec_closure(dynamic_cast<const vw1__ProfileSerializedCreateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostProfileSerializedHostProfileSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.validatorHost? 
			get_closure_from_mor(HostSystem(_obj.validatorHost)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return ProfileSerializedCreateSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostProxySwitch_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostProxySwitch", context);
	update_member_with_version(update, "configNumPorts", "xsd:int", basic2str(_obj.configNumPorts), context, "5.0");
	update_member(update, "dvsName", "xsd:string", basic2str(_obj.dvsName), context);
	update_member(update, "dvsUuid", "xsd:string", basic2str(_obj.dvsUuid), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "mtu", "xsd:int", basic2str(_obj.mtu), context);
	update_member(update, "numPorts", "xsd:int", basic2str(_obj.numPorts), context);
	update_member(update, "numPortsAvailable", "xsd:int", basic2str(_obj.numPortsAvailable), context);
	update_member(update, "pnic", "xsd:string[]", a2s_basic(*_obj.pnic, _obj.__sizepnic), context);
	update_member(update, "spec", "HostProxySwitchSpec", handle_obj_ptr(_obj.spec), context);
	update_member(update, "uplinkPort", "KeyValue[]", a2s_object(_obj.uplinkPort, _obj.__sizeuplinkPort), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostProxySwitch_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 8:
		if (_obj.spec)
			return new HostProxySwitchSpec_closure(*_obj.spec);
		else
			return 0;
	case 9:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeuplinkPort)
				return new KeyValue_closure(*_obj.uplinkPort[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 10) << 16) + arr_index);
	}
	return 0;
}

void HostProxySwitchConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostProxySwitchConfig", context);
	update_member(update, "changeOperation", "xsd:string", basic2str(_obj.changeOperation), context);
	update_member(update, "spec", "HostProxySwitchSpec", handle_obj_ptr(_obj.spec), context);
	update_member(update, "uuid", "xsd:string", basic2str(_obj.uuid), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostProxySwitchConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.spec)
			return new HostProxySwitchSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostProxySwitchSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostProxySwitchSpec", context);
	update_member(update, "backing", "DistributedVirtualSwitchHostMemberBacking", handle_obj_ptr(_obj.backing), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostProxySwitchSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.backing)
			return new DistributedVirtualSwitchHostMemberBacking_closure(*_obj.backing);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostReconnectionFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostReconnectionFailedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostReconnectionFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostRemovedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostRemovedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostRemovedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostResignatureRescanResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostResignatureRescanResult", context);
	update_member(update, "rescan", "HostVmfsRescanResult[]", a2s_object(_obj.rescan, _obj.__sizerescan), context);
	update_member(update, "result", "Datastore", handle_obj_ptr(_obj.result), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostResignatureRescanResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerescan)
				return new HostVmfsRescanResult_closure(*_obj.rescan[i]);
			else
				return 0;
		}
	case 1:
		return _obj.result? 
			get_closure_from_mor(Datastore(_obj.result)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostRuntimeInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostRuntimeInfo", context);
	update_member(update, "bootTime", "xsd:dateTime", basic2str(_obj.bootTime), context);
	update_member(update, "connectionState", "HostSystemConnectionState", handle_obj(_obj.connectionState), context);
	update_member_with_version(update, "dasHostState", "ClusterDasFdmHostState", handle_obj_ptr(_obj.dasHostState), context, "5.0");
	update_member_with_version(update, "healthSystemRuntime", "HealthSystemRuntime", handle_obj_ptr(_obj.healthSystemRuntime), context, "2.5");
	update_member(update, "inMaintenanceMode", "xsd:boolean", basic2str(_obj.inMaintenanceMode), context);
	update_member_with_version(update, "powerState", "HostSystemPowerState", handle_obj(_obj.powerState), context, "2.5");
	update_member_with_version(update, "standbyMode", "xsd:string", basic2str(_obj.standbyMode), context, "4.1");
	update_member_with_version(update, "tpmPcrValues", "HostTpmDigestInfo[]", a2s_object(_obj.tpmPcrValues, _obj.__sizetpmPcrValues), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostRuntimeInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.dasHostState)
			return new ClusterDasFdmHostState_closure(*_obj.dasHostState);
		else
			return 0;
	case 3:
		if (_obj.healthSystemRuntime)
			return new HealthSystemRuntime_closure(*_obj.healthSystemRuntime);
		else
			return 0;
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizetpmPcrValues)
				return new HostTpmDigestInfo_closure(*_obj.tpmPcrValues[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void HostScsiDisk_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostScsiDisk", context);
	update_member(update, "capacity", "HostDiskDimensionsLba", handle_obj_ptr(_obj.capacity), context);
	update_member(update, "devicePath", "xsd:string", basic2str(_obj.devicePath), context);
	update_member_with_version(update, "ssd", "xsd:boolean", basic2str(_obj.ssd), context, "5.0");
	update("Base", "ScsiLun", context);
	ScsiLun_closure(dynamic_cast<const vw1__ScsiLun&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostScsiDisk_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.capacity)
			return new HostDiskDimensionsLba_closure(*_obj.capacity);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ScsiLun_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostScsiDiskPartition_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostScsiDiskPartition", context);
	update_member(update, "diskName", "xsd:string", basic2str(_obj.diskName), context);
	update_member(update, "partition", "xsd:int", basic2str(_obj.partition), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostScsiDiskPartition_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostScsiTopology_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostScsiTopology", context);
	update_member(update, "adapter", "HostScsiTopologyInterface[]", a2s_object(_obj.adapter, _obj.__sizeadapter), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostScsiTopology_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeadapter)
				return new HostScsiTopologyInterface_closure(*_obj.adapter[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostScsiTopologyInterface_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostScsiTopologyInterface", context);
	update_member(update, "adapter", "xsd:string", basic2str(_obj.adapter), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "target", "HostScsiTopologyTarget[]", a2s_object(_obj.target, _obj.__sizetarget), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostScsiTopologyInterface_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizetarget)
				return new HostScsiTopologyTarget_closure(*_obj.target[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostScsiTopologyLun_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostScsiTopologyLun", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "lun", "xsd:int", basic2str(_obj.lun), context);
	update_member(update, "scsiLun", "xsd:string", basic2str(_obj.scsiLun), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostScsiTopologyLun_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostScsiTopologyTarget_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostScsiTopologyTarget", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "lun", "HostScsiTopologyLun[]", a2s_object(_obj.lun, _obj.__sizelun), context);
	update_member(update, "target", "xsd:int", basic2str(_obj.target), context);
	update_member(update, "transport", "HostTargetTransport", handle_obj_ptr(_obj.transport), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostScsiTopologyTarget_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizelun)
				return new HostScsiTopologyLun_closure(*_obj.lun[i]);
			else
				return 0;
		}
	case 3:
		if (_obj.transport)
			return new HostTargetTransport_closure(*_obj.transport);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostSecuritySpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostSecuritySpec", context);
	update_member_with_version(update, "addPermission", "Permission[]", a2s_object(_obj.addPermission, _obj.__sizeaddPermission), context, "4.1");
	update_member(update, "adminPassword", "xsd:string", basic2str(_obj.adminPassword), context);
	update_member_with_version(update, "removePermission", "Permission[]", a2s_object(_obj.removePermission, _obj.__sizeremovePermission), context, "4.1");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostSecuritySpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeaddPermission)
				return new Permission_closure(*_obj.addPermission[i]);
			else
				return 0;
		}
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeremovePermission)
				return new Permission_closure(*_obj.removePermission[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostService_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostService", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "label", "xsd:string", basic2str(_obj.label), context);
	update_member(update, "policy", "xsd:string", basic2str(_obj.policy), context);
	update_member(update, "required", "xsd:boolean", basic2str(_obj.required), context);
	update_member(update, "ruleset", "xsd:string[]", a2s_basic(*_obj.ruleset, _obj.__sizeruleset), context);
	update_member(update, "running", "xsd:boolean", basic2str(_obj.running), context);
	update_member_with_version(update, "sourcePackage", "HostServiceSourcePackage", handle_obj_ptr(_obj.sourcePackage), context, "5.0");
	update_member(update, "uninstallable", "xsd:boolean", basic2str(_obj.uninstallable), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostService_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 6:
		if (_obj.sourcePackage)
			return new HostServiceSourcePackage_closure(*_obj.sourcePackage);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void HostServiceConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostServiceConfig", context);
	update_member(update, "serviceId", "xsd:string", basic2str(_obj.serviceId), context);
	update_member(update, "startupPolicy", "xsd:string", basic2str(_obj.startupPolicy), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostServiceConfig_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostServiceInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostServiceInfo", context);
	update_member(update, "service", "HostService[]", a2s_object(_obj.service, _obj.__sizeservice), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostServiceInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeservice)
				return new HostService_closure(*_obj.service[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostServiceSourcePackage_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostServiceSourcePackage", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "sourcePackageName", "xsd:string", basic2str(_obj.sourcePackageName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostServiceSourcePackage_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostServiceTicket_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostServiceTicket", context);
	update_member(update, "host", "xsd:string", basic2str(_obj.host), context);
	update_member(update, "port", "xsd:int", basic2str(_obj.port), context);
	update_member(update, "service", "xsd:string", basic2str(_obj.service), context);
	update_member(update, "serviceVersion", "xsd:string", basic2str(_obj.serviceVersion), context);
	update_member(update, "sessionId", "xsd:string", basic2str(_obj.sessionId), context);
	update_member_with_version(update, "sslThumbprint", "xsd:string", basic2str(_obj.sslThumbprint), context, "2.5");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostServiceTicket_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostShortNameInconsistentEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostShortNameInconsistentEvent", context);
	update_member(update, "shortName", "xsd:string", basic2str(_obj.shortName), context);
	update_member(update, "shortName2", "xsd:string", basic2str(_obj.shortName2), context);
	update("Base", "HostDasEvent", context);
	HostDasEvent_closure(dynamic_cast<const vw1__HostDasEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostShortNameInconsistentEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostShortNameToIpFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostShortNameToIpFailedEvent", context);
	update_member(update, "shortName", "xsd:string", basic2str(_obj.shortName), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostShortNameToIpFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostShutdownEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostShutdownEvent", context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostShutdownEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostSnmpConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostSnmpConfigSpec", context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member_with_version(update, "option", "KeyValue[]", a2s_object(_obj.option, _obj.__sizeoption), context, "5.0");
	update_member(update, "port", "xsd:int", basic2str(_obj.port), context);
	update_member(update, "readOnlyCommunities", "xsd:string[]", a2s_basic(*_obj.readOnlyCommunities, _obj.__sizereadOnlyCommunities), context);
	update_member(update, "trapTargets", "HostSnmpDestination[]", a2s_object(_obj.trapTargets, _obj.__sizetrapTargets), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostSnmpConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeoption)
				return new KeyValue_closure(*_obj.option[i]);
			else
				return 0;
		}
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizetrapTargets)
				return new HostSnmpDestination_closure(*_obj.trapTargets[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void HostSnmpDestination_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostSnmpDestination", context);
	update_member(update, "community", "xsd:string", basic2str(_obj.community), context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update_member(update, "port", "xsd:int", basic2str(_obj.port), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostSnmpDestination_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostSnmpSystemAgentLimits_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostSnmpSystemAgentLimits", context);
	update_member_with_version(update, "capability", "HostSnmpAgentCapability", handle_obj_ptr(_obj.capability), context, "4.0");
	update_member(update, "maxBufferSize", "xsd:int", basic2str(_obj.maxBufferSize), context);
	update_member(update, "maxCommunityLength", "xsd:int", basic2str(_obj.maxCommunityLength), context);
	update_member(update, "maxReadOnlyCommunities", "xsd:int", basic2str(_obj.maxReadOnlyCommunities), context);
	update_member(update, "maxTrapDestinations", "xsd:int", basic2str(_obj.maxTrapDestinations), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostSnmpSystemAgentLimits_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostSslThumbprintInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostSslThumbprintInfo", context);
	update_member_with_version(update, "ownerTag", "xsd:string", basic2str(_obj.ownerTag), context, "5.0");
	update_member(update, "principal", "xsd:string", basic2str(_obj.principal), context);
	update_member(update, "sslThumbprints", "xsd:string[]", a2s_basic(*_obj.sslThumbprints, _obj.__sizesslThumbprints), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostSslThumbprintInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostStatusChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostStatusChangedEvent", context);
	update("Base", "ClusterStatusChangedEvent", context);
	ClusterStatusChangedEvent_closure(dynamic_cast<const vw1__ClusterStatusChangedEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostStatusChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostStorageArrayTypePolicyOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostStorageArrayTypePolicyOption", context);
	update_member(update, "policy", "ElementDescription", handle_obj_ptr(_obj.policy), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostStorageArrayTypePolicyOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.policy)
			return new ElementDescription_closure(*_obj.policy);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostStorageDeviceInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostStorageDeviceInfo", context);
	update_member(update, "hostBusAdapter", "HostHostBusAdapter[]", a2s_object(_obj.hostBusAdapter, _obj.__sizehostBusAdapter), context);
	update_member(update, "multipathInfo", "HostMultipathInfo", handle_obj_ptr(_obj.multipathInfo), context);
	update_member_with_version(update, "plugStoreTopology", "HostPlugStoreTopology", handle_obj_ptr(_obj.plugStoreTopology), context, "4.0");
	update_member(update, "scsiLun", "ScsiLun[]", a2s_object(_obj.scsiLun, _obj.__sizescsiLun), context);
	update_member(update, "scsiTopology", "HostScsiTopology", handle_obj_ptr(_obj.scsiTopology), context);
	update_member(update, "softwareInternetScsiEnabled", "xsd:boolean", basic2str(_obj.softwareInternetScsiEnabled), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostStorageDeviceInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehostBusAdapter)
				return new HostHostBusAdapter_closure(*_obj.hostBusAdapter[i]);
			else
				return 0;
		}
	case 1:
		if (_obj.multipathInfo)
			return new HostMultipathInfo_closure(*_obj.multipathInfo);
		else
			return 0;
	case 2:
		if (_obj.plugStoreTopology)
			return new HostPlugStoreTopology_closure(*_obj.plugStoreTopology);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizescsiLun)
				return new ScsiLun_closure(*_obj.scsiLun[i]);
			else
				return 0;
		}
	case 4:
		if (_obj.scsiTopology)
			return new HostScsiTopology_closure(*_obj.scsiTopology);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void HostStorageElementInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostStorageElementInfo", context);
	update_member(update, "operationalInfo", "HostStorageOperationalInfo[]", a2s_object(_obj.operationalInfo, _obj.__sizeoperationalInfo), context);
	update("Base", "HostHardwareElementInfo", context);
	HostHardwareElementInfo_closure(dynamic_cast<const vw1__HostHardwareElementInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostStorageElementInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeoperationalInfo)
				return new HostStorageOperationalInfo_closure(*_obj.operationalInfo[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return HostHardwareElementInfo_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostStorageOperationalInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostStorageOperationalInfo", context);
	update_member(update, "property", "xsd:string", basic2str(_obj.property), context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostStorageOperationalInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostSyncFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostSyncFailedEvent", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostSyncFailedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostSystemHealthInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostSystemHealthInfo", context);
	update_member(update, "numericSensorInfo", "HostNumericSensorInfo[]", a2s_object(_obj.numericSensorInfo, _obj.__sizenumericSensorInfo), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostSystemHealthInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenumericSensorInfo)
				return new HostNumericSensorInfo_closure(*_obj.numericSensorInfo[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostSystemIdentificationInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostSystemIdentificationInfo", context);
	update_member(update, "identifierType", "ElementDescription", handle_obj_ptr(_obj.identifierType), context);
	update_member(update, "identifierValue", "xsd:string", basic2str(_obj.identifierValue), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostSystemIdentificationInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.identifierType)
			return new ElementDescription_closure(*_obj.identifierType);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostSystemInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostSystemInfo", context);
	update_member(update, "model", "xsd:string", basic2str(_obj.model), context);
	update_member_with_version(update, "otherIdentifyingInfo", "HostSystemIdentificationInfo[]", a2s_object(_obj.otherIdentifyingInfo, _obj.__sizeotherIdentifyingInfo), context, "2.5");
	update_member(update, "uuid", "xsd:string", basic2str(_obj.uuid), context);
	update_member(update, "vendor", "xsd:string", basic2str(_obj.vendor), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostSystemInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeotherIdentifyingInfo)
				return new HostSystemIdentificationInfo_closure(*_obj.otherIdentifyingInfo[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostSystemReconnectSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostSystemReconnectSpec", context);
	update_member(update, "syncState", "xsd:boolean", basic2str(_obj.syncState), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostSystemReconnectSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostSystemResourceInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostSystemResourceInfo", context);
	update_member(update, "child", "HostSystemResourceInfo[]", a2s_object(_obj.child, _obj.__sizechild), context);
	update_member(update, "config", "ResourceConfigSpec", handle_obj_ptr(_obj.config), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostSystemResourceInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizechild)
				return new HostSystemResourceInfo_closure(*_obj.child[i]);
			else
				return 0;
		}
	case 1:
		if (_obj.config)
			return new ResourceConfigSpec_closure(*_obj.config);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostTargetTransport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostTargetTransport", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostTargetTransport_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostTpmDigestInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostTpmDigestInfo", context);
	update_member(update, "pcrNumber", "xsd:int", basic2str(_obj.pcrNumber), context);
	update("Base", "HostDigestInfo", context);
	HostDigestInfo_closure(dynamic_cast<const vw1__HostDigestInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostTpmDigestInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostUnresolvedVmfsExtent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostUnresolvedVmfsExtent", context);
	update_member(update, "device", "HostScsiDiskPartition", handle_obj_ptr(_obj.device), context);
	update_member(update, "devicePath", "xsd:string", basic2str(_obj.devicePath), context);
	update_member(update, "endBlock", "xsd:int", basic2str(_obj.endBlock), context);
	update_member(update, "isHeadExtent", "xsd:boolean", basic2str(_obj.isHeadExtent), context);
	update_member(update, "ordinal", "xsd:int", basic2str(_obj.ordinal), context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update_member(update, "startBlock", "xsd:int", basic2str(_obj.startBlock), context);
	update_member(update, "vmfsUuid", "xsd:string", basic2str(_obj.vmfsUuid), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostUnresolvedVmfsExtent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.device)
			return new HostScsiDiskPartition_closure(*_obj.device);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void HostUnresolvedVmfsResignatureSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostUnresolvedVmfsResignatureSpec", context);
	update_member(update, "extentDevicePath", "xsd:string[]", a2s_basic(*_obj.extentDevicePath, _obj.__sizeextentDevicePath), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostUnresolvedVmfsResignatureSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostUnresolvedVmfsResolutionResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostUnresolvedVmfsResolutionResult", context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update_member(update, "spec", "HostUnresolvedVmfsResolutionSpec", handle_obj_ptr(_obj.spec), context);
	update_member(update, "vmfs", "HostVmfsVolume", handle_obj_ptr(_obj.vmfs), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostUnresolvedVmfsResolutionResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	case 1:
		if (_obj.spec)
			return new HostUnresolvedVmfsResolutionSpec_closure(*_obj.spec);
		else
			return 0;
	case 2:
		if (_obj.vmfs)
			return new HostVmfsVolume_closure(*_obj.vmfs);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostUnresolvedVmfsResolutionSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostUnresolvedVmfsResolutionSpec", context);
	update_member(update, "extentDevicePath", "xsd:string[]", a2s_basic(*_obj.extentDevicePath, _obj.__sizeextentDevicePath), context);
	update_member(update, "uuidResolution", "xsd:string", basic2str(_obj.uuidResolution), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostUnresolvedVmfsResolutionSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostUnresolvedVmfsVolume_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostUnresolvedVmfsVolume", context);
	update_member(update, "extent", "HostUnresolvedVmfsExtent[]", a2s_object(_obj.extent, _obj.__sizeextent), context);
	update_member(update, "resolveStatus", "HostUnresolvedVmfsVolumeResolveStatus", handle_obj_ptr(_obj.resolveStatus), context);
	update_member(update, "totalBlocks", "xsd:int", basic2str(_obj.totalBlocks), context);
	update_member(update, "vmfsLabel", "xsd:string", basic2str(_obj.vmfsLabel), context);
	update_member(update, "vmfsUuid", "xsd:string", basic2str(_obj.vmfsUuid), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostUnresolvedVmfsVolume_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeextent)
				return new HostUnresolvedVmfsExtent_closure(*_obj.extent[i]);
			else
				return 0;
		}
	case 1:
		if (_obj.resolveStatus)
			return new HostUnresolvedVmfsVolumeResolveStatus_closure(*_obj.resolveStatus);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void HostUnresolvedVmfsVolumeResolveStatus_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostUnresolvedVmfsVolumeResolveStatus", context);
	update_member(update, "incompleteExtents", "xsd:boolean", basic2str(_obj.incompleteExtents), context);
	update_member(update, "multipleCopies", "xsd:boolean", basic2str(_obj.multipleCopies), context);
	update_member(update, "resolvable", "xsd:boolean", basic2str(_obj.resolvable), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostUnresolvedVmfsVolumeResolveStatus_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostUpgradeFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostUpgradeFailedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostUpgradeFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostUserWorldSwapNotEnabledEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostUserWorldSwapNotEnabledEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostUserWorldSwapNotEnabledEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostVMotionCompatibility_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVMotionCompatibility", context);
	update_member(update, "compatibility", "xsd:string[]", a2s_basic(*_obj.compatibility, _obj.__sizecompatibility), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVMotionCompatibility_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostVMotionConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVMotionConfig", context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "vmotionNicKey", "xsd:string", basic2str(_obj.vmotionNicKey), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVMotionConfig_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostVMotionInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVMotionInfo", context);
	update_member(update, "ipConfig", "HostIpConfig", handle_obj_ptr(_obj.ipConfig), context);
	update_member(update, "netConfig", "HostVMotionNetConfig", handle_obj_ptr(_obj.netConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVMotionInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.ipConfig)
			return new HostIpConfig_closure(*_obj.ipConfig);
		else
			return 0;
	case 1:
		if (_obj.netConfig)
			return new HostVMotionNetConfig_closure(*_obj.netConfig);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostVMotionNetConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVMotionNetConfig", context);
	update_member(update, "candidateVnic", "HostVirtualNic[]", a2s_object(_obj.candidateVnic, _obj.__sizecandidateVnic), context);
	update_member(update, "selectedVnic", "xsd:string", basic2str(_obj.selectedVnic), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVMotionNetConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecandidateVnic)
				return new HostVirtualNic_closure(*_obj.candidateVnic[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostVfatVolume_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVfatVolume", context);
	update("Base", "HostFileSystemVolume", context);
	HostFileSystemVolume_closure(dynamic_cast<const vw1__HostFileSystemVolume&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVfatVolume_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostVirtualNic_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualNic", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "port", "xsd:string", basic2str(_obj.port), context);
	update_member(update, "portgroup", "xsd:string", basic2str(_obj.portgroup), context);
	update_member(update, "spec", "HostVirtualNicSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualNic_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 4:
		if (_obj.spec)
			return new HostVirtualNicSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void HostVirtualNicConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualNicConfig", context);
	update_member(update, "changeOperation", "xsd:string", basic2str(_obj.changeOperation), context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update_member(update, "portgroup", "xsd:string", basic2str(_obj.portgroup), context);
	update_member(update, "spec", "HostVirtualNicSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualNicConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		if (_obj.spec)
			return new HostVirtualNicSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostVirtualNicConnection_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualNicConnection", context);
	update_member(update, "dvPort", "DistributedVirtualSwitchPortConnection", handle_obj_ptr(_obj.dvPort), context);
	update_member(update, "portgroup", "xsd:string", basic2str(_obj.portgroup), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualNicConnection_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.dvPort)
			return new DistributedVirtualSwitchPortConnection_closure(*_obj.dvPort);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostVirtualNicManagerInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualNicManagerInfo", context);
	update_member(update, "netConfig", "VirtualNicManagerNetConfig[]", a2s_object(_obj.netConfig, _obj.__sizenetConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualNicManagerInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenetConfig)
				return new VirtualNicManagerNetConfig_closure(*_obj.netConfig[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostVirtualNicManagerNicTypeSelection_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualNicManagerNicTypeSelection", context);
	update_member(update, "nicType", "xsd:string[]", a2s_basic(*_obj.nicType, _obj.__sizenicType), context);
	update_member(update, "vnic", "HostVirtualNicConnection", handle_obj_ptr(_obj.vnic), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualNicManagerNicTypeSelection_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.vnic)
			return new HostVirtualNicConnection_closure(*_obj.vnic);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostVirtualNicSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualNicSpec", context);
	update_member_with_version(update, "distributedVirtualPort", "DistributedVirtualSwitchPortConnection", handle_obj_ptr(_obj.distributedVirtualPort), context, "4.0");
	update_member(update, "ip", "HostIpConfig", handle_obj_ptr(_obj.ip), context);
	update_member(update, "mac", "xsd:string", basic2str(_obj.mac), context);
	update_member_with_version(update, "mtu", "xsd:int", basic2str(_obj.mtu), context, "4.0");
	update_member_with_version(update, "portgroup", "xsd:string", basic2str(_obj.portgroup), context, "4.0");
	update_member_with_version(update, "tsoEnabled", "xsd:boolean", basic2str(_obj.tsoEnabled), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualNicSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.distributedVirtualPort)
			return new DistributedVirtualSwitchPortConnection_closure(*_obj.distributedVirtualPort);
		else
			return 0;
	case 1:
		if (_obj.ip)
			return new HostIpConfig_closure(*_obj.ip);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void HostVirtualSwitch_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualSwitch", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member_with_version(update, "mtu", "xsd:int", basic2str(_obj.mtu), context, "2.5");
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "numPorts", "xsd:int", basic2str(_obj.numPorts), context);
	update_member(update, "numPortsAvailable", "xsd:int", basic2str(_obj.numPortsAvailable), context);
	update_member(update, "pnic", "xsd:string[]", a2s_basic(*_obj.pnic, _obj.__sizepnic), context);
	update_member(update, "portgroup", "xsd:string[]", a2s_basic(*_obj.portgroup, _obj.__sizeportgroup), context);
	update_member(update, "spec", "HostVirtualSwitchSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualSwitch_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 7:
		if (_obj.spec)
			return new HostVirtualSwitchSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void HostVirtualSwitchAutoBridge_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualSwitchAutoBridge", context);
	update_member_with_version(update, "excludedNicDevice", "xsd:string[]", a2s_basic(*_obj.excludedNicDevice, _obj.__sizeexcludedNicDevice), context, "2.5");
	update("Base", "HostVirtualSwitchBridge", context);
	HostVirtualSwitchBridge_closure(dynamic_cast<const vw1__HostVirtualSwitchBridge&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualSwitchAutoBridge_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostVirtualSwitchBeaconConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualSwitchBeaconConfig", context);
	update_member(update, "interval", "xsd:int", basic2str(_obj.interval), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualSwitchBeaconConfig_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostVirtualSwitchBondBridge_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualSwitchBondBridge", context);
	update_member(update, "beacon", "HostVirtualSwitchBeaconConfig", handle_obj_ptr(_obj.beacon), context);
	update_member_with_version(update, "linkDiscoveryProtocolConfig", "LinkDiscoveryProtocolConfig", handle_obj_ptr(_obj.linkDiscoveryProtocolConfig), context, "4.0");
	update_member(update, "nicDevice", "xsd:string[]", a2s_basic(*_obj.nicDevice, _obj.__sizenicDevice), context);
	update("Base", "HostVirtualSwitchBridge", context);
	HostVirtualSwitchBridge_closure(dynamic_cast<const vw1__HostVirtualSwitchBridge&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualSwitchBondBridge_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.beacon)
			return new HostVirtualSwitchBeaconConfig_closure(*_obj.beacon);
		else
			return 0;
	case 1:
		if (_obj.linkDiscoveryProtocolConfig)
			return new LinkDiscoveryProtocolConfig_closure(*_obj.linkDiscoveryProtocolConfig);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostVirtualSwitchBridge_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostVirtualSwitchBridge_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualSwitchBridge", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualSwitchBridge_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostVirtualSwitchConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualSwitchConfig", context);
	update_member(update, "changeOperation", "xsd:string", basic2str(_obj.changeOperation), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "spec", "HostVirtualSwitchSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualSwitchConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.spec)
			return new HostVirtualSwitchSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostVirtualSwitchSimpleBridge_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualSwitchSimpleBridge", context);
	update_member(update, "nicDevice", "xsd:string", basic2str(_obj.nicDevice), context);
	update("Base", "HostVirtualSwitchBridge", context);
	HostVirtualSwitchBridge_closure(dynamic_cast<const vw1__HostVirtualSwitchBridge&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualSwitchSimpleBridge_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostVirtualSwitchSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualSwitchSpec", context);
	update_member(update, "bridge", "HostVirtualSwitchBridge", handle_obj_ptr(_obj.bridge), context);
	update_member_with_version(update, "mtu", "xsd:int", basic2str(_obj.mtu), context, "2.5");
	update_member(update, "numPorts", "xsd:int", basic2str(_obj.numPorts), context);
	update_member(update, "policy", "HostNetworkPolicy", handle_obj_ptr(_obj.policy), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualSwitchSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.bridge)
			return new HostVirtualSwitchBridge_closure(*_obj.bridge);
		else
			return 0;
	case 3:
		if (_obj.policy)
			return new HostNetworkPolicy_closure(*_obj.policy);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostVmciAccessManagerAccessSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVmciAccessManagerAccessSpec", context);
	update_member(update, "mode", "xsd:string", basic2str(_obj.mode), context);
	update_member(update, "services", "xsd:string[]", a2s_basic(*_obj.services, _obj.__sizeservices), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVmciAccessManagerAccessSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HostVmfsRescanResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVmfsRescanResult", context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVmfsRescanResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	case 1:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostVmfsSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVmfsSpec", context);
	update_member(update, "blockSizeMb", "xsd:int", basic2str(_obj.blockSizeMb), context);
	update_member(update, "extent", "HostScsiDiskPartition", handle_obj_ptr(_obj.extent), context);
	update_member(update, "majorVersion", "xsd:int", basic2str(_obj.majorVersion), context);
	update_member(update, "volumeName", "xsd:string", basic2str(_obj.volumeName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVmfsSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.extent)
			return new HostScsiDiskPartition_closure(*_obj.extent);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostVmfsVolume_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVmfsVolume", context);
	update_member(update, "blockSizeMb", "xsd:int", basic2str(_obj.blockSizeMb), context);
	update_member(update, "extent", "HostScsiDiskPartition[]", a2s_object(_obj.extent, _obj.__sizeextent), context);
	update_member_with_version(update, "forceMountedInfo", "HostForceMountedInfo", handle_obj_ptr(_obj.forceMountedInfo), context, "4.0");
	update_member(update, "majorVersion", "xsd:int", basic2str(_obj.majorVersion), context);
	update_member(update, "maxBlocks", "xsd:int", basic2str(_obj.maxBlocks), context);
	update_member_with_version(update, "ssd", "xsd:boolean", basic2str(_obj.ssd), context, "5.0");
	update_member(update, "uuid", "xsd:string", basic2str(_obj.uuid), context);
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update_member(update, "vmfsUpgradable", "xsd:boolean", basic2str(_obj.vmfsUpgradable), context);
	update("Base", "HostFileSystemVolume", context);
	HostFileSystemVolume_closure(dynamic_cast<const vw1__HostFileSystemVolume&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVmfsVolume_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeextent)
				return new HostScsiDiskPartition_closure(*_obj.extent[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.forceMountedInfo)
			return new HostForceMountedInfo_closure(*_obj.forceMountedInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostFileSystemVolume_closure(_obj).get_sub_closure(((prop_index - 9) << 16) + arr_index);
	}
	return 0;
}

void HostVnicConnectedToCustomizedDVPortEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVnicConnectedToCustomizedDVPortEvent", context);
	update_member(update, "vnic", "VnicPortArgument", handle_obj_ptr(_obj.vnic), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVnicConnectedToCustomizedDVPortEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.vnic)
			return new VnicPortArgument_closure(*_obj.vnic);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostWwnChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostWwnChangedEvent", context);
	update_member(update, "newNodeWwns", "xsd:long[]", a2s_basic(_obj.newNodeWwns, _obj.__sizenewNodeWwns), context);
	update_member(update, "newPortWwns", "xsd:long[]", a2s_basic(_obj.newPortWwns, _obj.__sizenewPortWwns), context);
	update_member(update, "oldNodeWwns", "xsd:long[]", a2s_basic(_obj.oldNodeWwns, _obj.__sizeoldNodeWwns), context);
	update_member(update, "oldPortWwns", "xsd:long[]", a2s_basic(_obj.oldPortWwns, _obj.__sizeoldPortWwns), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostWwnChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostWwnConflictEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostWwnConflictEvent", context);
	update_member(update, "conflictedHosts", "HostEventArgument[]", a2s_object(_obj.conflictedHosts, _obj.__sizeconflictedHosts), context);
	update_member(update, "conflictedVms", "VmEventArgument[]", a2s_object(_obj.conflictedVms, _obj.__sizeconflictedVms), context);
	update_member(update, "wwn", "xsd:long", basic2str(_obj.wwn), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostWwnConflictEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeconflictedHosts)
				return new HostEventArgument_closure(*_obj.conflictedHosts[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeconflictedVms)
				return new VmEventArgument_closure(*_obj.conflictedVms[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void HourlyTaskScheduler_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HourlyTaskScheduler", context);
	update_member(update, "minute", "xsd:int", basic2str(_obj.minute), context);
	update("Base", "RecurrentTaskScheduler", context);
	RecurrentTaskScheduler_closure(dynamic_cast<const vw1__RecurrentTaskScheduler&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HourlyTaskScheduler_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HttpNfcLeaseDatastoreLeaseInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HttpNfcLeaseDatastoreLeaseInfo", context);
	update_member(update, "datastoreKey", "xsd:string", basic2str(_obj.datastoreKey), context);
	update_member(update, "hosts", "HttpNfcLeaseHostInfo[]", a2s_object(_obj.hosts, _obj.__sizehosts), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HttpNfcLeaseDatastoreLeaseInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehosts)
				return new HttpNfcLeaseHostInfo_closure(*_obj.hosts[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HttpNfcLeaseDeviceUrl_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HttpNfcLeaseDeviceUrl", context);
	update_member_with_version(update, "datastoreKey", "xsd:string", basic2str(_obj.datastoreKey), context, "4.1");
	update_member_with_version(update, "disk", "xsd:boolean", basic2str(_obj.disk), context, "4.1");
	update_member_with_version(update, "fileSize", "xsd:long", basic2str(_obj.fileSize), context, "4.1");
	update_member(update, "importKey", "xsd:string", basic2str(_obj.importKey), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "sslThumbprint", "xsd:string", basic2str(_obj.sslThumbprint), context);
	update_member_with_version(update, "targetId", "xsd:string", basic2str(_obj.targetId), context, "4.1");
	update_member(update, "url", "xsd:string", basic2str(_obj.url), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HttpNfcLeaseDeviceUrl_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HttpNfcLeaseHostInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HttpNfcLeaseHostInfo", context);
	update_member(update, "sslThumbprint", "xsd:string", basic2str(_obj.sslThumbprint), context);
	update_member(update, "url", "xsd:string", basic2str(_obj.url), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HttpNfcLeaseHostInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HttpNfcLeaseInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HttpNfcLeaseInfo", context);
	update_member(update, "deviceUrl", "HttpNfcLeaseDeviceUrl[]", a2s_object(_obj.deviceUrl, _obj.__sizedeviceUrl), context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member_with_version(update, "hostMap", "HttpNfcLeaseDatastoreLeaseInfo[]", a2s_object(_obj.hostMap, _obj.__sizehostMap), context, "4.1");
	update_member(update, "lease", "HttpNfcLease", handle_obj_ptr(_obj.lease), context);
	update_member(update, "leaseTimeout", "xsd:int", basic2str(_obj.leaseTimeout), context);
	update_member(update, "totalDiskCapacityInKB", "xsd:long", basic2str(_obj.totalDiskCapacityInKB), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HttpNfcLeaseInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedeviceUrl)
				return new HttpNfcLeaseDeviceUrl_closure(*_obj.deviceUrl[i]);
			else
				return 0;
		}
	case 1:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehostMap)
				return new HttpNfcLeaseDatastoreLeaseInfo_closure(*_obj.hostMap[i]);
			else
				return 0;
		}
	case 3:
		return _obj.lease? 
			get_closure_from_mor(HttpNfcLease(_obj.lease)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void HttpNfcLeaseManifestEntry_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HttpNfcLeaseManifestEntry", context);
	update_member(update, "capacity", "xsd:long", basic2str(_obj.capacity), context);
	update_member(update, "disk", "xsd:boolean", basic2str(_obj.disk), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "populatedSize", "xsd:long", basic2str(_obj.populatedSize), context);
	update_member(update, "sha1", "xsd:string", basic2str(_obj.sha1), context);
	update_member(update, "size", "xsd:long", basic2str(_obj.size), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HttpNfcLeaseManifestEntry_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IScsiBootFailureEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IScsiBootFailureEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IScsiBootFailureEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ImportSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ImportSpec", context);
	update_member(update, "entityConfig", "VAppEntityConfigInfo", handle_obj_ptr(_obj.entityConfig), context);
	update_member_with_version(update, "instantiationOst", "OvfConsumerOstNode", handle_obj_ptr(_obj.instantiationOst), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ImportSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entityConfig)
			return new VAppEntityConfigInfo_closure(*_obj.entityConfig);
		else
			return 0;
	case 1:
		if (_obj.instantiationOst)
			return new OvfConsumerOstNode_closure(*_obj.instantiationOst);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void IncorrectHostInformationEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IncorrectHostInformationEvent", context);
	update("Base", "LicenseEvent", context);
	LicenseEvent_closure(dynamic_cast<const vw1__LicenseEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IncorrectHostInformationEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InfoUpgradeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InfoUpgradeEvent", context);
	update("Base", "UpgradeEvent", context);
	UpgradeEvent_closure(dynamic_cast<const vw1__UpgradeEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InfoUpgradeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InheritablePolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InheritablePolicy", context);
	update_member(update, "inherited", "xsd:boolean", basic2str(_obj.inherited), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InheritablePolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InsufficientFailoverResourcesEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InsufficientFailoverResourcesEvent", context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InsufficientFailoverResourcesEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IntOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IntOption", context);
	update_member(update, "defaultValue", "xsd:int", basic2str(_obj.defaultValue), context);
	update_member(update, "max_", "xsd:int", basic2str(_obj.max_), context);
	update_member(update, "min_", "xsd:int", basic2str(_obj.min_), context);
	update("Base", "OptionType", context);
	OptionType_closure(dynamic_cast<const vw1__OptionType&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IntOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IntPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IntPolicy", context);
	update_member(update, "value", "xsd:int", basic2str(_obj.value), context);
	update("Base", "InheritablePolicy", context);
	InheritablePolicy_closure(dynamic_cast<const vw1__InheritablePolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IntPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidEditionEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidEditionEvent", context);
	update_member(update, "feature", "xsd:string", basic2str(_obj.feature), context);
	update("Base", "LicenseEvent", context);
	LicenseEvent_closure(dynamic_cast<const vw1__LicenseEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidEditionEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InventoryDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InventoryDescription", context);
	update_member(update, "numClusters", "xsd:int", basic2str(_obj.numClusters), context);
	update_member(update, "numCpuDev", "xsd:int", basic2str(_obj.numCpuDev), context);
	update_member(update, "numDiskDev", "xsd:int", basic2str(_obj.numDiskDev), context);
	update_member(update, "numHosts", "xsd:int", basic2str(_obj.numHosts), context);
	update_member(update, "numNetDev", "xsd:int", basic2str(_obj.numNetDev), context);
	update_member(update, "numResourcePools", "xsd:int", basic2str(_obj.numResourcePools), context);
	update_member(update, "numvCpuDev", "xsd:int", basic2str(_obj.numvCpuDev), context);
	update_member(update, "numvDiskDev", "xsd:int", basic2str(_obj.numvDiskDev), context);
	update_member(update, "numVirtualMachines", "xsd:int", basic2str(_obj.numVirtualMachines), context);
	update_member(update, "numvNetDev", "xsd:int", basic2str(_obj.numvNetDev), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InventoryDescription_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IpAddressProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IpAddressProfile", context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IpAddressProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IpPool_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IpPool", context);
	update_member(update, "dnsDomain", "xsd:string", basic2str(_obj.dnsDomain), context);
	update_member(update, "dnsSearchPath", "xsd:string", basic2str(_obj.dnsSearchPath), context);
	update_member(update, "hostPrefix", "xsd:string", basic2str(_obj.hostPrefix), context);
	update_member(update, "httpProxy", "xsd:string", basic2str(_obj.httpProxy), context);
	update_member(update, "id", "xsd:int", basic2str(_obj.id), context);
	update_member(update, "ipv4Config", "IpPoolIpPoolConfigInfo", handle_obj_ptr(_obj.ipv4Config), context);
	update_member(update, "ipv6Config", "IpPoolIpPoolConfigInfo", handle_obj_ptr(_obj.ipv6Config), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "networkAssociation", "IpPoolAssociation[]", a2s_object(_obj.networkAssociation, _obj.__sizenetworkAssociation), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IpPool_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 5:
		if (_obj.ipv4Config)
			return new IpPoolIpPoolConfigInfo_closure(*_obj.ipv4Config);
		else
			return 0;
	case 6:
		if (_obj.ipv6Config)
			return new IpPoolIpPoolConfigInfo_closure(*_obj.ipv6Config);
		else
			return 0;
	case 8:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenetworkAssociation)
				return new IpPoolAssociation_closure(*_obj.networkAssociation[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 9) << 16) + arr_index);
	}
	return 0;
}

void IpPoolAssociation_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IpPoolAssociation", context);
	update_member(update, "network", "Network", handle_obj_ptr(_obj.network), context);
	update_member(update, "networkName", "xsd:string", basic2str(_obj.networkName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IpPoolAssociation_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.network? 
			get_closure_from_mor(Network(_obj.network)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void IpPoolIpPoolConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IpPoolIpPoolConfigInfo", context);
	update_member(update, "dhcpServerAvailable", "xsd:boolean", basic2str(_obj.dhcpServerAvailable), context);
	update_member(update, "dns", "xsd:string[]", a2s_basic(*_obj.dns, _obj.__sizedns), context);
	update_member(update, "gateway", "xsd:string", basic2str(_obj.gateway), context);
	update_member(update, "ipPoolEnabled", "xsd:boolean", basic2str(_obj.ipPoolEnabled), context);
	update_member(update, "netmask", "xsd:string", basic2str(_obj.netmask), context);
	update_member(update, "range", "xsd:string", basic2str(_obj.range), context);
	update_member(update, "subnetAddress", "xsd:string", basic2str(_obj.subnetAddress), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IpPoolIpPoolConfigInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IpRouteProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IpRouteProfile", context);
	update_member(update, "staticRoute", "StaticRouteProfile[]", a2s_object(_obj.staticRoute, _obj.__sizestaticRoute), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IpRouteProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizestaticRoute)
				return new StaticRouteProfile_closure(*_obj.staticRoute[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ApplyProfile_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void IscsiDependencyEntity_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiDependencyEntity", context);
	update_member(update, "pnicDevice", "xsd:string", basic2str(_obj.pnicDevice), context);
	update_member(update, "vmhbaName", "xsd:string", basic2str(_obj.vmhbaName), context);
	update_member(update, "vnicDevice", "xsd:string", basic2str(_obj.vnicDevice), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiDependencyEntity_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IscsiMigrationDependency_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiMigrationDependency", context);
	update_member(update, "dependency", "IscsiDependencyEntity[]", a2s_object(_obj.dependency, _obj.__sizedependency), context);
	update_member(update, "disallowReason", "IscsiStatus", handle_obj_ptr(_obj.disallowReason), context);
	update_member(update, "migrationAllowed", "xsd:boolean", basic2str(_obj.migrationAllowed), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiMigrationDependency_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedependency)
				return new IscsiDependencyEntity_closure(*_obj.dependency[i]);
			else
				return 0;
		}
	case 1:
		if (_obj.disallowReason)
			return new IscsiStatus_closure(*_obj.disallowReason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void IscsiPortInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiPortInfo", context);
	update_member(update, "complianceStatus", "IscsiStatus", handle_obj_ptr(_obj.complianceStatus), context);
	update_member(update, "pathStatus", "xsd:string", basic2str(_obj.pathStatus), context);
	update_member(update, "pnic", "PhysicalNic", handle_obj_ptr(_obj.pnic), context);
	update_member(update, "pnicDevice", "xsd:string", basic2str(_obj.pnicDevice), context);
	update_member(update, "portgroupKey", "xsd:string", basic2str(_obj.portgroupKey), context);
	update_member(update, "portgroupName", "xsd:string", basic2str(_obj.portgroupName), context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update_member(update, "switchName", "xsd:string", basic2str(_obj.switchName), context);
	update_member(update, "switchUuid", "xsd:string", basic2str(_obj.switchUuid), context);
	update_member(update, "vnic", "HostVirtualNic", handle_obj_ptr(_obj.vnic), context);
	update_member(update, "vnicDevice", "xsd:string", basic2str(_obj.vnicDevice), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiPortInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.complianceStatus)
			return new IscsiStatus_closure(*_obj.complianceStatus);
		else
			return 0;
	case 2:
		if (_obj.pnic)
			return new PhysicalNic_closure(*_obj.pnic);
		else
			return 0;
	case 9:
		if (_obj.vnic)
			return new HostVirtualNic_closure(*_obj.vnic);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void IscsiStatus_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiStatus", context);
	update_member(update, "reason", "LocalizedMethodFault[]", a2s_object(_obj.reason, _obj.__sizereason), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiStatus_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizereason)
				return new LocalizedMethodFault_closure(*_obj.reason[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void IsoImageFileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IsoImageFileInfo", context);
	update("Base", "FileInfo", context);
	FileInfo_closure(dynamic_cast<const vw1__FileInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IsoImageFileInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IsoImageFileQuery_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IsoImageFileQuery", context);
	update("Base", "FileQuery", context);
	FileQuery_closure(dynamic_cast<const vw1__FileQuery&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IsoImageFileQuery_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void KernelModuleInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "KernelModuleInfo", context);
	update_member(update, "bssSection", "KernelModuleSectionInfo", handle_obj_ptr(_obj.bssSection), context);
	update_member(update, "dataSection", "KernelModuleSectionInfo", handle_obj_ptr(_obj.dataSection), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "filename", "xsd:string", basic2str(_obj.filename), context);
	update_member(update, "id", "xsd:int", basic2str(_obj.id), context);
	update_member(update, "loaded", "xsd:boolean", basic2str(_obj.loaded), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "optionString", "xsd:string", basic2str(_obj.optionString), context);
	update_member(update, "readOnlySection", "KernelModuleSectionInfo", handle_obj_ptr(_obj.readOnlySection), context);
	update_member(update, "textSection", "KernelModuleSectionInfo", handle_obj_ptr(_obj.textSection), context);
	update_member(update, "useCount", "xsd:int", basic2str(_obj.useCount), context);
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update_member(update, "writableSection", "KernelModuleSectionInfo", handle_obj_ptr(_obj.writableSection), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* KernelModuleInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.bssSection)
			return new KernelModuleSectionInfo_closure(*_obj.bssSection);
		else
			return 0;
	case 1:
		if (_obj.dataSection)
			return new KernelModuleSectionInfo_closure(*_obj.dataSection);
		else
			return 0;
	case 8:
		if (_obj.readOnlySection)
			return new KernelModuleSectionInfo_closure(*_obj.readOnlySection);
		else
			return 0;
	case 9:
		if (_obj.textSection)
			return new KernelModuleSectionInfo_closure(*_obj.textSection);
		else
			return 0;
	case 12:
		if (_obj.writableSection)
			return new KernelModuleSectionInfo_closure(*_obj.writableSection);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 13) << 16) + arr_index);
	}
	return 0;
}

void KernelModuleSectionInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "KernelModuleSectionInfo", context);
	update_member(update, "address", "xsd:long", basic2str(_obj.address), context);
	update_member(update, "length", "xsd:int", basic2str(_obj.length), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* KernelModuleSectionInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void KeyAnyValue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "KeyAnyValue", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "value", "xsd:anyType", basic2str(_obj.value), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* KeyAnyValue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void KeyValue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "KeyValue", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* KeyValue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseAssignmentManagerLicenseAssignment_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseAssignmentManagerLicenseAssignment", context);
	update_member(update, "assignedLicense", "LicenseManagerLicenseInfo", handle_obj_ptr(_obj.assignedLicense), context);
	update_member(update, "entityDisplayName", "xsd:string", basic2str(_obj.entityDisplayName), context);
	update_member(update, "entityId", "xsd:string", basic2str(_obj.entityId), context);
	update_member(update, "properties", "KeyAnyValue[]", a2s_object(_obj.properties, _obj.__sizeproperties), context);
	update_member(update, "scope", "xsd:string", basic2str(_obj.scope), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseAssignmentManagerLicenseAssignment_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.assignedLicense)
			return new LicenseManagerLicenseInfo_closure(*_obj.assignedLicense);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeproperties)
				return new KeyAnyValue_closure(*_obj.properties[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void LicenseAvailabilityInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseAvailabilityInfo", context);
	update_member(update, "available", "xsd:int", basic2str(_obj.available), context);
	update_member(update, "feature", "LicenseFeatureInfo", handle_obj_ptr(_obj.feature), context);
	update_member(update, "total", "xsd:int", basic2str(_obj.total), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseAvailabilityInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.feature)
			return new LicenseFeatureInfo_closure(*_obj.feature);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void LicenseDiagnostics_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseDiagnostics", context);
	update_member(update, "lastStatusUpdate", "xsd:dateTime", basic2str(_obj.lastStatusUpdate), context);
	update_member(update, "licenseFeatureUnknowns", "xsd:string", basic2str(_obj.licenseFeatureUnknowns), context);
	update_member(update, "licenseRequestFailures", "xsd:string", basic2str(_obj.licenseRequestFailures), context);
	update_member(update, "licenseRequests", "xsd:string", basic2str(_obj.licenseRequests), context);
	update_member(update, "opFailureMessage", "xsd:string", basic2str(_obj.opFailureMessage), context);
	update_member(update, "opState", "LicenseManagerState", handle_obj(_obj.opState), context);
	update_member(update, "sourceLastChanged", "xsd:dateTime", basic2str(_obj.sourceLastChanged), context);
	update_member(update, "sourceLatency", "xsd:float", basic2str(_obj.sourceLatency), context);
	update_member(update, "sourceLost", "xsd:string", basic2str(_obj.sourceLost), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseDiagnostics_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseEvent", context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseExpiredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseExpiredEvent", context);
	update_member(update, "feature", "LicenseFeatureInfo", handle_obj_ptr(_obj.feature), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseExpiredEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.feature)
			return new LicenseFeatureInfo_closure(*_obj.feature);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return Event_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void LicenseFeatureInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseFeatureInfo", context);
	update_member(update, "costUnit", "xsd:string", basic2str(_obj.costUnit), context);
	update_member_with_version(update, "dependentKey", "xsd:string[]", a2s_basic(*_obj.dependentKey, _obj.__sizedependentKey), context, "2.5");
	update_member_with_version(update, "edition", "xsd:boolean", basic2str(_obj.edition), context, "2.5");
	update_member_with_version(update, "expiresOn", "xsd:dateTime", basic2str(_obj.expiresOn), context, "2.5");
	update_member_with_version(update, "featureDescription", "xsd:string", basic2str(_obj.featureDescription), context, "2.5");
	update_member(update, "featureName", "xsd:string", basic2str(_obj.featureName), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member_with_version(update, "sourceRestriction", "xsd:string", basic2str(_obj.sourceRestriction), context, "2.5");
	update_member(update, "state", "LicenseFeatureInfoState", handle_obj_ptr(_obj.state), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseFeatureInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseManagerEvaluationInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseManagerEvaluationInfo", context);
	update_member(update, "properties", "KeyAnyValue[]", a2s_object(_obj.properties, _obj.__sizeproperties), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseManagerEvaluationInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeproperties)
				return new KeyAnyValue_closure(*_obj.properties[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void LicenseManagerLicenseInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseManagerLicenseInfo", context);
	update_member(update, "costUnit", "xsd:string", basic2str(_obj.costUnit), context);
	update_member(update, "editionKey", "xsd:string", basic2str(_obj.editionKey), context);
	update_member(update, "labels", "KeyValue[]", a2s_object(_obj.labels, _obj.__sizelabels), context);
	update_member(update, "licenseKey", "xsd:string", basic2str(_obj.licenseKey), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "properties", "KeyAnyValue[]", a2s_object(_obj.properties, _obj.__sizeproperties), context);
	update_member(update, "total", "xsd:int", basic2str(_obj.total), context);
	update_member(update, "used", "xsd:int", basic2str(_obj.used), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseManagerLicenseInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizelabels)
				return new KeyValue_closure(*_obj.labels[i]);
			else
				return 0;
		}
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeproperties)
				return new KeyAnyValue_closure(*_obj.properties[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void LicenseNonComplianceEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseNonComplianceEvent", context);
	update_member(update, "url", "xsd:string", basic2str(_obj.url), context);
	update("Base", "LicenseEvent", context);
	LicenseEvent_closure(dynamic_cast<const vw1__LicenseEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseNonComplianceEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseReservationInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseReservationInfo", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "required", "xsd:int", basic2str(_obj.required), context);
	update_member(update, "state", "LicenseReservationInfoState", handle_obj(_obj.state), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseReservationInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseRestrictedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseRestrictedEvent", context);
	update("Base", "LicenseEvent", context);
	LicenseEvent_closure(dynamic_cast<const vw1__LicenseEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseRestrictedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseServerAvailableEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseServerAvailableEvent", context);
	update_member(update, "licenseServer", "xsd:string", basic2str(_obj.licenseServer), context);
	update("Base", "LicenseEvent", context);
	LicenseEvent_closure(dynamic_cast<const vw1__LicenseEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseServerAvailableEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseServerSource_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseServerSource", context);
	update_member(update, "licenseServer", "xsd:string", basic2str(_obj.licenseServer), context);
	update("Base", "LicenseSource", context);
	LicenseSource_closure(dynamic_cast<const vw1__LicenseSource&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseServerSource_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseServerUnavailableEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseServerUnavailableEvent", context);
	update_member(update, "licenseServer", "xsd:string", basic2str(_obj.licenseServer), context);
	update("Base", "LicenseEvent", context);
	LicenseEvent_closure(dynamic_cast<const vw1__LicenseEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseServerUnavailableEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseSource_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseSource", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseSource_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseUsageInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseUsageInfo", context);
	update_member(update, "featureInfo", "LicenseFeatureInfo[]", a2s_object(_obj.featureInfo, _obj.__sizefeatureInfo), context);
	update_member(update, "reservationInfo", "LicenseReservationInfo[]", a2s_object(_obj.reservationInfo, _obj.__sizereservationInfo), context);
	update_member(update, "source", "LicenseSource", handle_obj_ptr(_obj.source), context);
	update_member(update, "sourceAvailable", "xsd:boolean", basic2str(_obj.sourceAvailable), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseUsageInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefeatureInfo)
				return new LicenseFeatureInfo_closure(*_obj.featureInfo[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizereservationInfo)
				return new LicenseReservationInfo_closure(*_obj.reservationInfo[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.source)
			return new LicenseSource_closure(*_obj.source);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void LinkDiscoveryProtocolConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LinkDiscoveryProtocolConfig", context);
	update_member(update, "operation", "xsd:string", basic2str(_obj.operation), context);
	update_member(update, "protocol", "xsd:string", basic2str(_obj.protocol), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LinkDiscoveryProtocolConfig_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LinkLayerDiscoveryProtocolInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LinkLayerDiscoveryProtocolInfo", context);
	update_member(update, "chassisId", "xsd:string", basic2str(_obj.chassisId), context);
	update_member(update, "parameter", "KeyAnyValue[]", a2s_object(_obj.parameter, _obj.__sizeparameter), context);
	update_member(update, "portId", "xsd:string", basic2str(_obj.portId), context);
	update_member(update, "timeToLive", "xsd:int", basic2str(_obj.timeToLive), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LinkLayerDiscoveryProtocolInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeparameter)
				return new KeyAnyValue_closure(*_obj.parameter[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void LinkProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LinkProfile", context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LinkProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LocalDatastoreCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LocalDatastoreCreatedEvent", context);
	update_member(update, "datastore", "DatastoreEventArgument", handle_obj_ptr(_obj.datastore), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LocalDatastoreCreatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.datastore)
			return new DatastoreEventArgument_closure(*_obj.datastore);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void LocalDatastoreInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LocalDatastoreInfo", context);
	update_member(update, "path", "xsd:string", basic2str(_obj.path), context);
	update("Base", "DatastoreInfo", context);
	DatastoreInfo_closure(dynamic_cast<const vw1__DatastoreInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LocalDatastoreInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LocalLicenseSource_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LocalLicenseSource", context);
	update_member(update, "licenseKeys", "xsd:string", basic2str(_obj.licenseKeys), context);
	update("Base", "LicenseSource", context);
	LicenseSource_closure(dynamic_cast<const vw1__LicenseSource&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LocalLicenseSource_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LocalTSMEnabledEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LocalTSMEnabledEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LocalTSMEnabledEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LocalizableMessage_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LocalizableMessage", context);
	update_member(update, "arg", "KeyAnyValue[]", a2s_object(_obj.arg, _obj.__sizearg), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "message", "xsd:string", basic2str(_obj.message), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LocalizableMessage_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizearg)
				return new KeyAnyValue_closure(*_obj.arg[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void LocalizationManagerMessageCatalog_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LocalizationManagerMessageCatalog", context);
	update_member(update, "catalogName", "xsd:string", basic2str(_obj.catalogName), context);
	update_member(update, "catalogUri", "xsd:string", basic2str(_obj.catalogUri), context);
	update_member(update, "lastModified", "xsd:dateTime", basic2str(_obj.lastModified), context);
	update_member(update, "locale", "xsd:string", basic2str(_obj.locale), context);
	update_member(update, "md5sum", "xsd:string", basic2str(_obj.md5sum), context);
	update_member(update, "moduleName", "xsd:string", basic2str(_obj.moduleName), context);
	update_member_with_version(update, "version", "xsd:string", basic2str(_obj.version), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LocalizationManagerMessageCatalog_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LocalizedMethodFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LocalizedMethodFault", context);
	update_member(update, "fault", "MethodFault", handle_obj_ptr(_obj.fault), context);
	update_member(update, "localizedMessage", "xsd:string", basic2str(_obj.localizedMessage), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LocalizedMethodFault_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new MethodFault_closure(*_obj.fault);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void LockerMisconfiguredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LockerMisconfiguredEvent", context);
	update_member(update, "datastore", "DatastoreEventArgument", handle_obj_ptr(_obj.datastore), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LockerMisconfiguredEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.datastore)
			return new DatastoreEventArgument_closure(*_obj.datastore);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return Event_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void LockerReconfiguredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LockerReconfiguredEvent", context);
	update_member(update, "newDatastore", "DatastoreEventArgument", handle_obj_ptr(_obj.newDatastore), context);
	update_member(update, "oldDatastore", "DatastoreEventArgument", handle_obj_ptr(_obj.oldDatastore), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LockerReconfiguredEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.newDatastore)
			return new DatastoreEventArgument_closure(*_obj.newDatastore);
		else
			return 0;
	case 1:
		if (_obj.oldDatastore)
			return new DatastoreEventArgument_closure(*_obj.oldDatastore);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return Event_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void LongOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LongOption", context);
	update_member(update, "defaultValue", "xsd:long", basic2str(_obj.defaultValue), context);
	update_member(update, "max_", "xsd:long", basic2str(_obj.max_), context);
	update_member(update, "min_", "xsd:long", basic2str(_obj.min_), context);
	update("Base", "OptionType", context);
	OptionType_closure(dynamic_cast<const vw1__OptionType&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LongOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LongPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LongPolicy", context);
	update_member(update, "value", "xsd:long", basic2str(_obj.value), context);
	update("Base", "InheritablePolicy", context);
	InheritablePolicy_closure(dynamic_cast<const vw1__InheritablePolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LongPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ManagedByInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ManagedByInfo", context);
	update_member(update, "extensionKey", "xsd:string", basic2str(_obj.extensionKey), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ManagedByInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ManagedEntityEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ManagedEntityEventArgument", context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update("Base", "EntityEventArgument", context);
	EntityEventArgument_closure(dynamic_cast<const vw1__EntityEventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ManagedEntityEventArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return EntityEventArgument_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ManagedObjectReference_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ManagedObjectReference", context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update_member(update, "value", "xsd:string", _obj.__item, context);
	update("End", std::string(), context);
}

closure* ManagedObjectReference_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MethodAction_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MethodAction", context);
	update_member(update, "argument", "MethodActionArgument[]", a2s_object(_obj.argument, _obj.__sizeargument), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "Action", context);
	Action_closure(dynamic_cast<const vw1__Action&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MethodAction_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeargument)
				return new MethodActionArgument_closure(*_obj.argument[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return Action_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void MethodActionArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MethodActionArgument", context);
	update_member(update, "value", "xsd:anyType", basic2str(_obj.value), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MethodActionArgument_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MethodDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MethodDescription", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "Description", context);
	Description_closure(dynamic_cast<const vw1__Description&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MethodDescription_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MetricAlarmExpression_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MetricAlarmExpression", context);
	update_member(update, "metric", "PerfMetricId", handle_obj_ptr(_obj.metric), context);
	update_member(update, "operator_", "MetricAlarmOperator", handle_obj(_obj.operator_), context);
	update_member(update, "red", "xsd:int", basic2str(_obj.red), context);
	update_member_with_version(update, "redInterval", "xsd:int", basic2str(_obj.redInterval), context, "4.0");
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update_member(update, "yellow", "xsd:int", basic2str(_obj.yellow), context);
	update_member_with_version(update, "yellowInterval", "xsd:int", basic2str(_obj.yellowInterval), context, "4.0");
	update("Base", "AlarmExpression", context);
	AlarmExpression_closure(dynamic_cast<const vw1__AlarmExpression&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MetricAlarmExpression_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.metric)
			return new PerfMetricId_closure(*_obj.metric);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AlarmExpression_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void MigrationErrorEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MigrationErrorEvent", context);
	update("Base", "MigrationEvent", context);
	MigrationEvent_closure(dynamic_cast<const vw1__MigrationEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MigrationErrorEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MigrationEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MigrationEvent", context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MigrationEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void MigrationHostErrorEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MigrationHostErrorEvent", context);
	update_member(update, "dstHost", "HostEventArgument", handle_obj_ptr(_obj.dstHost), context);
	update("Base", "MigrationEvent", context);
	MigrationEvent_closure(dynamic_cast<const vw1__MigrationEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MigrationHostErrorEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.dstHost)
			return new HostEventArgument_closure(*_obj.dstHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return MigrationEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void MigrationHostWarningEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MigrationHostWarningEvent", context);
	update_member(update, "dstHost", "HostEventArgument", handle_obj_ptr(_obj.dstHost), context);
	update("Base", "MigrationEvent", context);
	MigrationEvent_closure(dynamic_cast<const vw1__MigrationEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MigrationHostWarningEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.dstHost)
			return new HostEventArgument_closure(*_obj.dstHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return MigrationEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void MigrationResourceErrorEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MigrationResourceErrorEvent", context);
	update_member(update, "dstHost", "HostEventArgument", handle_obj_ptr(_obj.dstHost), context);
	update_member(update, "dstPool", "ResourcePoolEventArgument", handle_obj_ptr(_obj.dstPool), context);
	update("Base", "MigrationEvent", context);
	MigrationEvent_closure(dynamic_cast<const vw1__MigrationEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MigrationResourceErrorEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.dstHost)
			return new HostEventArgument_closure(*_obj.dstHost);
		else
			return 0;
	case 1:
		if (_obj.dstPool)
			return new ResourcePoolEventArgument_closure(*_obj.dstPool);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return MigrationEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void MigrationResourceWarningEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MigrationResourceWarningEvent", context);
	update_member(update, "dstHost", "HostEventArgument", handle_obj_ptr(_obj.dstHost), context);
	update_member(update, "dstPool", "ResourcePoolEventArgument", handle_obj_ptr(_obj.dstPool), context);
	update("Base", "MigrationEvent", context);
	MigrationEvent_closure(dynamic_cast<const vw1__MigrationEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MigrationResourceWarningEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.dstHost)
			return new HostEventArgument_closure(*_obj.dstHost);
		else
			return 0;
	case 1:
		if (_obj.dstPool)
			return new ResourcePoolEventArgument_closure(*_obj.dstPool);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return MigrationEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void MigrationWarningEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MigrationWarningEvent", context);
	update("Base", "MigrationEvent", context);
	MigrationEvent_closure(dynamic_cast<const vw1__MigrationEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MigrationWarningEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MissingObject_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MissingObject", context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update_member(update, "obj", "ManagedObjectReference", handle_obj_ptr(_obj.obj), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MissingObject_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	case 1:
		if (_obj.obj)
			return new ManagedObjectReference_closure(*_obj.obj);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void MissingProperty_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MissingProperty", context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update_member(update, "path", "xsd:string", basic2str(_obj.path), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MissingProperty_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ModeInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ModeInfo", context);
	update_member(update, "admin", "xsd:string", basic2str(_obj.admin), context);
	update_member(update, "browse", "xsd:string", basic2str(_obj.browse), context);
	update_member(update, "full", "xsd:string", basic2str(_obj.full), context);
	update_member(update, "modify", "xsd:string", basic2str(_obj.modify), context);
	update_member(update, "read", "xsd:string", basic2str(_obj.read), context);
	update_member(update, "use", "xsd:string", basic2str(_obj.use), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ModeInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MonthlyByDayTaskScheduler_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MonthlyByDayTaskScheduler", context);
	update_member(update, "day", "xsd:int", basic2str(_obj.day), context);
	update("Base", "MonthlyTaskScheduler", context);
	MonthlyTaskScheduler_closure(dynamic_cast<const vw1__MonthlyTaskScheduler&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MonthlyByDayTaskScheduler_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MonthlyByWeekdayTaskScheduler_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MonthlyByWeekdayTaskScheduler", context);
	update_member(update, "offset", "WeekOfMonth", handle_obj(_obj.offset), context);
	update_member(update, "weekday", "DayOfWeek", handle_obj(_obj.weekday), context);
	update("Base", "MonthlyTaskScheduler", context);
	MonthlyTaskScheduler_closure(dynamic_cast<const vw1__MonthlyTaskScheduler&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MonthlyByWeekdayTaskScheduler_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MonthlyTaskScheduler_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MonthlyTaskScheduler", context);
	update("Base", "DailyTaskScheduler", context);
	DailyTaskScheduler_closure(dynamic_cast<const vw1__DailyTaskScheduler&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MonthlyTaskScheduler_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MultipleCertificatesVerifyFaultThumbprintData_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MultipleCertificatesVerifyFaultThumbprintData", context);
	update_member(update, "port", "xsd:int", basic2str(_obj.port), context);
	update_member(update, "thumbprint", "xsd:string", basic2str(_obj.thumbprint), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MultipleCertificatesVerifyFaultThumbprintData_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NASDatastoreCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NASDatastoreCreatedEvent", context);
	update_member(update, "datastore", "DatastoreEventArgument", handle_obj_ptr(_obj.datastore), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NASDatastoreCreatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.datastore)
			return new DatastoreEventArgument_closure(*_obj.datastore);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void NamePasswordAuthentication_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NamePasswordAuthentication", context);
	update_member(update, "password", "xsd:string", basic2str(_obj.password), context);
	update_member(update, "username", "xsd:string", basic2str(_obj.username), context);
	update("Base", "GuestAuthentication", context);
	GuestAuthentication_closure(dynamic_cast<const vw1__GuestAuthentication&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NamePasswordAuthentication_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NasDatastoreInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NasDatastoreInfo", context);
	update_member(update, "nas", "HostNasVolume", handle_obj_ptr(_obj.nas), context);
	update("Base", "DatastoreInfo", context);
	DatastoreInfo_closure(dynamic_cast<const vw1__DatastoreInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NasDatastoreInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.nas)
			return new HostNasVolume_closure(*_obj.nas);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DatastoreInfo_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void NasStorageProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NasStorageProfile", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NasStorageProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetBIOSConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetBIOSConfigInfo", context);
	update_member(update, "mode", "xsd:string", basic2str(_obj.mode), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetBIOSConfigInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetDhcpConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetDhcpConfigInfo", context);
	update_member(update, "ipv4", "NetDhcpConfigInfoDhcpOptions", handle_obj_ptr(_obj.ipv4), context);
	update_member(update, "ipv6", "NetDhcpConfigInfoDhcpOptions", handle_obj_ptr(_obj.ipv6), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetDhcpConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.ipv4)
			return new NetDhcpConfigInfoDhcpOptions_closure(*_obj.ipv4);
		else
			return 0;
	case 1:
		if (_obj.ipv6)
			return new NetDhcpConfigInfoDhcpOptions_closure(*_obj.ipv6);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void NetDhcpConfigInfoDhcpOptions_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetDhcpConfigInfoDhcpOptions", context);
	update_member(update, "config", "KeyValue[]", a2s_object(_obj.config, _obj.__sizeconfig), context);
	update_member(update, "enable", "xsd:boolean", basic2str(_obj.enable), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetDhcpConfigInfoDhcpOptions_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeconfig)
				return new KeyValue_closure(*_obj.config[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void NetDhcpConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetDhcpConfigSpec", context);
	update_member(update, "ipv4", "NetDhcpConfigSpecDhcpOptionsSpec", handle_obj_ptr(_obj.ipv4), context);
	update_member(update, "ipv6", "NetDhcpConfigSpecDhcpOptionsSpec", handle_obj_ptr(_obj.ipv6), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetDhcpConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.ipv4)
			return new NetDhcpConfigSpecDhcpOptionsSpec_closure(*_obj.ipv4);
		else
			return 0;
	case 1:
		if (_obj.ipv6)
			return new NetDhcpConfigSpecDhcpOptionsSpec_closure(*_obj.ipv6);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void NetDhcpConfigSpecDhcpOptionsSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetDhcpConfigSpecDhcpOptionsSpec", context);
	update_member(update, "config", "KeyValue[]", a2s_object(_obj.config, _obj.__sizeconfig), context);
	update_member(update, "enable", "xsd:boolean", basic2str(_obj.enable), context);
	update_member(update, "operation", "xsd:string", basic2str(_obj.operation), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetDhcpConfigSpecDhcpOptionsSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeconfig)
				return new KeyValue_closure(*_obj.config[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void NetDnsConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetDnsConfigInfo", context);
	update_member(update, "dhcp", "xsd:boolean", basic2str(_obj.dhcp), context);
	update_member(update, "domainName", "xsd:string", basic2str(_obj.domainName), context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update_member(update, "ipAddress", "xsd:string[]", a2s_basic(*_obj.ipAddress, _obj.__sizeipAddress), context);
	update_member(update, "searchDomain", "xsd:string[]", a2s_basic(*_obj.searchDomain, _obj.__sizesearchDomain), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetDnsConfigInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetDnsConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetDnsConfigSpec", context);
	update_member(update, "dhcp", "xsd:boolean", basic2str(_obj.dhcp), context);
	update_member(update, "domainName", "xsd:string", basic2str(_obj.domainName), context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update_member(update, "ipAddress", "xsd:string[]", a2s_basic(*_obj.ipAddress, _obj.__sizeipAddress), context);
	update_member(update, "searchDomain", "xsd:string[]", a2s_basic(*_obj.searchDomain, _obj.__sizesearchDomain), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetDnsConfigSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetIpConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetIpConfigInfo", context);
	update_member(update, "autoConfigurationEnabled", "xsd:boolean", basic2str(_obj.autoConfigurationEnabled), context);
	update_member(update, "dhcp", "NetDhcpConfigInfo", handle_obj_ptr(_obj.dhcp), context);
	update_member(update, "ipAddress", "NetIpConfigInfoIpAddress[]", a2s_object(_obj.ipAddress, _obj.__sizeipAddress), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetIpConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.dhcp)
			return new NetDhcpConfigInfo_closure(*_obj.dhcp);
		else
			return 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeipAddress)
				return new NetIpConfigInfoIpAddress_closure(*_obj.ipAddress[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void NetIpConfigInfoIpAddress_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetIpConfigInfoIpAddress", context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update_member(update, "lifetime", "xsd:dateTime", basic2str(_obj.lifetime), context);
	update_member(update, "origin", "xsd:string", basic2str(_obj.origin), context);
	update_member(update, "prefixLength", "xsd:int", basic2str(_obj.prefixLength), context);
	update_member(update, "state", "xsd:string", basic2str(_obj.state), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetIpConfigInfoIpAddress_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetIpConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetIpConfigSpec", context);
	update_member(update, "autoConfigurationEnabled", "xsd:boolean", basic2str(_obj.autoConfigurationEnabled), context);
	update_member(update, "dhcp", "NetDhcpConfigSpec", handle_obj_ptr(_obj.dhcp), context);
	update_member(update, "ipAddress", "NetIpConfigSpecIpAddressSpec[]", a2s_object(_obj.ipAddress, _obj.__sizeipAddress), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetIpConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.dhcp)
			return new NetDhcpConfigSpec_closure(*_obj.dhcp);
		else
			return 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeipAddress)
				return new NetIpConfigSpecIpAddressSpec_closure(*_obj.ipAddress[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void NetIpConfigSpecIpAddressSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetIpConfigSpecIpAddressSpec", context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update_member(update, "operation", "xsd:string", basic2str(_obj.operation), context);
	update_member(update, "prefixLength", "xsd:int", basic2str(_obj.prefixLength), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetIpConfigSpecIpAddressSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetIpRouteConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetIpRouteConfigInfo", context);
	update_member(update, "ipRoute", "NetIpRouteConfigInfoIpRoute[]", a2s_object(_obj.ipRoute, _obj.__sizeipRoute), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetIpRouteConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeipRoute)
				return new NetIpRouteConfigInfoIpRoute_closure(*_obj.ipRoute[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void NetIpRouteConfigInfoGateway_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetIpRouteConfigInfoGateway", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetIpRouteConfigInfoGateway_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetIpRouteConfigInfoIpRoute_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetIpRouteConfigInfoIpRoute", context);
	update_member(update, "gateway", "NetIpRouteConfigInfoGateway", handle_obj_ptr(_obj.gateway), context);
	update_member(update, "network", "xsd:string", basic2str(_obj.network), context);
	update_member(update, "prefixLength", "xsd:int", basic2str(_obj.prefixLength), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetIpRouteConfigInfoIpRoute_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.gateway)
			return new NetIpRouteConfigInfoGateway_closure(*_obj.gateway);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void NetIpRouteConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetIpRouteConfigSpec", context);
	update_member(update, "ipRoute", "NetIpRouteConfigSpecIpRouteSpec[]", a2s_object(_obj.ipRoute, _obj.__sizeipRoute), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetIpRouteConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeipRoute)
				return new NetIpRouteConfigSpecIpRouteSpec_closure(*_obj.ipRoute[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void NetIpRouteConfigSpecGatewaySpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetIpRouteConfigSpecGatewaySpec", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetIpRouteConfigSpecGatewaySpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetIpRouteConfigSpecIpRouteSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetIpRouteConfigSpecIpRouteSpec", context);
	update_member(update, "gateway", "NetIpRouteConfigSpecGatewaySpec", handle_obj_ptr(_obj.gateway), context);
	update_member(update, "network", "xsd:string", basic2str(_obj.network), context);
	update_member(update, "operation", "xsd:string", basic2str(_obj.operation), context);
	update_member(update, "prefixLength", "xsd:int", basic2str(_obj.prefixLength), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetIpRouteConfigSpecIpRouteSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.gateway)
			return new NetIpRouteConfigSpecGatewaySpec_closure(*_obj.gateway);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void NetIpStackInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetIpStackInfo", context);
	update_member(update, "defaultRouter", "NetIpStackInfoDefaultRouter[]", a2s_object(_obj.defaultRouter, _obj.__sizedefaultRouter), context);
	update_member(update, "neighbor", "NetIpStackInfoNetToMedia[]", a2s_object(_obj.neighbor, _obj.__sizeneighbor), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetIpStackInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedefaultRouter)
				return new NetIpStackInfoDefaultRouter_closure(*_obj.defaultRouter[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeneighbor)
				return new NetIpStackInfoNetToMedia_closure(*_obj.neighbor[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void NetIpStackInfoDefaultRouter_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetIpStackInfoDefaultRouter", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update_member(update, "lifetime", "xsd:dateTime", basic2str(_obj.lifetime), context);
	update_member(update, "preference", "xsd:string", basic2str(_obj.preference), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetIpStackInfoDefaultRouter_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetIpStackInfoNetToMedia_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetIpStackInfoNetToMedia", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update_member(update, "physicalAddress", "xsd:string", basic2str(_obj.physicalAddress), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetIpStackInfoNetToMedia_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetworkEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetworkEventArgument", context);
	update_member(update, "network", "Network", handle_obj_ptr(_obj.network), context);
	update("Base", "EntityEventArgument", context);
	EntityEventArgument_closure(dynamic_cast<const vw1__EntityEventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetworkEventArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.network? 
			get_closure_from_mor(Network(_obj.network)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return EntityEventArgument_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void NetworkPolicyProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetworkPolicyProfile", context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetworkPolicyProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetworkProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetworkProfile", context);
	update_member(update, "consoleIpRouteConfig", "IpRouteProfile", handle_obj_ptr(_obj.consoleIpRouteConfig), context);
	update_member(update, "dnsConfig", "NetworkProfileDnsConfigProfile", handle_obj_ptr(_obj.dnsConfig), context);
	update_member(update, "dvsHostNic", "DvsHostVNicProfile[]", a2s_object(_obj.dvsHostNic, _obj.__sizedvsHostNic), context);
	update_member(update, "dvsServiceConsoleNic", "DvsServiceConsoleVNicProfile[]", a2s_object(_obj.dvsServiceConsoleNic, _obj.__sizedvsServiceConsoleNic), context);
	update_member(update, "dvswitch", "DvsProfile[]", a2s_object(_obj.dvswitch, _obj.__sizedvswitch), context);
	update_member(update, "hostPortGroup", "HostPortGroupProfile[]", a2s_object(_obj.hostPortGroup, _obj.__sizehostPortGroup), context);
	update_member(update, "ipRouteConfig", "IpRouteProfile", handle_obj_ptr(_obj.ipRouteConfig), context);
	update_member(update, "pnic", "PhysicalNicProfile[]", a2s_object(_obj.pnic, _obj.__sizepnic), context);
	update_member(update, "serviceConsolePortGroup", "ServiceConsolePortGroupProfile[]", a2s_object(_obj.serviceConsolePortGroup, _obj.__sizeserviceConsolePortGroup), context);
	update_member(update, "vmPortGroup", "VmPortGroupProfile[]", a2s_object(_obj.vmPortGroup, _obj.__sizevmPortGroup), context);
	update_member(update, "vswitch", "VirtualSwitchProfile[]", a2s_object(_obj.vswitch, _obj.__sizevswitch), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetworkProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.consoleIpRouteConfig)
			return new IpRouteProfile_closure(*_obj.consoleIpRouteConfig);
		else
			return 0;
	case 1:
		if (_obj.dnsConfig)
			return new NetworkProfileDnsConfigProfile_closure(*_obj.dnsConfig);
		else
			return 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedvsHostNic)
				return new DvsHostVNicProfile_closure(*_obj.dvsHostNic[i]);
			else
				return 0;
		}
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedvsServiceConsoleNic)
				return new DvsServiceConsoleVNicProfile_closure(*_obj.dvsServiceConsoleNic[i]);
			else
				return 0;
		}
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedvswitch)
				return new DvsProfile_closure(*_obj.dvswitch[i]);
			else
				return 0;
		}
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehostPortGroup)
				return new HostPortGroupProfile_closure(*_obj.hostPortGroup[i]);
			else
				return 0;
		}
	case 6:
		if (_obj.ipRouteConfig)
			return new IpRouteProfile_closure(*_obj.ipRouteConfig);
		else
			return 0;
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepnic)
				return new PhysicalNicProfile_closure(*_obj.pnic[i]);
			else
				return 0;
		}
	case 8:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeserviceConsolePortGroup)
				return new ServiceConsolePortGroupProfile_closure(*_obj.serviceConsolePortGroup[i]);
			else
				return 0;
		}
	case 9:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevmPortGroup)
				return new VmPortGroupProfile_closure(*_obj.vmPortGroup[i]);
			else
				return 0;
		}
	case 10:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevswitch)
				return new VirtualSwitchProfile_closure(*_obj.vswitch[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ApplyProfile_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void NetworkProfileDnsConfigProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetworkProfileDnsConfigProfile", context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetworkProfileDnsConfigProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetworkSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetworkSummary", context);
	update_member(update, "accessible", "xsd:boolean", basic2str(_obj.accessible), context);
	update_member_with_version(update, "ipPoolName", "xsd:string", basic2str(_obj.ipPoolName), context, "4.0");
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "network", "Network", handle_obj_ptr(_obj.network), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetworkSummary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		return _obj.network? 
			get_closure_from_mor(Network(_obj.network)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void NoAccessUserEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoAccessUserEvent", context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update("Base", "SessionEvent", context);
	SessionEvent_closure(dynamic_cast<const vw1__SessionEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoAccessUserEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoDatastoresConfiguredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoDatastoresConfiguredEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoDatastoresConfiguredEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoLicenseEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoLicenseEvent", context);
	update_member(update, "feature", "LicenseFeatureInfo", handle_obj_ptr(_obj.feature), context);
	update("Base", "LicenseEvent", context);
	LicenseEvent_closure(dynamic_cast<const vw1__LicenseEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoLicenseEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.feature)
			return new LicenseFeatureInfo_closure(*_obj.feature);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return LicenseEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void NoMaintenanceModeDrsRecommendationForVM_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoMaintenanceModeDrsRecommendationForVM", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoMaintenanceModeDrsRecommendationForVM_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NonVIWorkloadDetectedOnDatastoreEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NonVIWorkloadDetectedOnDatastoreEvent", context);
	update("Base", "DatastoreEvent", context);
	DatastoreEvent_closure(dynamic_cast<const vw1__DatastoreEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NonVIWorkloadDetectedOnDatastoreEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NotEnoughResourcesToStartVmEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotEnoughResourcesToStartVmEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotEnoughResourcesToStartVmEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NumPortsProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NumPortsProfile", context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NumPortsProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NumericRange_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NumericRange", context);
	update_member(update, "end", "xsd:int", basic2str(_obj.end), context);
	update_member(update, "start", "xsd:int", basic2str(_obj.start), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NumericRange_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ObjectContent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ObjectContent", context);
	update_member(update, "missingSet", "MissingProperty[]", a2s_object(_obj.missingSet, _obj.__sizemissingSet), context);
	update_member(update, "obj", "ManagedObjectReference", handle_obj_ptr(_obj.obj), context);
	update_member(update, "propSet", "DynamicProperty[]", a2s_object(_obj.propSet, _obj.__sizepropSet), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ObjectContent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemissingSet)
				return new MissingProperty_closure(*_obj.missingSet[i]);
			else
				return 0;
		}
	case 1:
		if (_obj.obj)
			return new ManagedObjectReference_closure(*_obj.obj);
		else
			return 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepropSet)
				return new DynamicProperty_closure(*_obj.propSet[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ObjectSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ObjectSpec", context);
	update_member(update, "obj", "ManagedObjectReference", handle_obj_ptr(_obj.obj), context);
	update_member(update, "selectSet", "SelectionSpec[]", a2s_object(_obj.selectSet, _obj.__sizeselectSet), context);
	update_member(update, "skip", "xsd:boolean", basic2str(_obj.skip), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ObjectSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.obj)
			return new ManagedObjectReference_closure(*_obj.obj);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeselectSet)
				return new SelectionSpec_closure(*_obj.selectSet[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ObjectUpdate_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ObjectUpdate", context);
	update_member(update, "changeSet", "PropertyChange[]", a2s_object(_obj.changeSet, _obj.__sizechangeSet), context);
	update_member(update, "kind", "ObjectUpdateKind", handle_obj(_obj.kind), context);
	update_member(update, "missingSet", "MissingProperty[]", a2s_object(_obj.missingSet, _obj.__sizemissingSet), context);
	update_member(update, "obj", "ManagedObjectReference", handle_obj_ptr(_obj.obj), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ObjectUpdate_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizechangeSet)
				return new PropertyChange_closure(*_obj.changeSet[i]);
			else
				return 0;
		}
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemissingSet)
				return new MissingProperty_closure(*_obj.missingSet[i]);
			else
				return 0;
		}
	case 3:
		if (_obj.obj)
			return new ManagedObjectReference_closure(*_obj.obj);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void OnceTaskScheduler_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OnceTaskScheduler", context);
	update_member(update, "runAt", "xsd:dateTime", basic2str(_obj.runAt), context);
	update("Base", "TaskScheduler", context);
	TaskScheduler_closure(dynamic_cast<const vw1__TaskScheduler&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OnceTaskScheduler_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OptionDef_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OptionDef", context);
	update_member(update, "optionType", "OptionType", handle_obj_ptr(_obj.optionType), context);
	update("Base", "ElementDescription", context);
	ElementDescription_closure(dynamic_cast<const vw1__ElementDescription&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OptionDef_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.optionType)
			return new OptionType_closure(*_obj.optionType);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ElementDescription_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void OptionProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OptionProfile", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OptionProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OptionType_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OptionType", context);
	update_member(update, "valueIsReadonly", "xsd:boolean", basic2str(_obj.valueIsReadonly), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OptionType_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OptionValue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OptionValue", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "value", "xsd:anyType", basic2str(_obj.value), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OptionValue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OrAlarmExpression_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OrAlarmExpression", context);
	update_member(update, "expression", "AlarmExpression[]", a2s_object(_obj.expression, _obj.__sizeexpression), context);
	update("Base", "AlarmExpression", context);
	AlarmExpression_closure(dynamic_cast<const vw1__AlarmExpression&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OrAlarmExpression_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeexpression)
				return new AlarmExpression_closure(*_obj.expression[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return AlarmExpression_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void OutOfSyncDvsHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OutOfSyncDvsHost", context);
	update_member(update, "hostOutOfSync", "DvsOutOfSyncHostArgument[]", a2s_object(_obj.hostOutOfSync, _obj.__sizehostOutOfSync), context);
	update("Base", "DvsEvent", context);
	DvsEvent_closure(dynamic_cast<const vw1__DvsEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OutOfSyncDvsHost_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehostOutOfSync)
				return new DvsOutOfSyncHostArgument_closure(*_obj.hostOutOfSync[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DvsEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void OvfConsumerOstNode_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfConsumerOstNode", context);
	update_member(update, "child", "OvfConsumerOstNode[]", a2s_object(_obj.child, _obj.__sizechild), context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "section", "OvfConsumerOvfSection[]", a2s_object(_obj.section, _obj.__sizesection), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfConsumerOstNode_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizechild)
				return new OvfConsumerOstNode_closure(*_obj.child[i]);
			else
				return 0;
		}
	case 1:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesection)
				return new OvfConsumerOvfSection_closure(*_obj.section[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void OvfConsumerOvfSection_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfConsumerOvfSection", context);
	update_member(update, "lineNumber", "xsd:int", basic2str(_obj.lineNumber), context);
	update_member(update, "xml", "xsd:string", basic2str(_obj.xml), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfConsumerOvfSection_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfCreateDescriptorParams_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfCreateDescriptorParams", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member_with_version(update, "includeImageFiles", "xsd:boolean", basic2str(_obj.includeImageFiles), context, "4.1");
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "ovfFiles", "OvfFile[]", a2s_object(_obj.ovfFiles, _obj.__sizeovfFiles), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfCreateDescriptorParams_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeovfFiles)
				return new OvfFile_closure(*_obj.ovfFiles[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void OvfCreateDescriptorResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfCreateDescriptorResult", context);
	update_member(update, "error", "LocalizedMethodFault[]", a2s_object(_obj.error, _obj.__sizeerror), context);
	update_member_with_version(update, "includeImageFiles", "xsd:boolean", basic2str(_obj.includeImageFiles), context, "4.1");
	update_member(update, "ovfDescriptor", "xsd:string", basic2str(_obj.ovfDescriptor), context);
	update_member(update, "warning", "LocalizedMethodFault[]", a2s_object(_obj.warning, _obj.__sizewarning), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfCreateDescriptorResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeerror)
				return new LocalizedMethodFault_closure(*_obj.error[i]);
			else
				return 0;
		}
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizewarning)
				return new LocalizedMethodFault_closure(*_obj.warning[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void OvfCreateImportSpecParams_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfCreateImportSpecParams", context);
	update_member_with_version(update, "diskProvisioning", "xsd:string", basic2str(_obj.diskProvisioning), context, "4.1");
	update_member(update, "entityName", "xsd:string", basic2str(_obj.entityName), context);
	update_member(update, "hostSystem", "HostSystem", handle_obj_ptr(_obj.hostSystem), context);
	update_member_with_version(update, "instantiationOst", "OvfConsumerOstNode", handle_obj_ptr(_obj.instantiationOst), context, "5.0");
	update_member(update, "ipAllocationPolicy", "xsd:string", basic2str(_obj.ipAllocationPolicy), context);
	update_member(update, "ipProtocol", "xsd:string", basic2str(_obj.ipProtocol), context);
	update_member(update, "networkMapping", "OvfNetworkMapping[]", a2s_object(_obj.networkMapping, _obj.__sizenetworkMapping), context);
	update_member(update, "propertyMapping", "KeyValue[]", a2s_object(_obj.propertyMapping, _obj.__sizepropertyMapping), context);
	update_member_with_version(update, "resourceMapping", "OvfResourceMap[]", a2s_object(_obj.resourceMapping, _obj.__sizeresourceMapping), context, "4.1");
	update("Base", "OvfManagerCommonParams", context);
	OvfManagerCommonParams_closure(dynamic_cast<const vw1__OvfManagerCommonParams&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfCreateImportSpecParams_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		return _obj.hostSystem? 
			get_closure_from_mor(HostSystem(_obj.hostSystem)) : 0;
	case 3:
		if (_obj.instantiationOst)
			return new OvfConsumerOstNode_closure(*_obj.instantiationOst);
		else
			return 0;
	case 6:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenetworkMapping)
				return new OvfNetworkMapping_closure(*_obj.networkMapping[i]);
			else
				return 0;
		}
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepropertyMapping)
				return new KeyValue_closure(*_obj.propertyMapping[i]);
			else
				return 0;
		}
	case 8:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeresourceMapping)
				return new OvfResourceMap_closure(*_obj.resourceMapping[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return OvfManagerCommonParams_closure(_obj).get_sub_closure(((prop_index - 9) << 16) + arr_index);
	}
	return 0;
}

void OvfCreateImportSpecResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfCreateImportSpecResult", context);
	update_member(update, "error", "LocalizedMethodFault[]", a2s_object(_obj.error, _obj.__sizeerror), context);
	update_member(update, "fileItem", "OvfFileItem[]", a2s_object(_obj.fileItem, _obj.__sizefileItem), context);
	update_member(update, "importSpec", "ImportSpec", handle_obj_ptr(_obj.importSpec), context);
	update_member(update, "warning", "LocalizedMethodFault[]", a2s_object(_obj.warning, _obj.__sizewarning), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfCreateImportSpecResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeerror)
				return new LocalizedMethodFault_closure(*_obj.error[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefileItem)
				return new OvfFileItem_closure(*_obj.fileItem[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.importSpec)
			return new ImportSpec_closure(*_obj.importSpec);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizewarning)
				return new LocalizedMethodFault_closure(*_obj.warning[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void OvfDeploymentOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfDeploymentOption", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "label", "xsd:string", basic2str(_obj.label), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfDeploymentOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfFile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfFile", context);
	update_member_with_version(update, "capacity", "xsd:long", basic2str(_obj.capacity), context, "4.1");
	update_member(update, "chunkSize", "xsd:long", basic2str(_obj.chunkSize), context);
	update_member(update, "compressionMethod", "xsd:string", basic2str(_obj.compressionMethod), context);
	update_member(update, "deviceId", "xsd:string", basic2str(_obj.deviceId), context);
	update_member(update, "path", "xsd:string", basic2str(_obj.path), context);
	update_member_with_version(update, "populatedSize", "xsd:long", basic2str(_obj.populatedSize), context, "4.1");
	update_member(update, "size", "xsd:long", basic2str(_obj.size), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfFile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfFileItem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfFileItem", context);
	update_member(update, "chunkSize", "xsd:long", basic2str(_obj.chunkSize), context);
	update_member(update, "cimType", "xsd:int", basic2str(_obj.cimType), context);
	update_member(update, "compressionMethod", "xsd:string", basic2str(_obj.compressionMethod), context);
	update_member(update, "create", "xsd:boolean", basic2str(_obj.create), context);
	update_member(update, "deviceId", "xsd:string", basic2str(_obj.deviceId), context);
	update_member(update, "path", "xsd:string", basic2str(_obj.path), context);
	update_member(update, "size", "xsd:long", basic2str(_obj.size), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfFileItem_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfManagerCommonParams_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfManagerCommonParams", context);
	update_member(update, "deploymentOption", "xsd:string", basic2str(_obj.deploymentOption), context);
	update_member(update, "locale", "xsd:string", basic2str(_obj.locale), context);
	update_member(update, "msgBundle", "KeyValue[]", a2s_object(_obj.msgBundle, _obj.__sizemsgBundle), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfManagerCommonParams_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemsgBundle)
				return new KeyValue_closure(*_obj.msgBundle[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void OvfNetworkInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfNetworkInfo", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfNetworkInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfNetworkMapping_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfNetworkMapping", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "network", "Network", handle_obj_ptr(_obj.network), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfNetworkMapping_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.network? 
			get_closure_from_mor(Network(_obj.network)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void OvfParseDescriptorParams_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfParseDescriptorParams", context);
	update("Base", "OvfManagerCommonParams", context);
	OvfManagerCommonParams_closure(dynamic_cast<const vw1__OvfManagerCommonParams&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfParseDescriptorParams_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfParseDescriptorResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfParseDescriptorResult", context);
	update_member_with_version(update, "annotatedOst", "OvfConsumerOstNode", handle_obj_ptr(_obj.annotatedOst), context, "5.0");
	update_member(update, "annotation", "xsd:string", basic2str(_obj.annotation), context);
	update_member(update, "approximateDownloadSize", "xsd:long", basic2str(_obj.approximateDownloadSize), context);
	update_member(update, "approximateFlatDeploymentSize", "xsd:long", basic2str(_obj.approximateFlatDeploymentSize), context);
	update_member(update, "approximateSparseDeploymentSize", "xsd:long", basic2str(_obj.approximateSparseDeploymentSize), context);
	update_member(update, "defaultDeploymentOption", "xsd:string", basic2str(_obj.defaultDeploymentOption), context);
	update_member(update, "defaultEntityName", "xsd:string", basic2str(_obj.defaultEntityName), context);
	update_member(update, "deploymentOption", "OvfDeploymentOption[]", a2s_object(_obj.deploymentOption, _obj.__sizedeploymentOption), context);
	update_member_with_version(update, "entityName", "KeyValue[]", a2s_object(_obj.entityName, _obj.__sizeentityName), context, "4.1");
	update_member(update, "error", "LocalizedMethodFault[]", a2s_object(_obj.error, _obj.__sizeerror), context);
	update_member(update, "eula", "xsd:string[]", a2s_basic(*_obj.eula, _obj.__sizeeula), context);
	update_member(update, "ipAllocationScheme", "xsd:string[]", a2s_basic(*_obj.ipAllocationScheme, _obj.__sizeipAllocationScheme), context);
	update_member(update, "ipProtocols", "xsd:string[]", a2s_basic(*_obj.ipProtocols, _obj.__sizeipProtocols), context);
	update_member(update, "network", "OvfNetworkInfo[]", a2s_object(_obj.network, _obj.__sizenetwork), context);
	update_member(update, "productInfo", "VAppProductInfo", handle_obj_ptr(_obj.productInfo), context);
	update_member(update, "property", "VAppPropertyInfo[]", a2s_object(_obj.property, _obj.__sizeproperty), context);
	update_member(update, "virtualApp", "xsd:boolean", basic2str(_obj.virtualApp), context);
	update_member(update, "warning", "LocalizedMethodFault[]", a2s_object(_obj.warning, _obj.__sizewarning), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfParseDescriptorResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.annotatedOst)
			return new OvfConsumerOstNode_closure(*_obj.annotatedOst);
		else
			return 0;
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedeploymentOption)
				return new OvfDeploymentOption_closure(*_obj.deploymentOption[i]);
			else
				return 0;
		}
	case 8:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeentityName)
				return new KeyValue_closure(*_obj.entityName[i]);
			else
				return 0;
		}
	case 9:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeerror)
				return new LocalizedMethodFault_closure(*_obj.error[i]);
			else
				return 0;
		}
	case 13:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenetwork)
				return new OvfNetworkInfo_closure(*_obj.network[i]);
			else
				return 0;
		}
	case 14:
		if (_obj.productInfo)
			return new VAppProductInfo_closure(*_obj.productInfo);
		else
			return 0;
	case 15:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeproperty)
				return new VAppPropertyInfo_closure(*_obj.property[i]);
			else
				return 0;
		}
	case 17:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizewarning)
				return new LocalizedMethodFault_closure(*_obj.warning[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 18) << 16) + arr_index);
	}
	return 0;
}

void OvfResourceMap_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfResourceMap", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "parent", "ResourcePool", handle_obj_ptr(_obj.parent), context);
	update_member(update, "resourceSpec", "ResourceConfigSpec", handle_obj_ptr(_obj.resourceSpec), context);
	update_member(update, "source", "xsd:string", basic2str(_obj.source), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfResourceMap_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	case 1:
		return _obj.parent? 
			get_closure_from_mor(ResourcePool(_obj.parent)) : 0;
	case 2:
		if (_obj.resourceSpec)
			return new ResourceConfigSpec_closure(*_obj.resourceSpec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void OvfValidateHostParams_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfValidateHostParams", context);
	update("Base", "OvfManagerCommonParams", context);
	OvfManagerCommonParams_closure(dynamic_cast<const vw1__OvfManagerCommonParams&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfValidateHostParams_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfValidateHostResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfValidateHostResult", context);
	update_member(update, "downloadSize", "xsd:long", basic2str(_obj.downloadSize), context);
	update_member(update, "error", "LocalizedMethodFault[]", a2s_object(_obj.error, _obj.__sizeerror), context);
	update_member(update, "flatDeploymentSize", "xsd:long", basic2str(_obj.flatDeploymentSize), context);
	update_member(update, "sparseDeploymentSize", "xsd:long", basic2str(_obj.sparseDeploymentSize), context);
	update_member_with_version(update, "supportedDiskProvisioning", "xsd:string[]", a2s_basic(*_obj.supportedDiskProvisioning, _obj.__sizesupportedDiskProvisioning), context, "4.1");
	update_member(update, "warning", "LocalizedMethodFault[]", a2s_object(_obj.warning, _obj.__sizewarning), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfValidateHostResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeerror)
				return new LocalizedMethodFault_closure(*_obj.error[i]);
			else
				return 0;
		}
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizewarning)
				return new LocalizedMethodFault_closure(*_obj.warning[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void ParaVirtualSCSIController_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ParaVirtualSCSIController", context);
	update("Base", "VirtualSCSIController", context);
	VirtualSCSIController_closure(dynamic_cast<const vw1__VirtualSCSIController&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ParaVirtualSCSIController_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ParaVirtualSCSIControllerOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ParaVirtualSCSIControllerOption", context);
	update("Base", "VirtualSCSIControllerOption", context);
	VirtualSCSIControllerOption_closure(dynamic_cast<const vw1__VirtualSCSIControllerOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ParaVirtualSCSIControllerOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PasswordField_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PasswordField", context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PasswordField_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PerfCompositeMetric_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerfCompositeMetric", context);
	update_member(update, "childEntity", "PerfEntityMetricBase[]", a2s_object(_obj.childEntity, _obj.__sizechildEntity), context);
	update_member(update, "entity", "PerfEntityMetricBase", handle_obj_ptr(_obj.entity), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerfCompositeMetric_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizechildEntity)
				return new PerfEntityMetricBase_closure(*_obj.childEntity[i]);
			else
				return 0;
		}
	case 1:
		if (_obj.entity)
			return new PerfEntityMetricBase_closure(*_obj.entity);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void PerfCounterInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerfCounterInfo", context);
	update_member(update, "associatedCounterId", "xsd:int[]", a2s_basic(_obj.associatedCounterId, _obj.__sizeassociatedCounterId), context);
	update_member(update, "groupInfo", "ElementDescription", handle_obj_ptr(_obj.groupInfo), context);
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update_member_with_version(update, "level", "xsd:int", basic2str(_obj.level), context, "2.5");
	update_member(update, "nameInfo", "ElementDescription", handle_obj_ptr(_obj.nameInfo), context);
	update_member_with_version(update, "perDeviceLevel", "xsd:int", basic2str(_obj.perDeviceLevel), context, "4.1");
	update_member(update, "rollupType", "PerfSummaryType", handle_obj(_obj.rollupType), context);
	update_member(update, "statsType", "PerfStatsType", handle_obj(_obj.statsType), context);
	update_member(update, "unitInfo", "ElementDescription", handle_obj_ptr(_obj.unitInfo), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerfCounterInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.groupInfo)
			return new ElementDescription_closure(*_obj.groupInfo);
		else
			return 0;
	case 4:
		if (_obj.nameInfo)
			return new ElementDescription_closure(*_obj.nameInfo);
		else
			return 0;
	case 8:
		if (_obj.unitInfo)
			return new ElementDescription_closure(*_obj.unitInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 9) << 16) + arr_index);
	}
	return 0;
}

void PerfEntityMetric_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerfEntityMetric", context);
	update_member(update, "sampleInfo", "PerfSampleInfo[]", a2s_object(_obj.sampleInfo, _obj.__sizesampleInfo), context);
	update_member(update, "value", "PerfMetricSeries[]", a2s_object(_obj.value, _obj.__sizevalue), context);
	update("Base", "PerfEntityMetricBase", context);
	PerfEntityMetricBase_closure(dynamic_cast<const vw1__PerfEntityMetricBase&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerfEntityMetric_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesampleInfo)
				return new PerfSampleInfo_closure(*_obj.sampleInfo[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevalue)
				return new PerfMetricSeries_closure(*_obj.value[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return PerfEntityMetricBase_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void PerfEntityMetricBase_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerfEntityMetricBase", context);
	update_member(update, "entity", "ManagedObjectReference", handle_obj_ptr(_obj.entity), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerfEntityMetricBase_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedObjectReference_closure(*_obj.entity);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void PerfEntityMetricCSV_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerfEntityMetricCSV", context);
	update_member(update, "sampleInfoCSV", "xsd:string", basic2str(_obj.sampleInfoCSV), context);
	update_member(update, "value", "PerfMetricSeriesCSV[]", a2s_object(_obj.value, _obj.__sizevalue), context);
	update("Base", "PerfEntityMetricBase", context);
	PerfEntityMetricBase_closure(dynamic_cast<const vw1__PerfEntityMetricBase&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerfEntityMetricCSV_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevalue)
				return new PerfMetricSeriesCSV_closure(*_obj.value[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return PerfEntityMetricBase_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void PerfInterval_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerfInterval", context);
	update_member_with_version(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context, "2.5");
	update_member_with_version(update, "key", "xsd:int", basic2str(_obj.key), context, "2.5");
	update_member(update, "length", "xsd:int", basic2str(_obj.length), context);
	update_member_with_version(update, "level", "xsd:int", basic2str(_obj.level), context, "2.5");
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "samplingPeriod", "xsd:int", basic2str(_obj.samplingPeriod), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerfInterval_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PerfMetricId_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerfMetricId", context);
	update_member(update, "counterId", "xsd:int", basic2str(_obj.counterId), context);
	update_member(update, "instance", "xsd:string", basic2str(_obj.instance), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerfMetricId_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PerfMetricIntSeries_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerfMetricIntSeries", context);
	update_member(update, "value", "xsd:long[]", a2s_basic(_obj.value, _obj.__sizevalue), context);
	update("Base", "PerfMetricSeries", context);
	PerfMetricSeries_closure(dynamic_cast<const vw1__PerfMetricSeries&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerfMetricIntSeries_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PerfMetricSeries_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerfMetricSeries", context);
	update_member(update, "id", "PerfMetricId", handle_obj_ptr(_obj.id), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerfMetricSeries_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.id)
			return new PerfMetricId_closure(*_obj.id);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void PerfMetricSeriesCSV_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerfMetricSeriesCSV", context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "PerfMetricSeries", context);
	PerfMetricSeries_closure(dynamic_cast<const vw1__PerfMetricSeries&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerfMetricSeriesCSV_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PerfProviderSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerfProviderSummary", context);
	update_member(update, "currentSupported", "xsd:boolean", basic2str(_obj.currentSupported), context);
	update_member(update, "entity", "ManagedObjectReference", handle_obj_ptr(_obj.entity), context);
	update_member(update, "refreshRate", "xsd:int", basic2str(_obj.refreshRate), context);
	update_member(update, "summarySupported", "xsd:boolean", basic2str(_obj.summarySupported), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerfProviderSummary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.entity)
			return new ManagedObjectReference_closure(*_obj.entity);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void PerfQuerySpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerfQuerySpec", context);
	update_member(update, "endTime", "xsd:dateTime", basic2str(_obj.endTime), context);
	update_member(update, "entity", "ManagedObjectReference", handle_obj_ptr(_obj.entity), context);
	update_member(update, "format", "xsd:string", basic2str(_obj.format), context);
	update_member(update, "intervalId", "xsd:int", basic2str(_obj.intervalId), context);
	update_member(update, "maxSample", "xsd:int", basic2str(_obj.maxSample), context);
	update_member(update, "metricId", "PerfMetricId[]", a2s_object(_obj.metricId, _obj.__sizemetricId), context);
	update_member(update, "startTime", "xsd:dateTime", basic2str(_obj.startTime), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerfQuerySpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.entity)
			return new ManagedObjectReference_closure(*_obj.entity);
		else
			return 0;
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemetricId)
				return new PerfMetricId_closure(*_obj.metricId[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void PerfSampleInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerfSampleInfo", context);
	update_member(update, "interval", "xsd:int", basic2str(_obj.interval), context);
	update_member(update, "timestamp", "xsd:dateTime", basic2str(_obj.timestamp), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerfSampleInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PerformanceDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerformanceDescription", context);
	update_member(update, "counterType", "ElementDescription[]", a2s_object(_obj.counterType, _obj.__sizecounterType), context);
	update_member(update, "statsType", "ElementDescription[]", a2s_object(_obj.statsType, _obj.__sizestatsType), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerformanceDescription_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecounterType)
				return new ElementDescription_closure(*_obj.counterType[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizestatsType)
				return new ElementDescription_closure(*_obj.statsType[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void PerformanceManagerCounterLevelMapping_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerformanceManagerCounterLevelMapping", context);
	update_member(update, "aggregateLevel", "xsd:int", basic2str(_obj.aggregateLevel), context);
	update_member(update, "counterId", "xsd:int", basic2str(_obj.counterId), context);
	update_member(update, "perDeviceLevel", "xsd:int", basic2str(_obj.perDeviceLevel), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerformanceManagerCounterLevelMapping_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PerformanceStatisticsDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerformanceStatisticsDescription", context);
	update_member(update, "intervals", "PerfInterval[]", a2s_object(_obj.intervals, _obj.__sizeintervals), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PerformanceStatisticsDescription_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeintervals)
				return new PerfInterval_closure(*_obj.intervals[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void Permission_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Permission", context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "group", "xsd:boolean", basic2str(_obj.group), context);
	update_member(update, "principal", "xsd:string", basic2str(_obj.principal), context);
	update_member(update, "propagate", "xsd:boolean", basic2str(_obj.propagate), context);
	update_member(update, "roleId", "xsd:int", basic2str(_obj.roleId), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* Permission_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void PermissionAddedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PermissionAddedEvent", context);
	update_member(update, "propagate", "xsd:boolean", basic2str(_obj.propagate), context);
	update_member(update, "role", "RoleEventArgument", handle_obj_ptr(_obj.role), context);
	update("Base", "PermissionEvent", context);
	PermissionEvent_closure(dynamic_cast<const vw1__PermissionEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PermissionAddedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.role)
			return new RoleEventArgument_closure(*_obj.role);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return PermissionEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void PermissionEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PermissionEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update_member(update, "group", "xsd:boolean", basic2str(_obj.group), context);
	update_member(update, "principal", "xsd:string", basic2str(_obj.principal), context);
	update("Base", "AuthorizationEvent", context);
	AuthorizationEvent_closure(dynamic_cast<const vw1__AuthorizationEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PermissionEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AuthorizationEvent_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void PermissionProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PermissionProfile", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PermissionProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PermissionRemovedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PermissionRemovedEvent", context);
	update("Base", "PermissionEvent", context);
	PermissionEvent_closure(dynamic_cast<const vw1__PermissionEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PermissionRemovedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PermissionUpdatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PermissionUpdatedEvent", context);
	update_member(update, "propagate", "xsd:boolean", basic2str(_obj.propagate), context);
	update_member(update, "role", "RoleEventArgument", handle_obj_ptr(_obj.role), context);
	update("Base", "PermissionEvent", context);
	PermissionEvent_closure(dynamic_cast<const vw1__PermissionEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PermissionUpdatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.role)
			return new RoleEventArgument_closure(*_obj.role);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return PermissionEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void PhysicalNic_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PhysicalNic", context);
	update_member_with_version(update, "autoNegotiateSupported", "xsd:boolean", basic2str(_obj.autoNegotiateSupported), context, "4.1");
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update_member(update, "driver", "xsd:string", basic2str(_obj.driver), context);
	update_member_with_version(update, "fcoeConfiguration", "FcoeConfig", handle_obj_ptr(_obj.fcoeConfiguration), context, "5.0");
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "linkSpeed", "PhysicalNicLinkInfo", handle_obj_ptr(_obj.linkSpeed), context);
	update_member_with_version(update, "mac", "xsd:string", basic2str(_obj.mac), context, "2.5");
	update_member(update, "pci", "xsd:string", basic2str(_obj.pci), context);
	update_member_with_version(update, "resourcePoolSchedulerAllowed", "xsd:boolean", basic2str(_obj.resourcePoolSchedulerAllowed), context, "4.1");
	update_member_with_version(update, "resourcePoolSchedulerDisallowedReason", "xsd:string[]", a2s_basic(*_obj.resourcePoolSchedulerDisallowedReason, _obj.__sizeresourcePoolSchedulerDisallowedReason), context, "4.1");
	update_member(update, "spec", "PhysicalNicSpec", handle_obj_ptr(_obj.spec), context);
	update_member(update, "validLinkSpecification", "PhysicalNicLinkInfo[]", a2s_object(_obj.validLinkSpecification, _obj.__sizevalidLinkSpecification), context);
	update_member_with_version(update, "vmDirectPathGen2Supported", "xsd:boolean", basic2str(_obj.vmDirectPathGen2Supported), context, "4.1");
	update_member_with_version(update, "vmDirectPathGen2SupportedMode", "xsd:string", basic2str(_obj.vmDirectPathGen2SupportedMode), context, "4.1");
	update_member_with_version(update, "wakeOnLanSupported", "xsd:boolean", basic2str(_obj.wakeOnLanSupported), context, "2.5");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PhysicalNic_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		if (_obj.fcoeConfiguration)
			return new FcoeConfig_closure(*_obj.fcoeConfiguration);
		else
			return 0;
	case 5:
		if (_obj.linkSpeed)
			return new PhysicalNicLinkInfo_closure(*_obj.linkSpeed);
		else
			return 0;
	case 10:
		if (_obj.spec)
			return new PhysicalNicSpec_closure(*_obj.spec);
		else
			return 0;
	case 11:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevalidLinkSpecification)
				return new PhysicalNicLinkInfo_closure(*_obj.validLinkSpecification[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 15) << 16) + arr_index);
	}
	return 0;
}

void PhysicalNicCdpDeviceCapability_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PhysicalNicCdpDeviceCapability", context);
	update_member(update, "host", "xsd:boolean", basic2str(_obj.host), context);
	update_member(update, "igmpEnabled", "xsd:boolean", basic2str(_obj.igmpEnabled), context);
	update_member(update, "networkSwitch", "xsd:boolean", basic2str(_obj.networkSwitch), context);
	update_member(update, "repeater", "xsd:boolean", basic2str(_obj.repeater), context);
	update_member(update, "router", "xsd:boolean", basic2str(_obj.router), context);
	update_member(update, "sourceRouteBridge", "xsd:boolean", basic2str(_obj.sourceRouteBridge), context);
	update_member(update, "transparentBridge", "xsd:boolean", basic2str(_obj.transparentBridge), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PhysicalNicCdpDeviceCapability_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PhysicalNicCdpInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PhysicalNicCdpInfo", context);
	update_member(update, "address", "xsd:string", basic2str(_obj.address), context);
	update_member(update, "cdpVersion", "xsd:int", basic2str(_obj.cdpVersion), context);
	update_member(update, "deviceCapability", "PhysicalNicCdpDeviceCapability", handle_obj_ptr(_obj.deviceCapability), context);
	update_member(update, "devId", "xsd:string", basic2str(_obj.devId), context);
	update_member(update, "fullDuplex", "xsd:boolean", basic2str(_obj.fullDuplex), context);
	update_member(update, "hardwarePlatform", "xsd:string", basic2str(_obj.hardwarePlatform), context);
	update_member(update, "ipPrefix", "xsd:string", basic2str(_obj.ipPrefix), context);
	update_member(update, "ipPrefixLen", "xsd:int", basic2str(_obj.ipPrefixLen), context);
	update_member(update, "location", "xsd:string", basic2str(_obj.location), context);
	update_member(update, "mgmtAddr", "xsd:string", basic2str(_obj.mgmtAddr), context);
	update_member(update, "mtu", "xsd:int", basic2str(_obj.mtu), context);
	update_member(update, "portId", "xsd:string", basic2str(_obj.portId), context);
	update_member(update, "samples", "xsd:int", basic2str(_obj.samples), context);
	update_member(update, "softwareVersion", "xsd:string", basic2str(_obj.softwareVersion), context);
	update_member(update, "systemName", "xsd:string", basic2str(_obj.systemName), context);
	update_member(update, "systemOID", "xsd:string", basic2str(_obj.systemOID), context);
	update_member(update, "timeout", "xsd:int", basic2str(_obj.timeout), context);
	update_member(update, "ttl", "xsd:int", basic2str(_obj.ttl), context);
	update_member(update, "vlan", "xsd:int", basic2str(_obj.vlan), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PhysicalNicCdpInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.deviceCapability)
			return new PhysicalNicCdpDeviceCapability_closure(*_obj.deviceCapability);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 19) << 16) + arr_index);
	}
	return 0;
}

void PhysicalNicConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PhysicalNicConfig", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update_member(update, "spec", "PhysicalNicSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PhysicalNicConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.spec)
			return new PhysicalNicSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void PhysicalNicHint_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PhysicalNicHint", context);
	update_member(update, "vlanId", "xsd:int", basic2str(_obj.vlanId), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PhysicalNicHint_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PhysicalNicHintInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PhysicalNicHintInfo", context);
	update_member_with_version(update, "connectedSwitchPort", "PhysicalNicCdpInfo", handle_obj_ptr(_obj.connectedSwitchPort), context, "2.5");
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update_member_with_version(update, "lldpInfo", "LinkLayerDiscoveryProtocolInfo", handle_obj_ptr(_obj.lldpInfo), context, "5.0");
	update_member(update, "network", "PhysicalNicNameHint[]", a2s_object(_obj.network, _obj.__sizenetwork), context);
	update_member(update, "subnet", "PhysicalNicIpHint[]", a2s_object(_obj.subnet, _obj.__sizesubnet), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PhysicalNicHintInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.connectedSwitchPort)
			return new PhysicalNicCdpInfo_closure(*_obj.connectedSwitchPort);
		else
			return 0;
	case 2:
		if (_obj.lldpInfo)
			return new LinkLayerDiscoveryProtocolInfo_closure(*_obj.lldpInfo);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenetwork)
				return new PhysicalNicNameHint_closure(*_obj.network[i]);
			else
				return 0;
		}
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesubnet)
				return new PhysicalNicIpHint_closure(*_obj.subnet[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void PhysicalNicIpHint_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PhysicalNicIpHint", context);
	update_member(update, "ipSubnet", "xsd:string", basic2str(_obj.ipSubnet), context);
	update("Base", "PhysicalNicHint", context);
	PhysicalNicHint_closure(dynamic_cast<const vw1__PhysicalNicHint&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PhysicalNicIpHint_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PhysicalNicLinkInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PhysicalNicLinkInfo", context);
	update_member(update, "duplex", "xsd:boolean", basic2str(_obj.duplex), context);
	update_member(update, "speedMb", "xsd:int", basic2str(_obj.speedMb), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PhysicalNicLinkInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PhysicalNicNameHint_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PhysicalNicNameHint", context);
	update_member(update, "network", "xsd:string", basic2str(_obj.network), context);
	update("Base", "PhysicalNicHint", context);
	PhysicalNicHint_closure(dynamic_cast<const vw1__PhysicalNicHint&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PhysicalNicNameHint_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PhysicalNicProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PhysicalNicProfile", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PhysicalNicProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PhysicalNicSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PhysicalNicSpec", context);
	update_member(update, "ip", "HostIpConfig", handle_obj_ptr(_obj.ip), context);
	update_member(update, "linkSpeed", "PhysicalNicLinkInfo", handle_obj_ptr(_obj.linkSpeed), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PhysicalNicSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.ip)
			return new HostIpConfig_closure(*_obj.ip);
		else
			return 0;
	case 1:
		if (_obj.linkSpeed)
			return new PhysicalNicLinkInfo_closure(*_obj.linkSpeed);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void PnicUplinkProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PnicUplinkProfile", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PnicUplinkProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PodDiskLocator_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PodDiskLocator", context);
	update_member(update, "diskBackingInfo", "VirtualDeviceBackingInfo", handle_obj_ptr(_obj.diskBackingInfo), context);
	update_member(update, "diskId", "xsd:int", basic2str(_obj.diskId), context);
	update_member(update, "diskMoveType", "xsd:string", basic2str(_obj.diskMoveType), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PodDiskLocator_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.diskBackingInfo)
			return new VirtualDeviceBackingInfo_closure(*_obj.diskBackingInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void PodStorageDrsEntry_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PodStorageDrsEntry", context);
	update_member(update, "actionHistory", "ClusterActionHistory[]", a2s_object(_obj.actionHistory, _obj.__sizeactionHistory), context);
	update_member(update, "drsFault", "ClusterDrsFaults[]", a2s_object(_obj.drsFault, _obj.__sizedrsFault), context);
	update_member(update, "recommendation", "ClusterRecommendation[]", a2s_object(_obj.recommendation, _obj.__sizerecommendation), context);
	update_member(update, "storageDrsConfig", "StorageDrsConfigInfo", handle_obj_ptr(_obj.storageDrsConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PodStorageDrsEntry_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeactionHistory)
				return new ClusterActionHistory_closure(*_obj.actionHistory[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedrsFault)
				return new ClusterDrsFaults_closure(*_obj.drsFault[i]);
			else
				return 0;
		}
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerecommendation)
				return new ClusterRecommendation_closure(*_obj.recommendation[i]);
			else
				return 0;
		}
	case 3:
		if (_obj.storageDrsConfig)
			return new StorageDrsConfigInfo_closure(*_obj.storageDrsConfig);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void PolicyOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PolicyOption", context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "parameter", "KeyAnyValue[]", a2s_object(_obj.parameter, _obj.__sizeparameter), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PolicyOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeparameter)
				return new KeyAnyValue_closure(*_obj.parameter[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void PortGroupProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PortGroupProfile", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "networkPolicy", "NetworkPolicyProfile", handle_obj_ptr(_obj.networkPolicy), context);
	update_member(update, "vlan", "VlanProfile", handle_obj_ptr(_obj.vlan), context);
	update_member(update, "vswitch", "VirtualSwitchSelectionProfile", handle_obj_ptr(_obj.vswitch), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PortGroupProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.networkPolicy)
			return new NetworkPolicyProfile_closure(*_obj.networkPolicy);
		else
			return 0;
	case 3:
		if (_obj.vlan)
			return new VlanProfile_closure(*_obj.vlan);
		else
			return 0;
	case 4:
		if (_obj.vswitch)
			return new VirtualSwitchSelectionProfile_closure(*_obj.vswitch);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ApplyProfile_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void PosixUserSearchResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PosixUserSearchResult", context);
	update_member(update, "id", "xsd:int", basic2str(_obj.id), context);
	update_member(update, "shellAccess", "xsd:boolean", basic2str(_obj.shellAccess), context);
	update("Base", "UserSearchResult", context);
	UserSearchResult_closure(dynamic_cast<const vw1__UserSearchResult&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PosixUserSearchResult_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PowerSystemCapability_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PowerSystemCapability", context);
	update_member(update, "availablePolicy", "HostPowerPolicy[]", a2s_object(_obj.availablePolicy, _obj.__sizeavailablePolicy), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PowerSystemCapability_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeavailablePolicy)
				return new HostPowerPolicy_closure(*_obj.availablePolicy[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void PowerSystemInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PowerSystemInfo", context);
	update_member(update, "currentPolicy", "HostPowerPolicy", handle_obj_ptr(_obj.currentPolicy), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PowerSystemInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.currentPolicy)
			return new HostPowerPolicy_closure(*_obj.currentPolicy);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void PrivilegePolicyDef_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PrivilegePolicyDef", context);
	update_member(update, "createPrivilege", "xsd:string", basic2str(_obj.createPrivilege), context);
	update_member(update, "deletePrivilege", "xsd:string", basic2str(_obj.deletePrivilege), context);
	update_member(update, "readPrivilege", "xsd:string", basic2str(_obj.readPrivilege), context);
	update_member(update, "updatePrivilege", "xsd:string", basic2str(_obj.updatePrivilege), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PrivilegePolicyDef_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProductComponentInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProductComponentInfo", context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "release", "xsd:int", basic2str(_obj.release), context);
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProductComponentInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileApplyProfileElement_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileApplyProfileElement", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileApplyProfileElement_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileApplyProfileProperty_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileApplyProfileProperty", context);
	update_member(update, "array", "xsd:boolean", basic2str(_obj.array), context);
	update_member(update, "profile", "ApplyProfile[]", a2s_object(_obj.profile, _obj.__sizeprofile), context);
	update_member(update, "propertyName", "xsd:string", basic2str(_obj.propertyName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileApplyProfileProperty_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeprofile)
				return new ApplyProfile_closure(*_obj.profile[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ProfileAssociatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileAssociatedEvent", context);
	update("Base", "ProfileEvent", context);
	ProfileEvent_closure(dynamic_cast<const vw1__ProfileEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileAssociatedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileChangedEvent", context);
	update("Base", "ProfileEvent", context);
	ProfileEvent_closure(dynamic_cast<const vw1__ProfileEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileCompositeExpression_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileCompositeExpression", context);
	update_member(update, "expressionName", "xsd:string[]", a2s_basic(*_obj.expressionName, _obj.__sizeexpressionName), context);
	update_member(update, "operator_", "xsd:string", basic2str(_obj.operator_), context);
	update("Base", "ProfileExpression", context);
	ProfileExpression_closure(dynamic_cast<const vw1__ProfileExpression&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileCompositeExpression_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileCompositePolicyOptionMetadata_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileCompositePolicyOptionMetadata", context);
	update_member(update, "option", "xsd:string[]", a2s_basic(*_obj.option, _obj.__sizeoption), context);
	update("Base", "ProfilePolicyOptionMetadata", context);
	ProfilePolicyOptionMetadata_closure(dynamic_cast<const vw1__ProfilePolicyOptionMetadata&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileCompositePolicyOptionMetadata_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileConfigInfo", context);
	update_member(update, "annotation", "xsd:string", basic2str(_obj.annotation), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileConfigInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileCreateSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileCreateSpec", context);
	update_member(update, "annotation", "xsd:string", basic2str(_obj.annotation), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileCreateSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileCreatedEvent", context);
	update("Base", "ProfileEvent", context);
	ProfileEvent_closure(dynamic_cast<const vw1__ProfileEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileCreatedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileDeferredPolicyOptionParameter_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileDeferredPolicyOptionParameter", context);
	update_member(update, "inputPath", "ProfilePropertyPath", handle_obj_ptr(_obj.inputPath), context);
	update_member(update, "parameter", "KeyAnyValue[]", a2s_object(_obj.parameter, _obj.__sizeparameter), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileDeferredPolicyOptionParameter_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.inputPath)
			return new ProfilePropertyPath_closure(*_obj.inputPath);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeparameter)
				return new KeyAnyValue_closure(*_obj.parameter[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ProfileDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileDescription", context);
	update_member(update, "section", "ProfileDescriptionSection[]", a2s_object(_obj.section, _obj.__sizesection), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileDescription_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesection)
				return new ProfileDescriptionSection_closure(*_obj.section[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ProfileDescriptionSection_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileDescriptionSection", context);
	update_member(update, "description", "ExtendedElementDescription", handle_obj_ptr(_obj.description), context);
	update_member(update, "message", "LocalizableMessage[]", a2s_object(_obj.message, _obj.__sizemessage), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileDescriptionSection_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.description)
			return new ExtendedElementDescription_closure(*_obj.description);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemessage)
				return new LocalizableMessage_closure(*_obj.message[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ProfileDissociatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileDissociatedEvent", context);
	update("Base", "ProfileEvent", context);
	ProfileEvent_closure(dynamic_cast<const vw1__ProfileEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileDissociatedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileEvent", context);
	update_member(update, "profile", "ProfileEventArgument", handle_obj_ptr(_obj.profile), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.profile)
			return new ProfileEventArgument_closure(*_obj.profile);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return Event_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ProfileEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileEventArgument", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "profile", "Profile", handle_obj_ptr(_obj.profile), context);
	update("Base", "EventArgument", context);
	EventArgument_closure(dynamic_cast<const vw1__EventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileEventArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.profile? 
			get_closure_from_mor(Profile(_obj.profile)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return EventArgument_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ProfileExecuteError_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileExecuteError", context);
	update_member(update, "message", "LocalizableMessage", handle_obj_ptr(_obj.message), context);
	update_member(update, "path", "ProfilePropertyPath", handle_obj_ptr(_obj.path), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileExecuteError_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.message)
			return new LocalizableMessage_closure(*_obj.message);
		else
			return 0;
	case 1:
		if (_obj.path)
			return new ProfilePropertyPath_closure(*_obj.path);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ProfileExecuteResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileExecuteResult", context);
	update_member(update, "configSpec", "HostConfigSpec", handle_obj_ptr(_obj.configSpec), context);
	update_member(update, "error", "ProfileExecuteError[]", a2s_object(_obj.error, _obj.__sizeerror), context);
	update_member(update, "inapplicablePath", "xsd:string[]", a2s_basic(*_obj.inapplicablePath, _obj.__sizeinapplicablePath), context);
	update_member(update, "requireInput", "ProfileDeferredPolicyOptionParameter[]", a2s_object(_obj.requireInput, _obj.__sizerequireInput), context);
	update_member(update, "status", "xsd:string", basic2str(_obj.status), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileExecuteResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.configSpec)
			return new HostConfigSpec_closure(*_obj.configSpec);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeerror)
				return new ProfileExecuteError_closure(*_obj.error[i]);
			else
				return 0;
		}
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerequireInput)
				return new ProfileDeferredPolicyOptionParameter_closure(*_obj.requireInput[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void ProfileExpression_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileExpression", context);
	update_member(update, "displayName", "xsd:string", basic2str(_obj.displayName), context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "negated", "xsd:boolean", basic2str(_obj.negated), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileExpression_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileExpressionMetadata_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileExpressionMetadata", context);
	update_member(update, "expressionId", "ExtendedElementDescription", handle_obj_ptr(_obj.expressionId), context);
	update_member(update, "parameter", "ProfileParameterMetadata[]", a2s_object(_obj.parameter, _obj.__sizeparameter), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileExpressionMetadata_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.expressionId)
			return new ExtendedElementDescription_closure(*_obj.expressionId);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeparameter)
				return new ProfileParameterMetadata_closure(*_obj.parameter[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ProfileMetadata_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileMetadata", context);
	update_member(update, "description", "ExtendedDescription", handle_obj_ptr(_obj.description), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member_with_version(update, "profileTypeName", "xsd:string", basic2str(_obj.profileTypeName), context, "5.0");
	update_member_with_version(update, "sortSpec", "ProfileMetadataProfileSortSpec[]", a2s_object(_obj.sortSpec, _obj.__sizesortSpec), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileMetadata_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.description)
			return new ExtendedDescription_closure(*_obj.description);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesortSpec)
				return new ProfileMetadataProfileSortSpec_closure(*_obj.sortSpec[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void ProfileMetadataProfileSortSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileMetadataProfileSortSpec", context);
	update_member(update, "parameter", "xsd:string", basic2str(_obj.parameter), context);
	update_member(update, "policyId", "xsd:string", basic2str(_obj.policyId), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileMetadataProfileSortSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileParameterMetadata_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileParameterMetadata", context);
	update_member(update, "defaultValue", "xsd:anyType", basic2str(_obj.defaultValue), context);
	update_member(update, "id", "ExtendedElementDescription", handle_obj_ptr(_obj.id), context);
	update_member(update, "optional", "xsd:boolean", basic2str(_obj.optional), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileParameterMetadata_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.id)
			return new ExtendedElementDescription_closure(*_obj.id);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void ProfilePolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfilePolicy", context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "policyOption", "PolicyOption", handle_obj_ptr(_obj.policyOption), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfilePolicy_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.policyOption)
			return new PolicyOption_closure(*_obj.policyOption);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ProfilePolicyMetadata_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfilePolicyMetadata", context);
	update_member(update, "id", "ExtendedElementDescription", handle_obj_ptr(_obj.id), context);
	update_member(update, "possibleOption", "ProfilePolicyOptionMetadata[]", a2s_object(_obj.possibleOption, _obj.__sizepossibleOption), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfilePolicyMetadata_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.id)
			return new ExtendedElementDescription_closure(*_obj.id);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepossibleOption)
				return new ProfilePolicyOptionMetadata_closure(*_obj.possibleOption[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ProfilePolicyOptionMetadata_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfilePolicyOptionMetadata", context);
	update_member(update, "id", "ExtendedElementDescription", handle_obj_ptr(_obj.id), context);
	update_member(update, "parameter", "ProfileParameterMetadata[]", a2s_object(_obj.parameter, _obj.__sizeparameter), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfilePolicyOptionMetadata_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.id)
			return new ExtendedElementDescription_closure(*_obj.id);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeparameter)
				return new ProfileParameterMetadata_closure(*_obj.parameter[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ProfileProfileStructure_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileProfileStructure", context);
	update_member(update, "child", "ProfileProfileStructureProperty[]", a2s_object(_obj.child, _obj.__sizechild), context);
	update_member(update, "profileTypeName", "xsd:string", basic2str(_obj.profileTypeName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileProfileStructure_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizechild)
				return new ProfileProfileStructureProperty_closure(*_obj.child[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ProfileProfileStructureProperty_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileProfileStructureProperty", context);
	update_member(update, "array", "xsd:boolean", basic2str(_obj.array), context);
	update_member(update, "element", "ProfileProfileStructure", handle_obj_ptr(_obj.element), context);
	update_member(update, "propertyName", "xsd:string", basic2str(_obj.propertyName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileProfileStructureProperty_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.element)
			return new ProfileProfileStructure_closure(*_obj.element);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ProfilePropertyPath_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfilePropertyPath", context);
	update_member(update, "policyId", "xsd:string", basic2str(_obj.policyId), context);
	update_member(update, "profilePath", "xsd:string", basic2str(_obj.profilePath), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfilePropertyPath_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileReferenceHostChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileReferenceHostChangedEvent", context);
	update_member(update, "referenceHost", "HostSystem", handle_obj_ptr(_obj.referenceHost), context);
	update("Base", "ProfileEvent", context);
	ProfileEvent_closure(dynamic_cast<const vw1__ProfileEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileReferenceHostChangedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.referenceHost? 
			get_closure_from_mor(HostSystem(_obj.referenceHost)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return ProfileEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ProfileRemovedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileRemovedEvent", context);
	update("Base", "ProfileEvent", context);
	ProfileEvent_closure(dynamic_cast<const vw1__ProfileEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileRemovedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileSerializedCreateSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileSerializedCreateSpec", context);
	update_member(update, "profileConfigString", "xsd:string", basic2str(_obj.profileConfigString), context);
	update("Base", "ProfileCreateSpec", context);
	ProfileCreateSpec_closure(dynamic_cast<const vw1__ProfileCreateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileSerializedCreateSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ProfileSimpleExpression_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileSimpleExpression", context);
	update_member(update, "expressionType", "xsd:string", basic2str(_obj.expressionType), context);
	update_member(update, "parameter", "KeyAnyValue[]", a2s_object(_obj.parameter, _obj.__sizeparameter), context);
	update("Base", "ProfileExpression", context);
	ProfileExpression_closure(dynamic_cast<const vw1__ProfileExpression&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileSimpleExpression_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeparameter)
				return new KeyAnyValue_closure(*_obj.parameter[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ProfileExpression_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ProfileUpdateFailedUpdateFailure_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileUpdateFailedUpdateFailure", context);
	update_member(update, "errMsg", "LocalizableMessage", handle_obj_ptr(_obj.errMsg), context);
	update_member(update, "profilePath", "ProfilePropertyPath", handle_obj_ptr(_obj.profilePath), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileUpdateFailedUpdateFailure_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.errMsg)
			return new LocalizableMessage_closure(*_obj.errMsg);
		else
			return 0;
	case 1:
		if (_obj.profilePath)
			return new ProfilePropertyPath_closure(*_obj.profilePath);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void PropertyChange_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PropertyChange", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "op", "PropertyChangeOp", handle_obj(_obj.op), context);
	update_member(update, "val", "xsd:anyType", basic2str(_obj.val), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PropertyChange_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PropertyFilterSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PropertyFilterSpec", context);
	update_member(update, "objectSet", "ObjectSpec[]", a2s_object(_obj.objectSet, _obj.__sizeobjectSet), context);
	update_member(update, "propSet", "PropertySpec[]", a2s_object(_obj.propSet, _obj.__sizepropSet), context);
	update_member_with_version(update, "reportMissingObjectsInResults", "xsd:boolean", basic2str(_obj.reportMissingObjectsInResults), context, "4.1");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PropertyFilterSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeobjectSet)
				return new ObjectSpec_closure(*_obj.objectSet[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepropSet)
				return new PropertySpec_closure(*_obj.propSet[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void PropertyFilterUpdate_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PropertyFilterUpdate", context);
	update_member(update, "filter", "PropertyFilter", handle_obj_ptr(_obj.filter), context);
	update_member(update, "missingSet", "MissingObject[]", a2s_object(_obj.missingSet, _obj.__sizemissingSet), context);
	update_member(update, "objectSet", "ObjectUpdate[]", a2s_object(_obj.objectSet, _obj.__sizeobjectSet), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PropertyFilterUpdate_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.filter? 
			get_closure_from_mor(PropertyFilter(_obj.filter)) : 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemissingSet)
				return new MissingObject_closure(*_obj.missingSet[i]);
			else
				return 0;
		}
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeobjectSet)
				return new ObjectUpdate_closure(*_obj.objectSet[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void PropertySpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PropertySpec", context);
	update_member(update, "all", "xsd:boolean", basic2str(_obj.all), context);
	update_member(update, "pathSet", "xsd:string[]", a2s_basic(*_obj.pathSet, _obj.__sizepathSet), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PropertySpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RecurrentTaskScheduler_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RecurrentTaskScheduler", context);
	update_member(update, "interval", "xsd:int", basic2str(_obj.interval), context);
	update("Base", "TaskScheduler", context);
	TaskScheduler_closure(dynamic_cast<const vw1__TaskScheduler&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RecurrentTaskScheduler_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RemoteTSMEnabledEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RemoteTSMEnabledEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RemoteTSMEnabledEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ReplicationInfoDiskSettings_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ReplicationInfoDiskSettings", context);
	update_member(update, "diskReplicationId", "xsd:string", basic2str(_obj.diskReplicationId), context);
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ReplicationInfoDiskSettings_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ReplicationVmProgressInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ReplicationVmProgressInfo", context);
	update_member(update, "bytesToTransfer", "xsd:long", basic2str(_obj.bytesToTransfer), context);
	update_member(update, "bytesTransferred", "xsd:long", basic2str(_obj.bytesTransferred), context);
	update_member(update, "checksumComparedBytes", "xsd:long", basic2str(_obj.checksumComparedBytes), context);
	update_member(update, "checksumTotalBytes", "xsd:long", basic2str(_obj.checksumTotalBytes), context);
	update_member(update, "progress", "xsd:int", basic2str(_obj.progress), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ReplicationVmProgressInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ResourceAllocationInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourceAllocationInfo", context);
	update_member(update, "expandableReservation", "xsd:boolean", basic2str(_obj.expandableReservation), context);
	update_member(update, "limit", "xsd:long", basic2str(_obj.limit), context);
	update_member_with_version(update, "overheadLimit", "xsd:long", basic2str(_obj.overheadLimit), context, "2.5");
	update_member(update, "reservation", "xsd:long", basic2str(_obj.reservation), context);
	update_member(update, "shares", "SharesInfo", handle_obj_ptr(_obj.shares), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourceAllocationInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 4:
		if (_obj.shares)
			return new SharesInfo_closure(*_obj.shares);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void ResourceAllocationOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourceAllocationOption", context);
	update_member(update, "sharesOption", "SharesOption", handle_obj_ptr(_obj.sharesOption), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourceAllocationOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.sharesOption)
			return new SharesOption_closure(*_obj.sharesOption);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ResourceConfigOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourceConfigOption", context);
	update_member(update, "cpuAllocationOption", "ResourceAllocationOption", handle_obj_ptr(_obj.cpuAllocationOption), context);
	update_member(update, "memoryAllocationOption", "ResourceAllocationOption", handle_obj_ptr(_obj.memoryAllocationOption), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourceConfigOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.cpuAllocationOption)
			return new ResourceAllocationOption_closure(*_obj.cpuAllocationOption);
		else
			return 0;
	case 1:
		if (_obj.memoryAllocationOption)
			return new ResourceAllocationOption_closure(*_obj.memoryAllocationOption);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ResourceConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourceConfigSpec", context);
	update_member(update, "changeVersion", "xsd:string", basic2str(_obj.changeVersion), context);
	update_member(update, "cpuAllocation", "ResourceAllocationInfo", handle_obj_ptr(_obj.cpuAllocation), context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "lastModified", "xsd:dateTime", basic2str(_obj.lastModified), context);
	update_member(update, "memoryAllocation", "ResourceAllocationInfo", handle_obj_ptr(_obj.memoryAllocation), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourceConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.cpuAllocation)
			return new ResourceAllocationInfo_closure(*_obj.cpuAllocation);
		else
			return 0;
	case 2:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	case 4:
		if (_obj.memoryAllocation)
			return new ResourceAllocationInfo_closure(*_obj.memoryAllocation);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void ResourcePoolCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourcePoolCreatedEvent", context);
	update_member(update, "parent", "ResourcePoolEventArgument", handle_obj_ptr(_obj.parent), context);
	update("Base", "ResourcePoolEvent", context);
	ResourcePoolEvent_closure(dynamic_cast<const vw1__ResourcePoolEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourcePoolCreatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.parent)
			return new ResourcePoolEventArgument_closure(*_obj.parent);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ResourcePoolEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ResourcePoolDestroyedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourcePoolDestroyedEvent", context);
	update("Base", "ResourcePoolEvent", context);
	ResourcePoolEvent_closure(dynamic_cast<const vw1__ResourcePoolEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourcePoolDestroyedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ResourcePoolEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourcePoolEvent", context);
	update_member(update, "resourcePool", "ResourcePoolEventArgument", handle_obj_ptr(_obj.resourcePool), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourcePoolEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.resourcePool)
			return new ResourcePoolEventArgument_closure(*_obj.resourcePool);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return Event_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ResourcePoolEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourcePoolEventArgument", context);
	update_member(update, "resourcePool", "ResourcePool", handle_obj_ptr(_obj.resourcePool), context);
	update("Base", "EntityEventArgument", context);
	EntityEventArgument_closure(dynamic_cast<const vw1__EntityEventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourcePoolEventArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.resourcePool? 
			get_closure_from_mor(ResourcePool(_obj.resourcePool)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return EntityEventArgument_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ResourcePoolMovedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourcePoolMovedEvent", context);
	update_member(update, "newParent", "ResourcePoolEventArgument", handle_obj_ptr(_obj.newParent), context);
	update_member(update, "oldParent", "ResourcePoolEventArgument", handle_obj_ptr(_obj.oldParent), context);
	update("Base", "ResourcePoolEvent", context);
	ResourcePoolEvent_closure(dynamic_cast<const vw1__ResourcePoolEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourcePoolMovedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.newParent)
			return new ResourcePoolEventArgument_closure(*_obj.newParent);
		else
			return 0;
	case 1:
		if (_obj.oldParent)
			return new ResourcePoolEventArgument_closure(*_obj.oldParent);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ResourcePoolEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ResourcePoolQuickStats_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourcePoolQuickStats", context);
	update_member(update, "balloonedMemory", "xsd:long", basic2str(_obj.balloonedMemory), context);
	update_member_with_version(update, "compressedMemory", "xsd:long", basic2str(_obj.compressedMemory), context, "4.1");
	update_member(update, "consumedOverheadMemory", "xsd:long", basic2str(_obj.consumedOverheadMemory), context);
	update_member(update, "distributedCpuEntitlement", "xsd:long", basic2str(_obj.distributedCpuEntitlement), context);
	update_member(update, "distributedMemoryEntitlement", "xsd:long", basic2str(_obj.distributedMemoryEntitlement), context);
	update_member(update, "guestMemoryUsage", "xsd:long", basic2str(_obj.guestMemoryUsage), context);
	update_member(update, "hostMemoryUsage", "xsd:long", basic2str(_obj.hostMemoryUsage), context);
	update_member(update, "overallCpuDemand", "xsd:long", basic2str(_obj.overallCpuDemand), context);
	update_member(update, "overallCpuUsage", "xsd:long", basic2str(_obj.overallCpuUsage), context);
	update_member(update, "overheadMemory", "xsd:long", basic2str(_obj.overheadMemory), context);
	update_member(update, "privateMemory", "xsd:long", basic2str(_obj.privateMemory), context);
	update_member(update, "sharedMemory", "xsd:long", basic2str(_obj.sharedMemory), context);
	update_member(update, "staticCpuEntitlement", "xsd:int", basic2str(_obj.staticCpuEntitlement), context);
	update_member(update, "staticMemoryEntitlement", "xsd:int", basic2str(_obj.staticMemoryEntitlement), context);
	update_member(update, "swappedMemory", "xsd:long", basic2str(_obj.swappedMemory), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourcePoolQuickStats_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ResourcePoolReconfiguredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourcePoolReconfiguredEvent", context);
	update("Base", "ResourcePoolEvent", context);
	ResourcePoolEvent_closure(dynamic_cast<const vw1__ResourcePoolEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourcePoolReconfiguredEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ResourcePoolResourceUsage_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourcePoolResourceUsage", context);
	update_member(update, "maxUsage", "xsd:long", basic2str(_obj.maxUsage), context);
	update_member(update, "overallUsage", "xsd:long", basic2str(_obj.overallUsage), context);
	update_member(update, "reservationUsed", "xsd:long", basic2str(_obj.reservationUsed), context);
	update_member(update, "reservationUsedForVm", "xsd:long", basic2str(_obj.reservationUsedForVm), context);
	update_member(update, "unreservedForPool", "xsd:long", basic2str(_obj.unreservedForPool), context);
	update_member(update, "unreservedForVm", "xsd:long", basic2str(_obj.unreservedForVm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourcePoolResourceUsage_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ResourcePoolRuntimeInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourcePoolRuntimeInfo", context);
	update_member(update, "cpu", "ResourcePoolResourceUsage", handle_obj_ptr(_obj.cpu), context);
	update_member(update, "memory", "ResourcePoolResourceUsage", handle_obj_ptr(_obj.memory), context);
	update_member(update, "overallStatus", "ManagedEntityStatus", handle_obj(_obj.overallStatus), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourcePoolRuntimeInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.cpu)
			return new ResourcePoolResourceUsage_closure(*_obj.cpu);
		else
			return 0;
	case 1:
		if (_obj.memory)
			return new ResourcePoolResourceUsage_closure(*_obj.memory);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ResourcePoolSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourcePoolSummary", context);
	update_member(update, "config", "ResourceConfigSpec", handle_obj_ptr(_obj.config), context);
	update_member_with_version(update, "configuredMemoryMB", "xsd:int", basic2str(_obj.configuredMemoryMB), context, "4.0");
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member_with_version(update, "quickStats", "ResourcePoolQuickStats", handle_obj_ptr(_obj.quickStats), context, "4.0");
	update_member(update, "runtime", "ResourcePoolRuntimeInfo", handle_obj_ptr(_obj.runtime), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourcePoolSummary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.config)
			return new ResourceConfigSpec_closure(*_obj.config);
		else
			return 0;
	case 3:
		if (_obj.quickStats)
			return new ResourcePoolQuickStats_closure(*_obj.quickStats);
		else
			return 0;
	case 4:
		if (_obj.runtime)
			return new ResourcePoolRuntimeInfo_closure(*_obj.runtime);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void ResourceViolatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourceViolatedEvent", context);
	update("Base", "ResourcePoolEvent", context);
	ResourcePoolEvent_closure(dynamic_cast<const vw1__ResourcePoolEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourceViolatedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RetrieveOptions_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RetrieveOptions", context);
	update_member(update, "maxObjects", "xsd:int", basic2str(_obj.maxObjects), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RetrieveOptions_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RetrieveResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RetrieveResult", context);
	update_member(update, "objects", "ObjectContent[]", a2s_object(_obj.objects, _obj.__sizeobjects), context);
	update_member(update, "token", "xsd:string", basic2str(_obj.token), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RetrieveResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeobjects)
				return new ObjectContent_closure(*_obj.objects[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void RoleAddedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RoleAddedEvent", context);
	update_member(update, "privilegeList", "xsd:string[]", a2s_basic(*_obj.privilegeList, _obj.__sizeprivilegeList), context);
	update("Base", "RoleEvent", context);
	RoleEvent_closure(dynamic_cast<const vw1__RoleEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RoleAddedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RoleEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RoleEvent", context);
	update_member(update, "role", "RoleEventArgument", handle_obj_ptr(_obj.role), context);
	update("Base", "AuthorizationEvent", context);
	AuthorizationEvent_closure(dynamic_cast<const vw1__AuthorizationEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RoleEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.role)
			return new RoleEventArgument_closure(*_obj.role);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return AuthorizationEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void RoleEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RoleEventArgument", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "roleId", "xsd:int", basic2str(_obj.roleId), context);
	update("Base", "EventArgument", context);
	EventArgument_closure(dynamic_cast<const vw1__EventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RoleEventArgument_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RoleRemovedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RoleRemovedEvent", context);
	update("Base", "RoleEvent", context);
	RoleEvent_closure(dynamic_cast<const vw1__RoleEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RoleRemovedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RoleUpdatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RoleUpdatedEvent", context);
	update_member(update, "privilegeList", "xsd:string[]", a2s_basic(*_obj.privilegeList, _obj.__sizeprivilegeList), context);
	update("Base", "RoleEvent", context);
	RoleEvent_closure(dynamic_cast<const vw1__RoleEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RoleUpdatedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RunScriptAction_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RunScriptAction", context);
	update_member(update, "script", "xsd:string", basic2str(_obj.script), context);
	update("Base", "Action", context);
	Action_closure(dynamic_cast<const vw1__Action&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RunScriptAction_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SSPIAuthentication_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SSPIAuthentication", context);
	update_member(update, "sspiToken", "xsd:string", basic2str(_obj.sspiToken), context);
	update("Base", "GuestAuthentication", context);
	GuestAuthentication_closure(dynamic_cast<const vw1__GuestAuthentication&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SSPIAuthentication_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ScheduledTaskCompletedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskCompletedEvent", context);
	update("Base", "ScheduledTaskEvent", context);
	ScheduledTaskEvent_closure(dynamic_cast<const vw1__ScheduledTaskEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTaskCompletedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ScheduledTaskCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskCreatedEvent", context);
	update("Base", "ScheduledTaskEvent", context);
	ScheduledTaskEvent_closure(dynamic_cast<const vw1__ScheduledTaskEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTaskCreatedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ScheduledTaskDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskDescription", context);
	update_member(update, "action", "TypeDescription[]", a2s_object(_obj.action, _obj.__sizeaction), context);
	update_member(update, "dayOfWeek", "ElementDescription[]", a2s_object(_obj.dayOfWeek, _obj.__sizedayOfWeek), context);
	update_member(update, "schedulerInfo", "ScheduledTaskDetail[]", a2s_object(_obj.schedulerInfo, _obj.__sizeschedulerInfo), context);
	update_member(update, "state", "ElementDescription[]", a2s_object(_obj.state, _obj.__sizestate), context);
	update_member(update, "weekOfMonth", "ElementDescription[]", a2s_object(_obj.weekOfMonth, _obj.__sizeweekOfMonth), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTaskDescription_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeaction)
				return new TypeDescription_closure(*_obj.action[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedayOfWeek)
				return new ElementDescription_closure(*_obj.dayOfWeek[i]);
			else
				return 0;
		}
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeschedulerInfo)
				return new ScheduledTaskDetail_closure(*_obj.schedulerInfo[i]);
			else
				return 0;
		}
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizestate)
				return new ElementDescription_closure(*_obj.state[i]);
			else
				return 0;
		}
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeweekOfMonth)
				return new ElementDescription_closure(*_obj.weekOfMonth[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void ScheduledTaskDetail_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskDetail", context);
	update_member(update, "frequency", "xsd:string", basic2str(_obj.frequency), context);
	update("Base", "TypeDescription", context);
	TypeDescription_closure(dynamic_cast<const vw1__TypeDescription&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTaskDetail_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ScheduledTaskEmailCompletedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskEmailCompletedEvent", context);
	update_member(update, "to", "xsd:string", basic2str(_obj.to), context);
	update("Base", "ScheduledTaskEvent", context);
	ScheduledTaskEvent_closure(dynamic_cast<const vw1__ScheduledTaskEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTaskEmailCompletedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ScheduledTaskEmailFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskEmailFailedEvent", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update_member(update, "to", "xsd:string", basic2str(_obj.to), context);
	update("Base", "ScheduledTaskEvent", context);
	ScheduledTaskEvent_closure(dynamic_cast<const vw1__ScheduledTaskEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTaskEmailFailedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ScheduledTaskEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ScheduledTaskEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskEvent", context);
	update_member(update, "entity", "ManagedEntityEventArgument", handle_obj_ptr(_obj.entity), context);
	update_member(update, "scheduledTask", "ScheduledTaskEventArgument", handle_obj_ptr(_obj.scheduledTask), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTaskEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.entity)
			return new ManagedEntityEventArgument_closure(*_obj.entity);
		else
			return 0;
	case 1:
		if (_obj.scheduledTask)
			return new ScheduledTaskEventArgument_closure(*_obj.scheduledTask);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return Event_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ScheduledTaskEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskEventArgument", context);
	update_member(update, "scheduledTask", "ScheduledTask", handle_obj_ptr(_obj.scheduledTask), context);
	update("Base", "EntityEventArgument", context);
	EntityEventArgument_closure(dynamic_cast<const vw1__EntityEventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTaskEventArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.scheduledTask? 
			get_closure_from_mor(ScheduledTask(_obj.scheduledTask)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return EntityEventArgument_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ScheduledTaskFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskFailedEvent", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "ScheduledTaskEvent", context);
	ScheduledTaskEvent_closure(dynamic_cast<const vw1__ScheduledTaskEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTaskFailedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ScheduledTaskEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ScheduledTaskInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskInfo", context);
	update_member(update, "activeTask", "Task", handle_obj_ptr(_obj.activeTask), context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "error", "LocalizedMethodFault", handle_obj_ptr(_obj.error), context);
	update_member(update, "lastModifiedTime", "xsd:dateTime", basic2str(_obj.lastModifiedTime), context);
	update_member(update, "lastModifiedUser", "xsd:string", basic2str(_obj.lastModifiedUser), context);
	update_member(update, "nextRunTime", "xsd:dateTime", basic2str(_obj.nextRunTime), context);
	update_member(update, "prevRunTime", "xsd:dateTime", basic2str(_obj.prevRunTime), context);
	update_member(update, "progress", "xsd:int", basic2str(_obj.progress), context);
	update_member(update, "result", "xsd:anyType", basic2str(_obj.result), context);
	update_member(update, "scheduledTask", "ScheduledTask", handle_obj_ptr(_obj.scheduledTask), context);
	update_member(update, "state", "TaskInfoState", handle_obj(_obj.state), context);
	update_member_with_version(update, "taskObject", "ManagedObjectReference", handle_obj_ptr(_obj.taskObject), context, "4.0");
	update("Base", "ScheduledTaskSpec", context);
	ScheduledTaskSpec_closure(dynamic_cast<const vw1__ScheduledTaskSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTaskInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.activeTask? 
			get_closure_from_mor(Task(_obj.activeTask)) : 0;
	case 1:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	case 2:
		if (_obj.error)
			return new LocalizedMethodFault_closure(*_obj.error);
		else
			return 0;
	case 9:
		return _obj.scheduledTask? 
			get_closure_from_mor(ScheduledTask(_obj.scheduledTask)) : 0;
	case 11:
		if (_obj.taskObject)
			return new ManagedObjectReference_closure(*_obj.taskObject);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ScheduledTaskSpec_closure(_obj).get_sub_closure(((prop_index - 12) << 16) + arr_index);
	}
	return 0;
}

void ScheduledTaskReconfiguredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskReconfiguredEvent", context);
	update("Base", "ScheduledTaskEvent", context);
	ScheduledTaskEvent_closure(dynamic_cast<const vw1__ScheduledTaskEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTaskReconfiguredEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ScheduledTaskRemovedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskRemovedEvent", context);
	update("Base", "ScheduledTaskEvent", context);
	ScheduledTaskEvent_closure(dynamic_cast<const vw1__ScheduledTaskEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTaskRemovedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ScheduledTaskSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskSpec", context);
	update_member(update, "action", "Action", handle_obj_ptr(_obj.action), context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "notification", "xsd:string", basic2str(_obj.notification), context);
	update_member(update, "scheduler", "TaskScheduler", handle_obj_ptr(_obj.scheduler), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTaskSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.action)
			return new Action_closure(*_obj.action);
		else
			return 0;
	case 5:
		if (_obj.scheduler)
			return new TaskScheduler_closure(*_obj.scheduler);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void ScheduledTaskStartedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskStartedEvent", context);
	update("Base", "ScheduledTaskEvent", context);
	ScheduledTaskEvent_closure(dynamic_cast<const vw1__ScheduledTaskEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTaskStartedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ScsiLun_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScsiLun", context);
	update_member_with_version(update, "alternateName", "ScsiLunDurableName[]", a2s_object(_obj.alternateName, _obj.__sizealternateName), context, "2.5");
	update_member(update, "canonicalName", "xsd:string", basic2str(_obj.canonicalName), context);
	update_member_with_version(update, "capabilities", "ScsiLunCapabilities", handle_obj_ptr(_obj.capabilities), context, "4.0");
	update_member_with_version(update, "descriptor", "ScsiLunDescriptor[]", a2s_object(_obj.descriptor, _obj.__sizedescriptor), context, "4.0");
	update_member_with_version(update, "displayName", "xsd:string", basic2str(_obj.displayName), context, "4.0");
	update_member(update, "durableName", "ScsiLunDurableName", handle_obj_ptr(_obj.durableName), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "lunType", "xsd:string", basic2str(_obj.lunType), context);
	update_member(update, "model", "xsd:string", basic2str(_obj.model), context);
	update_member(update, "operationalState", "xsd:string[]", a2s_basic(*_obj.operationalState, _obj.__sizeoperationalState), context);
	update_member(update, "queueDepth", "xsd:int", basic2str(_obj.queueDepth), context);
	update_member(update, "revision", "xsd:string", basic2str(_obj.revision), context);
	update_member(update, "scsiLevel", "xsd:int", basic2str(_obj.scsiLevel), context);
	update_member(update, "serialNumber", "xsd:string", basic2str(_obj.serialNumber), context);
	update_member_with_version(update, "standardInquiry", "xsd:byte[]", a2s_basic(_obj.standardInquiry, _obj.__sizestandardInquiry), context, "2.5");
	update_member(update, "uuid", "xsd:string", basic2str(_obj.uuid), context);
	update_member(update, "vendor", "xsd:string", basic2str(_obj.vendor), context);
	update_member_with_version(update, "vStorageSupport", "xsd:string", basic2str(_obj.vStorageSupport), context, "4.1");
	update("Base", "HostDevice", context);
	HostDevice_closure(dynamic_cast<const vw1__HostDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScsiLun_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizealternateName)
				return new ScsiLunDurableName_closure(*_obj.alternateName[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.capabilities)
			return new ScsiLunCapabilities_closure(*_obj.capabilities);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedescriptor)
				return new ScsiLunDescriptor_closure(*_obj.descriptor[i]);
			else
				return 0;
		}
	case 5:
		if (_obj.durableName)
			return new ScsiLunDurableName_closure(*_obj.durableName);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostDevice_closure(_obj).get_sub_closure(((prop_index - 18) << 16) + arr_index);
	}
	return 0;
}

void ScsiLunCapabilities_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScsiLunCapabilities", context);
	update_member(update, "updateDisplayNameSupported", "xsd:boolean", basic2str(_obj.updateDisplayNameSupported), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScsiLunCapabilities_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ScsiLunDescriptor_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScsiLunDescriptor", context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "quality", "xsd:string", basic2str(_obj.quality), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScsiLunDescriptor_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ScsiLunDurableName_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScsiLunDurableName", context);
	update_member(update, "data", "xsd:byte[]", a2s_basic(_obj.data, _obj.__sizedata), context);
	update_member(update, "namespace_", "xsd:string", basic2str(_obj.namespace_), context);
	update_member(update, "namespaceId", "xsd:byte", basic2str(_obj.namespaceId), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScsiLunDurableName_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SecurityProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SecurityProfile", context);
	update_member_with_version(update, "permission", "PermissionProfile[]", a2s_object(_obj.permission, _obj.__sizepermission), context, "4.1");
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SecurityProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepermission)
				return new PermissionProfile_closure(*_obj.permission[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ApplyProfile_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void SelectionSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SelectionSpec", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SelectionSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SendEmailAction_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SendEmailAction", context);
	update_member(update, "body", "xsd:string", basic2str(_obj.body), context);
	update_member(update, "ccList", "xsd:string", basic2str(_obj.ccList), context);
	update_member(update, "subject", "xsd:string", basic2str(_obj.subject), context);
	update_member(update, "toList", "xsd:string", basic2str(_obj.toList), context);
	update("Base", "Action", context);
	Action_closure(dynamic_cast<const vw1__Action&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SendEmailAction_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SendSNMPAction_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SendSNMPAction", context);
	update("Base", "Action", context);
	Action_closure(dynamic_cast<const vw1__Action&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SendSNMPAction_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ServerLicenseExpiredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ServerLicenseExpiredEvent", context);
	update_member(update, "product", "xsd:string", basic2str(_obj.product), context);
	update("Base", "LicenseEvent", context);
	LicenseEvent_closure(dynamic_cast<const vw1__LicenseEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ServerLicenseExpiredEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ServerStartedSessionEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ServerStartedSessionEvent", context);
	update("Base", "SessionEvent", context);
	SessionEvent_closure(dynamic_cast<const vw1__SessionEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ServerStartedSessionEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ServiceConsolePortGroupProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ServiceConsolePortGroupProfile", context);
	update_member(update, "ipConfig", "IpAddressProfile", handle_obj_ptr(_obj.ipConfig), context);
	update("Base", "PortGroupProfile", context);
	PortGroupProfile_closure(dynamic_cast<const vw1__PortGroupProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ServiceConsolePortGroupProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.ipConfig)
			return new IpAddressProfile_closure(*_obj.ipConfig);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return PortGroupProfile_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ServiceConsoleReservationInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ServiceConsoleReservationInfo", context);
	update_member(update, "serviceConsoleReserved", "xsd:long", basic2str(_obj.serviceConsoleReserved), context);
	update_member(update, "serviceConsoleReservedCfg", "xsd:long", basic2str(_obj.serviceConsoleReservedCfg), context);
	update_member(update, "unreserved", "xsd:long", basic2str(_obj.unreserved), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ServiceConsoleReservationInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ServiceContent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ServiceContent", context);
	update_member(update, "about", "AboutInfo", handle_obj_ptr(_obj.about), context);
	update_member(update, "accountManager", "HostLocalAccountManager", handle_obj_ptr(_obj.accountManager), context);
	update_member(update, "alarmManager", "AlarmManager", handle_obj_ptr(_obj.alarmManager), context);
	update_member(update, "authorizationManager", "AuthorizationManager", handle_obj_ptr(_obj.authorizationManager), context);
	update_member_with_version(update, "clusterProfileManager", "ClusterProfileManager", handle_obj_ptr(_obj.clusterProfileManager), context, "4.0");
	update_member_with_version(update, "complianceManager", "ProfileComplianceManager", handle_obj_ptr(_obj.complianceManager), context, "4.0");
	update_member(update, "customFieldsManager", "CustomFieldsManager", handle_obj_ptr(_obj.customFieldsManager), context);
	update_member(update, "customizationSpecManager", "CustomizationSpecManager", handle_obj_ptr(_obj.customizationSpecManager), context);
	update_member(update, "diagnosticManager", "DiagnosticManager", handle_obj_ptr(_obj.diagnosticManager), context);
	update_member_with_version(update, "dvSwitchManager", "DistributedVirtualSwitchManager", handle_obj_ptr(_obj.dvSwitchManager), context, "4.0");
	update_member(update, "eventManager", "EventManager", handle_obj_ptr(_obj.eventManager), context);
	update_member_with_version(update, "extensionManager", "ExtensionManager", handle_obj_ptr(_obj.extensionManager), context, "2.5");
	update_member_with_version(update, "fileManager", "FileManager", handle_obj_ptr(_obj.fileManager), context, "2.5");
	update_member_with_version(update, "guestOperationsManager", "GuestOperationsManager", handle_obj_ptr(_obj.guestOperationsManager), context, "5.0");
	update_member_with_version(update, "hostProfileManager", "HostProfileManager", handle_obj_ptr(_obj.hostProfileManager), context, "4.0");
	update_member_with_version(update, "ipPoolManager", "IpPoolManager", handle_obj_ptr(_obj.ipPoolManager), context, "4.0");
	update_member(update, "licenseManager", "LicenseManager", handle_obj_ptr(_obj.licenseManager), context);
	update_member_with_version(update, "localizationManager", "LocalizationManager", handle_obj_ptr(_obj.localizationManager), context, "4.0");
	update_member_with_version(update, "ovfManager", "OvfManager", handle_obj_ptr(_obj.ovfManager), context, "4.0");
	update_member(update, "perfManager", "PerformanceManager", handle_obj_ptr(_obj.perfManager), context);
	update_member(update, "propertyCollector", "PropertyCollector", handle_obj_ptr(_obj.propertyCollector), context);
	update_member(update, "rootFolder", "Folder", handle_obj_ptr(_obj.rootFolder), context);
	update_member(update, "scheduledTaskManager", "ScheduledTaskManager", handle_obj_ptr(_obj.scheduledTaskManager), context);
	update_member(update, "searchIndex", "SearchIndex", handle_obj_ptr(_obj.searchIndex), context);
	update_member(update, "sessionManager", "SessionManager", handle_obj_ptr(_obj.sessionManager), context);
	update_member(update, "setting", "OptionManager", handle_obj_ptr(_obj.setting), context);
	update_member_with_version(update, "snmpSystem", "HostSnmpSystem", handle_obj_ptr(_obj.snmpSystem), context, "4.0");
	update_member_with_version(update, "storageResourceManager", "StorageResourceManager", handle_obj_ptr(_obj.storageResourceManager), context, "4.1");
	update_member(update, "taskManager", "TaskManager", handle_obj_ptr(_obj.taskManager), context);
	update_member(update, "userDirectory", "UserDirectory", handle_obj_ptr(_obj.userDirectory), context);
	update_member_with_version(update, "viewManager", "ViewManager", handle_obj_ptr(_obj.viewManager), context, "2.5");
	update_member_with_version(update, "virtualDiskManager", "VirtualDiskManager", handle_obj_ptr(_obj.virtualDiskManager), context, "2.5");
	update_member_with_version(update, "virtualizationManager", "VirtualizationManager", handle_obj_ptr(_obj.virtualizationManager), context, "2.5");
	update_member_with_version(update, "vmCompatibilityChecker", "VirtualMachineCompatibilityChecker", handle_obj_ptr(_obj.vmCompatibilityChecker), context, "4.0");
	update_member_with_version(update, "vmProvisioningChecker", "VirtualMachineProvisioningChecker", handle_obj_ptr(_obj.vmProvisioningChecker), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ServiceContent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.about)
			return new AboutInfo_closure(*_obj.about);
		else
			return 0;
	case 1:
		return _obj.accountManager? 
			get_closure_from_mor(HostLocalAccountManager(_obj.accountManager)) : 0;
	case 2:
		return _obj.alarmManager? 
			get_closure_from_mor(AlarmManager(_obj.alarmManager)) : 0;
	case 3:
		return _obj.authorizationManager? 
			get_closure_from_mor(AuthorizationManager(_obj.authorizationManager)) : 0;
	case 4:
		return _obj.clusterProfileManager? 
			get_closure_from_mor(ClusterProfileManager(_obj.clusterProfileManager)) : 0;
	case 5:
		return _obj.complianceManager? 
			get_closure_from_mor(ProfileComplianceManager(_obj.complianceManager)) : 0;
	case 6:
		return _obj.customFieldsManager? 
			get_closure_from_mor(CustomFieldsManager(_obj.customFieldsManager)) : 0;
	case 7:
		return _obj.customizationSpecManager? 
			get_closure_from_mor(CustomizationSpecManager(_obj.customizationSpecManager)) : 0;
	case 8:
		return _obj.diagnosticManager? 
			get_closure_from_mor(DiagnosticManager(_obj.diagnosticManager)) : 0;
	case 9:
		return _obj.dvSwitchManager? 
			get_closure_from_mor(DistributedVirtualSwitchManager(_obj.dvSwitchManager)) : 0;
	case 10:
		return _obj.eventManager? 
			get_closure_from_mor(EventManager(_obj.eventManager)) : 0;
	case 11:
		return _obj.extensionManager? 
			get_closure_from_mor(ExtensionManager(_obj.extensionManager)) : 0;
	case 12:
		return _obj.fileManager? 
			get_closure_from_mor(FileManager(_obj.fileManager)) : 0;
	case 13:
		return _obj.guestOperationsManager? 
			get_closure_from_mor(GuestOperationsManager(_obj.guestOperationsManager)) : 0;
	case 14:
		return _obj.hostProfileManager? 
			get_closure_from_mor(HostProfileManager(_obj.hostProfileManager)) : 0;
	case 15:
		return _obj.ipPoolManager? 
			get_closure_from_mor(IpPoolManager(_obj.ipPoolManager)) : 0;
	case 16:
		return _obj.licenseManager? 
			get_closure_from_mor(LicenseManager(_obj.licenseManager)) : 0;
	case 17:
		return _obj.localizationManager? 
			get_closure_from_mor(LocalizationManager(_obj.localizationManager)) : 0;
	case 18:
		return _obj.ovfManager? 
			get_closure_from_mor(OvfManager(_obj.ovfManager)) : 0;
	case 19:
		return _obj.perfManager? 
			get_closure_from_mor(PerformanceManager(_obj.perfManager)) : 0;
	case 20:
		return _obj.propertyCollector? 
			get_closure_from_mor(PropertyCollector(_obj.propertyCollector)) : 0;
	case 21:
		return _obj.rootFolder? 
			get_closure_from_mor(Folder(_obj.rootFolder)) : 0;
	case 22:
		return _obj.scheduledTaskManager? 
			get_closure_from_mor(ScheduledTaskManager(_obj.scheduledTaskManager)) : 0;
	case 23:
		return _obj.searchIndex? 
			get_closure_from_mor(SearchIndex(_obj.searchIndex)) : 0;
	case 24:
		return _obj.sessionManager? 
			get_closure_from_mor(SessionManager(_obj.sessionManager)) : 0;
	case 25:
		return _obj.setting? 
			get_closure_from_mor(OptionManager(_obj.setting)) : 0;
	case 26:
		return _obj.snmpSystem? 
			get_closure_from_mor(HostSnmpSystem(_obj.snmpSystem)) : 0;
	case 27:
		return _obj.storageResourceManager? 
			get_closure_from_mor(StorageResourceManager(_obj.storageResourceManager)) : 0;
	case 28:
		return _obj.taskManager? 
			get_closure_from_mor(TaskManager(_obj.taskManager)) : 0;
	case 29:
		return _obj.userDirectory? 
			get_closure_from_mor(UserDirectory(_obj.userDirectory)) : 0;
	case 30:
		return _obj.viewManager? 
			get_closure_from_mor(ViewManager(_obj.viewManager)) : 0;
	case 31:
		return _obj.virtualDiskManager? 
			get_closure_from_mor(VirtualDiskManager(_obj.virtualDiskManager)) : 0;
	case 32:
		return _obj.virtualizationManager? 
			get_closure_from_mor(VirtualizationManager(_obj.virtualizationManager)) : 0;
	case 33:
		return _obj.vmCompatibilityChecker? 
			get_closure_from_mor(VirtualMachineCompatibilityChecker(_obj.vmCompatibilityChecker)) : 0;
	case 34:
		return _obj.vmProvisioningChecker? 
			get_closure_from_mor(VirtualMachineProvisioningChecker(_obj.vmProvisioningChecker)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 35) << 16) + arr_index);
	}
	return 0;
}

void ServiceProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ServiceProfile", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ServiceProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SessionEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SessionEvent", context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SessionEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SessionManagerGenericServiceTicket_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SessionManagerGenericServiceTicket", context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SessionManagerGenericServiceTicket_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SessionManagerHttpServiceRequestSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SessionManagerHttpServiceRequestSpec", context);
	update_member(update, "method", "xsd:string", basic2str(_obj.method), context);
	update_member(update, "url", "xsd:string", basic2str(_obj.url), context);
	update("Base", "SessionManagerServiceRequestSpec", context);
	SessionManagerServiceRequestSpec_closure(dynamic_cast<const vw1__SessionManagerServiceRequestSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SessionManagerHttpServiceRequestSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SessionManagerLocalTicket_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SessionManagerLocalTicket", context);
	update_member(update, "passwordFilePath", "xsd:string", basic2str(_obj.passwordFilePath), context);
	update_member(update, "userName", "xsd:string", basic2str(_obj.userName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SessionManagerLocalTicket_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SessionManagerServiceRequestSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SessionManagerServiceRequestSpec", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SessionManagerServiceRequestSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SessionTerminatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SessionTerminatedEvent", context);
	update_member(update, "sessionId", "xsd:string", basic2str(_obj.sessionId), context);
	update_member(update, "terminatedUsername", "xsd:string", basic2str(_obj.terminatedUsername), context);
	update("Base", "SessionEvent", context);
	SessionEvent_closure(dynamic_cast<const vw1__SessionEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SessionTerminatedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SharesInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SharesInfo", context);
	update_member(update, "level", "SharesLevel", handle_obj(_obj.level), context);
	update_member(update, "shares", "xsd:int", basic2str(_obj.shares), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SharesInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SharesOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SharesOption", context);
	update_member(update, "defaultLevel", "SharesLevel", handle_obj(_obj.defaultLevel), context);
	update_member(update, "sharesOption", "IntOption", handle_obj_ptr(_obj.sharesOption), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SharesOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.sharesOption)
			return new IntOption_closure(*_obj.sharesOption);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void StateAlarmExpression_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StateAlarmExpression", context);
	update_member(update, "operator_", "StateAlarmOperator", handle_obj(_obj.operator_), context);
	update_member(update, "red", "xsd:string", basic2str(_obj.red), context);
	update_member(update, "statePath", "xsd:string", basic2str(_obj.statePath), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update_member(update, "yellow", "xsd:string", basic2str(_obj.yellow), context);
	update("Base", "AlarmExpression", context);
	AlarmExpression_closure(dynamic_cast<const vw1__AlarmExpression&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StateAlarmExpression_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void StaticRouteProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StaticRouteProfile", context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StaticRouteProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void StorageDrsConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageDrsConfigInfo", context);
	update_member(update, "podConfig", "StorageDrsPodConfigInfo", handle_obj_ptr(_obj.podConfig), context);
	update_member(update, "vmConfig", "StorageDrsVmConfigInfo[]", a2s_object(_obj.vmConfig, _obj.__sizevmConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageDrsConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.podConfig)
			return new StorageDrsPodConfigInfo_closure(*_obj.podConfig);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevmConfig)
				return new StorageDrsVmConfigInfo_closure(*_obj.vmConfig[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void StorageDrsConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageDrsConfigSpec", context);
	update_member(update, "podConfigSpec", "StorageDrsPodConfigSpec", handle_obj_ptr(_obj.podConfigSpec), context);
	update_member(update, "vmConfigSpec", "StorageDrsVmConfigSpec[]", a2s_object(_obj.vmConfigSpec, _obj.__sizevmConfigSpec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageDrsConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.podConfigSpec)
			return new StorageDrsPodConfigSpec_closure(*_obj.podConfigSpec);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevmConfigSpec)
				return new StorageDrsVmConfigSpec_closure(*_obj.vmConfigSpec[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void StorageDrsIoLoadBalanceConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageDrsIoLoadBalanceConfig", context);
	update_member(update, "ioLatencyThreshold", "xsd:int", basic2str(_obj.ioLatencyThreshold), context);
	update_member(update, "ioLoadImbalanceThreshold", "xsd:int", basic2str(_obj.ioLoadImbalanceThreshold), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageDrsIoLoadBalanceConfig_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void StorageDrsOptionSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageDrsOptionSpec", context);
	update_member(update, "option", "OptionValue", handle_obj_ptr(_obj.option), context);
	update("Base", "ArrayUpdateSpec", context);
	ArrayUpdateSpec_closure(dynamic_cast<const vw1__ArrayUpdateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageDrsOptionSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.option)
			return new OptionValue_closure(*_obj.option);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ArrayUpdateSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void StorageDrsPodConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageDrsPodConfigInfo", context);
	update_member(update, "defaultIntraVmAffinity", "xsd:boolean", basic2str(_obj.defaultIntraVmAffinity), context);
	update_member(update, "defaultVmBehavior", "xsd:string", basic2str(_obj.defaultVmBehavior), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "ioLoadBalanceConfig", "StorageDrsIoLoadBalanceConfig", handle_obj_ptr(_obj.ioLoadBalanceConfig), context);
	update_member(update, "ioLoadBalanceEnabled", "xsd:boolean", basic2str(_obj.ioLoadBalanceEnabled), context);
	update_member(update, "loadBalanceInterval", "xsd:int", basic2str(_obj.loadBalanceInterval), context);
	update_member(update, "option", "OptionValue[]", a2s_object(_obj.option, _obj.__sizeoption), context);
	update_member(update, "rule", "ClusterRuleInfo[]", a2s_object(_obj.rule, _obj.__sizerule), context);
	update_member(update, "spaceLoadBalanceConfig", "StorageDrsSpaceLoadBalanceConfig", handle_obj_ptr(_obj.spaceLoadBalanceConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageDrsPodConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		if (_obj.ioLoadBalanceConfig)
			return new StorageDrsIoLoadBalanceConfig_closure(*_obj.ioLoadBalanceConfig);
		else
			return 0;
	case 6:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeoption)
				return new OptionValue_closure(*_obj.option[i]);
			else
				return 0;
		}
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerule)
				return new ClusterRuleInfo_closure(*_obj.rule[i]);
			else
				return 0;
		}
	case 8:
		if (_obj.spaceLoadBalanceConfig)
			return new StorageDrsSpaceLoadBalanceConfig_closure(*_obj.spaceLoadBalanceConfig);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 9) << 16) + arr_index);
	}
	return 0;
}

void StorageDrsPodConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageDrsPodConfigSpec", context);
	update_member(update, "defaultIntraVmAffinity", "xsd:boolean", basic2str(_obj.defaultIntraVmAffinity), context);
	update_member(update, "defaultVmBehavior", "xsd:string", basic2str(_obj.defaultVmBehavior), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "ioLoadBalanceConfig", "StorageDrsIoLoadBalanceConfig", handle_obj_ptr(_obj.ioLoadBalanceConfig), context);
	update_member(update, "ioLoadBalanceEnabled", "xsd:boolean", basic2str(_obj.ioLoadBalanceEnabled), context);
	update_member(update, "loadBalanceInterval", "xsd:int", basic2str(_obj.loadBalanceInterval), context);
	update_member(update, "option", "StorageDrsOptionSpec[]", a2s_object(_obj.option, _obj.__sizeoption), context);
	update_member(update, "rule", "ClusterRuleSpec[]", a2s_object(_obj.rule, _obj.__sizerule), context);
	update_member(update, "spaceLoadBalanceConfig", "StorageDrsSpaceLoadBalanceConfig", handle_obj_ptr(_obj.spaceLoadBalanceConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageDrsPodConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		if (_obj.ioLoadBalanceConfig)
			return new StorageDrsIoLoadBalanceConfig_closure(*_obj.ioLoadBalanceConfig);
		else
			return 0;
	case 6:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeoption)
				return new StorageDrsOptionSpec_closure(*_obj.option[i]);
			else
				return 0;
		}
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerule)
				return new ClusterRuleSpec_closure(*_obj.rule[i]);
			else
				return 0;
		}
	case 8:
		if (_obj.spaceLoadBalanceConfig)
			return new StorageDrsSpaceLoadBalanceConfig_closure(*_obj.spaceLoadBalanceConfig);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 9) << 16) + arr_index);
	}
	return 0;
}

void StorageDrsPodSelectionSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageDrsPodSelectionSpec", context);
	update_member(update, "initialVmConfig", "VmPodConfigForPlacement[]", a2s_object(_obj.initialVmConfig, _obj.__sizeinitialVmConfig), context);
	update_member(update, "storagePod", "StoragePod", handle_obj_ptr(_obj.storagePod), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageDrsPodSelectionSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeinitialVmConfig)
				return new VmPodConfigForPlacement_closure(*_obj.initialVmConfig[i]);
			else
				return 0;
		}
	case 1:
		return _obj.storagePod? 
			get_closure_from_mor(StoragePod(_obj.storagePod)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void StorageDrsSpaceLoadBalanceConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageDrsSpaceLoadBalanceConfig", context);
	update_member(update, "minSpaceUtilizationDifference", "xsd:int", basic2str(_obj.minSpaceUtilizationDifference), context);
	update_member(update, "spaceUtilizationThreshold", "xsd:int", basic2str(_obj.spaceUtilizationThreshold), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageDrsSpaceLoadBalanceConfig_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void StorageDrsVmConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageDrsVmConfigInfo", context);
	update_member(update, "behavior", "xsd:string", basic2str(_obj.behavior), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "intraVmAffinity", "xsd:boolean", basic2str(_obj.intraVmAffinity), context);
	update_member(update, "intraVmAntiAffinity", "VirtualDiskAntiAffinityRuleSpec", handle_obj_ptr(_obj.intraVmAntiAffinity), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageDrsVmConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		if (_obj.intraVmAntiAffinity)
			return new VirtualDiskAntiAffinityRuleSpec_closure(*_obj.intraVmAntiAffinity);
		else
			return 0;
	case 4:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void StorageDrsVmConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageDrsVmConfigSpec", context);
	update_member(update, "info", "StorageDrsVmConfigInfo", handle_obj_ptr(_obj.info), context);
	update("Base", "ArrayUpdateSpec", context);
	ArrayUpdateSpec_closure(dynamic_cast<const vw1__ArrayUpdateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageDrsVmConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.info)
			return new StorageDrsVmConfigInfo_closure(*_obj.info);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ArrayUpdateSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void StorageIOAllocationInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageIOAllocationInfo", context);
	update_member(update, "limit", "xsd:long", basic2str(_obj.limit), context);
	update_member(update, "shares", "SharesInfo", handle_obj_ptr(_obj.shares), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageIOAllocationInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.shares)
			return new SharesInfo_closure(*_obj.shares);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void StorageIOAllocationOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageIOAllocationOption", context);
	update_member(update, "limitOption", "LongOption", handle_obj_ptr(_obj.limitOption), context);
	update_member(update, "sharesOption", "SharesOption", handle_obj_ptr(_obj.sharesOption), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageIOAllocationOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.limitOption)
			return new LongOption_closure(*_obj.limitOption);
		else
			return 0;
	case 1:
		if (_obj.sharesOption)
			return new SharesOption_closure(*_obj.sharesOption);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void StorageIORMConfigOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageIORMConfigOption", context);
	update_member(update, "congestionThresholdOption", "IntOption", handle_obj_ptr(_obj.congestionThresholdOption), context);
	update_member(update, "enabledOption", "BoolOption", handle_obj_ptr(_obj.enabledOption), context);
	update_member_with_version(update, "statsCollectionEnabledOption", "BoolOption", handle_obj_ptr(_obj.statsCollectionEnabledOption), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageIORMConfigOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.congestionThresholdOption)
			return new IntOption_closure(*_obj.congestionThresholdOption);
		else
			return 0;
	case 1:
		if (_obj.enabledOption)
			return new BoolOption_closure(*_obj.enabledOption);
		else
			return 0;
	case 2:
		if (_obj.statsCollectionEnabledOption)
			return new BoolOption_closure(*_obj.statsCollectionEnabledOption);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void StorageIORMConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageIORMConfigSpec", context);
	update_member(update, "congestionThreshold", "xsd:int", basic2str(_obj.congestionThreshold), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member_with_version(update, "statsAggregationDisabled", "xsd:boolean", basic2str(_obj.statsAggregationDisabled), context, "5.0");
	update_member_with_version(update, "statsCollectionEnabled", "xsd:boolean", basic2str(_obj.statsCollectionEnabled), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageIORMConfigSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void StorageIORMInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageIORMInfo", context);
	update_member(update, "congestionThreshold", "xsd:int", basic2str(_obj.congestionThreshold), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member_with_version(update, "statsAggregationDisabled", "xsd:boolean", basic2str(_obj.statsAggregationDisabled), context, "5.0");
	update_member_with_version(update, "statsCollectionEnabled", "xsd:boolean", basic2str(_obj.statsCollectionEnabled), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageIORMInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void StorageMigrationAction_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageMigrationAction", context);
	update_member(update, "destination", "Datastore", handle_obj_ptr(_obj.destination), context);
	update_member(update, "ioLatencyDstBefore", "xsd:float", basic2str(_obj.ioLatencyDstBefore), context);
	update_member(update, "ioLatencySrcBefore", "xsd:float", basic2str(_obj.ioLatencySrcBefore), context);
	update_member(update, "relocateSpec", "VirtualMachineRelocateSpec", handle_obj_ptr(_obj.relocateSpec), context);
	update_member(update, "sizeTransferred", "xsd:long", basic2str(_obj.sizeTransferred), context);
	update_member(update, "source", "Datastore", handle_obj_ptr(_obj.source), context);
	update_member(update, "spaceUtilDstAfter", "xsd:float", basic2str(_obj.spaceUtilDstAfter), context);
	update_member(update, "spaceUtilDstBefore", "xsd:float", basic2str(_obj.spaceUtilDstBefore), context);
	update_member(update, "spaceUtilSrcAfter", "xsd:float", basic2str(_obj.spaceUtilSrcAfter), context);
	update_member(update, "spaceUtilSrcBefore", "xsd:float", basic2str(_obj.spaceUtilSrcBefore), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "ClusterAction", context);
	ClusterAction_closure(dynamic_cast<const vw1__ClusterAction&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageMigrationAction_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.destination? 
			get_closure_from_mor(Datastore(_obj.destination)) : 0;
	case 3:
		if (_obj.relocateSpec)
			return new VirtualMachineRelocateSpec_closure(*_obj.relocateSpec);
		else
			return 0;
	case 5:
		return _obj.source? 
			get_closure_from_mor(Datastore(_obj.source)) : 0;
	case 10:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return ClusterAction_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void StoragePlacementAction_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StoragePlacementAction", context);
	update_member(update, "destination", "Datastore", handle_obj_ptr(_obj.destination), context);
	update_member(update, "ioLatencyBefore", "xsd:float", basic2str(_obj.ioLatencyBefore), context);
	update_member(update, "relocateSpec", "VirtualMachineRelocateSpec", handle_obj_ptr(_obj.relocateSpec), context);
	update_member(update, "spaceUtilAfter", "xsd:float", basic2str(_obj.spaceUtilAfter), context);
	update_member(update, "spaceUtilBefore", "xsd:float", basic2str(_obj.spaceUtilBefore), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "ClusterAction", context);
	ClusterAction_closure(dynamic_cast<const vw1__ClusterAction&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StoragePlacementAction_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.destination? 
			get_closure_from_mor(Datastore(_obj.destination)) : 0;
	case 2:
		if (_obj.relocateSpec)
			return new VirtualMachineRelocateSpec_closure(*_obj.relocateSpec);
		else
			return 0;
	case 5:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return ClusterAction_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void StoragePlacementResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StoragePlacementResult", context);
	update_member(update, "drsFault", "ClusterDrsFaults", handle_obj_ptr(_obj.drsFault), context);
	update_member(update, "recommendations", "ClusterRecommendation[]", a2s_object(_obj.recommendations, _obj.__sizerecommendations), context);
	update_member(update, "task", "Task", handle_obj_ptr(_obj.task), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StoragePlacementResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.drsFault)
			return new ClusterDrsFaults_closure(*_obj.drsFault);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerecommendations)
				return new ClusterRecommendation_closure(*_obj.recommendations[i]);
			else
				return 0;
		}
	case 2:
		return _obj.task? 
			get_closure_from_mor(Task(_obj.task)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void StoragePlacementSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StoragePlacementSpec", context);
	update_member(update, "cloneName", "xsd:string", basic2str(_obj.cloneName), context);
	update_member(update, "cloneSpec", "VirtualMachineCloneSpec", handle_obj_ptr(_obj.cloneSpec), context);
	update_member(update, "configSpec", "VirtualMachineConfigSpec", handle_obj_ptr(_obj.configSpec), context);
	update_member(update, "folder", "Folder", handle_obj_ptr(_obj.folder), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "podSelectionSpec", "StorageDrsPodSelectionSpec", handle_obj_ptr(_obj.podSelectionSpec), context);
	update_member(update, "priority", "VirtualMachineMovePriority", handle_obj_ptr(_obj.priority), context);
	update_member(update, "relocateSpec", "VirtualMachineRelocateSpec", handle_obj_ptr(_obj.relocateSpec), context);
	update_member(update, "resourcePool", "ResourcePool", handle_obj_ptr(_obj.resourcePool), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StoragePlacementSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.cloneSpec)
			return new VirtualMachineCloneSpec_closure(*_obj.cloneSpec);
		else
			return 0;
	case 2:
		if (_obj.configSpec)
			return new VirtualMachineConfigSpec_closure(*_obj.configSpec);
		else
			return 0;
	case 3:
		return _obj.folder? 
			get_closure_from_mor(Folder(_obj.folder)) : 0;
	case 4:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	case 5:
		if (_obj.podSelectionSpec)
			return new StorageDrsPodSelectionSpec_closure(*_obj.podSelectionSpec);
		else
			return 0;
	case 7:
		if (_obj.relocateSpec)
			return new VirtualMachineRelocateSpec_closure(*_obj.relocateSpec);
		else
			return 0;
	case 8:
		return _obj.resourcePool? 
			get_closure_from_mor(ResourcePool(_obj.resourcePool)) : 0;
	case 10:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void StoragePodSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StoragePodSummary", context);
	update_member(update, "capacity", "xsd:long", basic2str(_obj.capacity), context);
	update_member(update, "freeSpace", "xsd:long", basic2str(_obj.freeSpace), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StoragePodSummary_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void StorageProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageProfile", context);
	update_member(update, "nasStorage", "NasStorageProfile[]", a2s_object(_obj.nasStorage, _obj.__sizenasStorage), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenasStorage)
				return new NasStorageProfile_closure(*_obj.nasStorage[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ApplyProfile_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void StorageRequirement_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageRequirement", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "freeSpaceRequiredInKb", "xsd:long", basic2str(_obj.freeSpaceRequiredInKb), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageRequirement_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void StringOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StringOption", context);
	update_member(update, "defaultValue", "xsd:string", basic2str(_obj.defaultValue), context);
	update_member(update, "validCharacters", "xsd:string", basic2str(_obj.validCharacters), context);
	update("Base", "OptionType", context);
	OptionType_closure(dynamic_cast<const vw1__OptionType&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StringOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void StringPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StringPolicy", context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "InheritablePolicy", context);
	InheritablePolicy_closure(dynamic_cast<const vw1__InheritablePolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StringPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void Tag_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Tag", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* Tag_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TaskDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskDescription", context);
	update_member(update, "methodInfo", "ElementDescription[]", a2s_object(_obj.methodInfo, _obj.__sizemethodInfo), context);
	update_member(update, "reason", "TypeDescription[]", a2s_object(_obj.reason, _obj.__sizereason), context);
	update_member(update, "state", "ElementDescription[]", a2s_object(_obj.state, _obj.__sizestate), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskDescription_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemethodInfo)
				return new ElementDescription_closure(*_obj.methodInfo[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizereason)
				return new TypeDescription_closure(*_obj.reason[i]);
			else
				return 0;
		}
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizestate)
				return new ElementDescription_closure(*_obj.state[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void TaskEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskEvent", context);
	update_member(update, "info", "TaskInfo", handle_obj_ptr(_obj.info), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.info)
			return new TaskInfo_closure(*_obj.info);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return Event_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void TaskFilterSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskFilterSpec", context);
	update_member(update, "alarm", "Alarm", handle_obj_ptr(_obj.alarm), context);
	update_member(update, "entity", "TaskFilterSpecByEntity", handle_obj_ptr(_obj.entity), context);
	update_member_with_version(update, "eventChainId", "xsd:int[]", a2s_basic(_obj.eventChainId, _obj.__sizeeventChainId), context, "4.0");
	update_member_with_version(update, "parentTaskKey", "xsd:string[]", a2s_basic(*_obj.parentTaskKey, _obj.__sizeparentTaskKey), context, "4.0");
	update_member_with_version(update, "rootTaskKey", "xsd:string[]", a2s_basic(*_obj.rootTaskKey, _obj.__sizerootTaskKey), context, "4.0");
	update_member(update, "scheduledTask", "ScheduledTask", handle_obj_ptr(_obj.scheduledTask), context);
	update_member(update, "state", "TaskInfoState[]", a2s_basic(_obj.state, _obj.__sizestate), context);
	update_member_with_version(update, "tag", "xsd:string[]", a2s_basic(*_obj.tag, _obj.__sizetag), context, "4.0");
	update_member(update, "time", "TaskFilterSpecByTime", handle_obj_ptr(_obj.time), context);
	update_member(update, "userName", "TaskFilterSpecByUsername", handle_obj_ptr(_obj.userName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskFilterSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.alarm? 
			get_closure_from_mor(Alarm(_obj.alarm)) : 0;
	case 1:
		if (_obj.entity)
			return new TaskFilterSpecByEntity_closure(*_obj.entity);
		else
			return 0;
	case 5:
		return _obj.scheduledTask? 
			get_closure_from_mor(ScheduledTask(_obj.scheduledTask)) : 0;
	case 8:
		if (_obj.time)
			return new TaskFilterSpecByTime_closure(*_obj.time);
		else
			return 0;
	case 9:
		if (_obj.userName)
			return new TaskFilterSpecByUsername_closure(*_obj.userName);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 10) << 16) + arr_index);
	}
	return 0;
}

void TaskFilterSpecByEntity_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskFilterSpecByEntity", context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "recursion", "TaskFilterSpecRecursionOption", handle_obj(_obj.recursion), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskFilterSpecByEntity_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void TaskFilterSpecByTime_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskFilterSpecByTime", context);
	update_member(update, "beginTime", "xsd:dateTime", basic2str(_obj.beginTime), context);
	update_member(update, "endTime", "xsd:dateTime", basic2str(_obj.endTime), context);
	update_member(update, "timeType", "TaskFilterSpecTimeOption", handle_obj(_obj.timeType), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskFilterSpecByTime_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TaskFilterSpecByUsername_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskFilterSpecByUsername", context);
	update_member(update, "systemUser", "xsd:boolean", basic2str(_obj.systemUser), context);
	update_member(update, "userList", "xsd:string[]", a2s_basic(*_obj.userList, _obj.__sizeuserList), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskFilterSpecByUsername_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TaskInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskInfo", context);
	update_member(update, "cancelable", "xsd:boolean", basic2str(_obj.cancelable), context);
	update_member(update, "cancelled", "xsd:boolean", basic2str(_obj.cancelled), context);
	update_member_with_version(update, "changeTag", "xsd:string", basic2str(_obj.changeTag), context, "4.0");
	update_member(update, "completeTime", "xsd:dateTime", basic2str(_obj.completeTime), context);
	update_member_with_version(update, "description", "LocalizableMessage", handle_obj_ptr(_obj.description), context, "4.0");
	update_member(update, "descriptionId", "xsd:string", basic2str(_obj.descriptionId), context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "entityName", "xsd:string", basic2str(_obj.entityName), context);
	update_member(update, "error", "LocalizedMethodFault", handle_obj_ptr(_obj.error), context);
	update_member(update, "eventChainId", "xsd:int", basic2str(_obj.eventChainId), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "locked", "ManagedEntity[]", a2s_object(_obj.locked, _obj.__sizelocked), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member_with_version(update, "parentTaskKey", "xsd:string", basic2str(_obj.parentTaskKey), context, "4.0");
	update_member(update, "progress", "xsd:int", basic2str(_obj.progress), context);
	update_member(update, "queueTime", "xsd:dateTime", basic2str(_obj.queueTime), context);
	update_member(update, "reason", "TaskReason", handle_obj_ptr(_obj.reason), context);
	update_member(update, "result", "xsd:anyType", basic2str(_obj.result), context);
	update_member_with_version(update, "rootTaskKey", "xsd:string", basic2str(_obj.rootTaskKey), context, "4.0");
	update_member(update, "startTime", "xsd:dateTime", basic2str(_obj.startTime), context);
	update_member(update, "state", "TaskInfoState", handle_obj(_obj.state), context);
	update_member(update, "task", "Task", handle_obj_ptr(_obj.task), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 4:
		if (_obj.description)
			return new LocalizableMessage_closure(*_obj.description);
		else
			return 0;
	case 6:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	case 8:
		if (_obj.error)
			return new LocalizedMethodFault_closure(*_obj.error);
		else
			return 0;
	case 11:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizelocked)
				return new ManagedEntity_closure(_obj.locked[i]);
			else
				return 0;
		}
	case 16:
		if (_obj.reason)
			return new TaskReason_closure(*_obj.reason);
		else
			return 0;
	case 21:
		return _obj.task? 
			get_closure_from_mor(Task(_obj.task)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 22) << 16) + arr_index);
	}
	return 0;
}

void TaskReason_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskReason", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskReason_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TaskReasonAlarm_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskReasonAlarm", context);
	update_member(update, "alarm", "Alarm", handle_obj_ptr(_obj.alarm), context);
	update_member(update, "alarmName", "xsd:string", basic2str(_obj.alarmName), context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "entityName", "xsd:string", basic2str(_obj.entityName), context);
	update("Base", "TaskReason", context);
	TaskReason_closure(dynamic_cast<const vw1__TaskReason&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskReasonAlarm_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.alarm? 
			get_closure_from_mor(Alarm(_obj.alarm)) : 0;
	case 2:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return TaskReason_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void TaskReasonSchedule_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskReasonSchedule", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "scheduledTask", "ScheduledTask", handle_obj_ptr(_obj.scheduledTask), context);
	update("Base", "TaskReason", context);
	TaskReason_closure(dynamic_cast<const vw1__TaskReason&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskReasonSchedule_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.scheduledTask? 
			get_closure_from_mor(ScheduledTask(_obj.scheduledTask)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return TaskReason_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void TaskReasonSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskReasonSystem", context);
	update("Base", "TaskReason", context);
	TaskReason_closure(dynamic_cast<const vw1__TaskReason&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskReasonSystem_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TaskReasonUser_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskReasonUser", context);
	update_member(update, "userName", "xsd:string", basic2str(_obj.userName), context);
	update("Base", "TaskReason", context);
	TaskReason_closure(dynamic_cast<const vw1__TaskReason&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskReasonUser_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TaskScheduler_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskScheduler", context);
	update_member(update, "activeTime", "xsd:dateTime", basic2str(_obj.activeTime), context);
	update_member(update, "expireTime", "xsd:dateTime", basic2str(_obj.expireTime), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskScheduler_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TaskTimeoutEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskTimeoutEvent", context);
	update("Base", "TaskEvent", context);
	TaskEvent_closure(dynamic_cast<const vw1__TaskEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskTimeoutEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TemplateBeingUpgradedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TemplateBeingUpgradedEvent", context);
	update("Base", "TemplateUpgradeEvent", context);
	TemplateUpgradeEvent_closure(dynamic_cast<const vw1__TemplateUpgradeEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TemplateBeingUpgradedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TemplateConfigFileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TemplateConfigFileInfo", context);
	update("Base", "VmConfigFileInfo", context);
	VmConfigFileInfo_closure(dynamic_cast<const vw1__VmConfigFileInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TemplateConfigFileInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TemplateConfigFileQuery_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TemplateConfigFileQuery", context);
	update("Base", "VmConfigFileQuery", context);
	VmConfigFileQuery_closure(dynamic_cast<const vw1__VmConfigFileQuery&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TemplateConfigFileQuery_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TemplateUpgradeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TemplateUpgradeEvent", context);
	update_member(update, "legacyTemplate", "xsd:string", basic2str(_obj.legacyTemplate), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TemplateUpgradeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TemplateUpgradeFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TemplateUpgradeFailedEvent", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "TemplateUpgradeEvent", context);
	TemplateUpgradeEvent_closure(dynamic_cast<const vw1__TemplateUpgradeEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TemplateUpgradeFailedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return TemplateUpgradeEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void TemplateUpgradedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TemplateUpgradedEvent", context);
	update("Base", "TemplateUpgradeEvent", context);
	TemplateUpgradeEvent_closure(dynamic_cast<const vw1__TemplateUpgradeEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TemplateUpgradedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TicketedSessionAuthentication_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TicketedSessionAuthentication", context);
	update_member(update, "ticket", "xsd:string", basic2str(_obj.ticket), context);
	update("Base", "GuestAuthentication", context);
	GuestAuthentication_closure(dynamic_cast<const vw1__GuestAuthentication&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TicketedSessionAuthentication_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TimedOutHostOperationEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TimedOutHostOperationEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TimedOutHostOperationEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ToolsConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ToolsConfigInfo", context);
	update_member(update, "afterPowerOn", "xsd:boolean", basic2str(_obj.afterPowerOn), context);
	update_member(update, "afterResume", "xsd:boolean", basic2str(_obj.afterResume), context);
	update_member(update, "beforeGuestReboot", "xsd:boolean", basic2str(_obj.beforeGuestReboot), context);
	update_member(update, "beforeGuestShutdown", "xsd:boolean", basic2str(_obj.beforeGuestShutdown), context);
	update_member(update, "beforeGuestStandby", "xsd:boolean", basic2str(_obj.beforeGuestStandby), context);
	update_member_with_version(update, "lastInstallInfo", "ToolsConfigInfoToolsLastInstallInfo", handle_obj_ptr(_obj.lastInstallInfo), context, "5.0");
	update_member_with_version(update, "pendingCustomization", "xsd:string", basic2str(_obj.pendingCustomization), context, "2.5");
	update_member_with_version(update, "syncTimeWithHost", "xsd:boolean", basic2str(_obj.syncTimeWithHost), context, "2.5");
	update_member_with_version(update, "toolsUpgradePolicy", "xsd:string", basic2str(_obj.toolsUpgradePolicy), context, "2.5");
	update_member(update, "toolsVersion", "xsd:int", basic2str(_obj.toolsVersion), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ToolsConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 5:
		if (_obj.lastInstallInfo)
			return new ToolsConfigInfoToolsLastInstallInfo_closure(*_obj.lastInstallInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 10) << 16) + arr_index);
	}
	return 0;
}

void ToolsConfigInfoToolsLastInstallInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ToolsConfigInfoToolsLastInstallInfo", context);
	update_member(update, "counter", "xsd:int", basic2str(_obj.counter), context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ToolsConfigInfoToolsLastInstallInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void TraversalSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TraversalSpec", context);
	update_member(update, "path", "xsd:string", basic2str(_obj.path), context);
	update_member(update, "selectSet", "SelectionSpec[]", a2s_object(_obj.selectSet, _obj.__sizeselectSet), context);
	update_member(update, "skip", "xsd:boolean", basic2str(_obj.skip), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "SelectionSpec", context);
	SelectionSpec_closure(dynamic_cast<const vw1__SelectionSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TraversalSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeselectSet)
				return new SelectionSpec_closure(*_obj.selectSet[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return SelectionSpec_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void TypeDescription_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TypeDescription", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "Description", context);
	Description_closure(dynamic_cast<const vw1__Description&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TypeDescription_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UnlicensedVirtualMachinesEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UnlicensedVirtualMachinesEvent", context);
	update_member(update, "available", "xsd:int", basic2str(_obj.available), context);
	update_member(update, "unlicensed", "xsd:int", basic2str(_obj.unlicensed), context);
	update("Base", "LicenseEvent", context);
	LicenseEvent_closure(dynamic_cast<const vw1__LicenseEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UnlicensedVirtualMachinesEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UnlicensedVirtualMachinesFoundEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UnlicensedVirtualMachinesFoundEvent", context);
	update_member(update, "available", "xsd:int", basic2str(_obj.available), context);
	update("Base", "LicenseEvent", context);
	LicenseEvent_closure(dynamic_cast<const vw1__LicenseEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UnlicensedVirtualMachinesFoundEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UpdateSet_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UpdateSet", context);
	update_member(update, "filterSet", "PropertyFilterUpdate[]", a2s_object(_obj.filterSet, _obj.__sizefilterSet), context);
	update_member_with_version(update, "truncated", "xsd:boolean", basic2str(_obj.truncated), context, "4.1");
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UpdateSet_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefilterSet)
				return new PropertyFilterUpdate_closure(*_obj.filterSet[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void UpdateVirtualMachineFilesResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UpdateVirtualMachineFilesResult", context);
	update_member(update, "failedVmFile", "UpdateVirtualMachineFilesResultFailedVmFileInfo[]", a2s_object(_obj.failedVmFile, _obj.__sizefailedVmFile), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UpdateVirtualMachineFilesResult_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefailedVmFile)
				return new UpdateVirtualMachineFilesResultFailedVmFileInfo_closure(*_obj.failedVmFile[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void UpdateVirtualMachineFilesResultFailedVmFileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UpdateVirtualMachineFilesResultFailedVmFileInfo", context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update_member(update, "vmFile", "xsd:string", basic2str(_obj.vmFile), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UpdateVirtualMachineFilesResultFailedVmFileInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void UpdatedAgentBeingRestartedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UpdatedAgentBeingRestartedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UpdatedAgentBeingRestartedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UpgradeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UpgradeEvent", context);
	update_member(update, "message", "xsd:string", basic2str(_obj.message), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UpgradeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UserAssignedToGroup_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UserAssignedToGroup", context);
	update_member(update, "group", "xsd:string", basic2str(_obj.group), context);
	update_member(update, "userLogin", "xsd:string", basic2str(_obj.userLogin), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UserAssignedToGroup_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UserGroupProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UserGroupProfile", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UserGroupProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UserInputRequiredParameterMetadata_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UserInputRequiredParameterMetadata", context);
	update_member(update, "userInputParameter", "ProfileParameterMetadata[]", a2s_object(_obj.userInputParameter, _obj.__sizeuserInputParameter), context);
	update("Base", "ProfilePolicyOptionMetadata", context);
	ProfilePolicyOptionMetadata_closure(dynamic_cast<const vw1__ProfilePolicyOptionMetadata&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UserInputRequiredParameterMetadata_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeuserInputParameter)
				return new ProfileParameterMetadata_closure(*_obj.userInputParameter[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ProfilePolicyOptionMetadata_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void UserLoginSessionEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UserLoginSessionEvent", context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update_member(update, "locale", "xsd:string", basic2str(_obj.locale), context);
	update_member(update, "sessionId", "xsd:string", basic2str(_obj.sessionId), context);
	update("Base", "SessionEvent", context);
	SessionEvent_closure(dynamic_cast<const vw1__SessionEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UserLoginSessionEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UserLogoutSessionEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UserLogoutSessionEvent", context);
	update("Base", "SessionEvent", context);
	SessionEvent_closure(dynamic_cast<const vw1__SessionEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UserLogoutSessionEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UserPasswordChanged_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UserPasswordChanged", context);
	update_member(update, "userLogin", "xsd:string", basic2str(_obj.userLogin), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UserPasswordChanged_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UserProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UserProfile", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UserProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UserSearchResult_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UserSearchResult", context);
	update_member(update, "fullName", "xsd:string", basic2str(_obj.fullName), context);
	update_member(update, "group", "xsd:boolean", basic2str(_obj.group), context);
	update_member(update, "principal", "xsd:string", basic2str(_obj.principal), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UserSearchResult_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UserSession_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UserSession", context);
	update_member_with_version(update, "extensionSession", "xsd:boolean", basic2str(_obj.extensionSession), context, "5.0");
	update_member(update, "fullName", "xsd:string", basic2str(_obj.fullName), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "lastActiveTime", "xsd:dateTime", basic2str(_obj.lastActiveTime), context);
	update_member(update, "locale", "xsd:string", basic2str(_obj.locale), context);
	update_member(update, "loginTime", "xsd:dateTime", basic2str(_obj.loginTime), context);
	update_member(update, "messageLocale", "xsd:string", basic2str(_obj.messageLocale), context);
	update_member(update, "userName", "xsd:string", basic2str(_obj.userName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UserSession_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UserUnassignedFromGroup_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UserUnassignedFromGroup", context);
	update_member(update, "group", "xsd:string", basic2str(_obj.group), context);
	update_member(update, "userLogin", "xsd:string", basic2str(_obj.userLogin), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UserUnassignedFromGroup_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UserUpgradeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UserUpgradeEvent", context);
	update("Base", "UpgradeEvent", context);
	UpgradeEvent_closure(dynamic_cast<const vw1__UpgradeEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UserUpgradeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VAppCloneSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppCloneSpec", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "location", "Datastore", handle_obj_ptr(_obj.location), context);
	update_member(update, "networkMapping", "VAppCloneSpecNetworkMappingPair[]", a2s_object(_obj.networkMapping, _obj.__sizenetworkMapping), context);
	update_member(update, "property", "KeyValue[]", a2s_object(_obj.property, _obj.__sizeproperty), context);
	update_member_with_version(update, "provisioning", "xsd:string", basic2str(_obj.provisioning), context, "4.1");
	update_member_with_version(update, "resourceMapping", "VAppCloneSpecResourceMap[]", a2s_object(_obj.resourceMapping, _obj.__sizeresourceMapping), context, "4.1");
	update_member(update, "resourceSpec", "ResourceConfigSpec", handle_obj_ptr(_obj.resourceSpec), context);
	update_member(update, "vmFolder", "Folder", handle_obj_ptr(_obj.vmFolder), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppCloneSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	case 1:
		return _obj.location? 
			get_closure_from_mor(Datastore(_obj.location)) : 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizenetworkMapping)
				return new VAppCloneSpecNetworkMappingPair_closure(*_obj.networkMapping[i]);
			else
				return 0;
		}
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeproperty)
				return new KeyValue_closure(*_obj.property[i]);
			else
				return 0;
		}
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeresourceMapping)
				return new VAppCloneSpecResourceMap_closure(*_obj.resourceMapping[i]);
			else
				return 0;
		}
	case 6:
		if (_obj.resourceSpec)
			return new ResourceConfigSpec_closure(*_obj.resourceSpec);
		else
			return 0;
	case 7:
		return _obj.vmFolder? 
			get_closure_from_mor(Folder(_obj.vmFolder)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void VAppCloneSpecNetworkMappingPair_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppCloneSpecNetworkMappingPair", context);
	update_member(update, "destination", "Network", handle_obj_ptr(_obj.destination), context);
	update_member(update, "source", "Network", handle_obj_ptr(_obj.source), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppCloneSpecNetworkMappingPair_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.destination? 
			get_closure_from_mor(Network(_obj.destination)) : 0;
	case 1:
		return _obj.source? 
			get_closure_from_mor(Network(_obj.source)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VAppCloneSpecResourceMap_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppCloneSpecResourceMap", context);
	update_member(update, "location", "Datastore", handle_obj_ptr(_obj.location), context);
	update_member(update, "parent", "ResourcePool", handle_obj_ptr(_obj.parent), context);
	update_member(update, "resourceSpec", "ResourceConfigSpec", handle_obj_ptr(_obj.resourceSpec), context);
	update_member(update, "source", "ManagedEntity", handle_obj_ptr(_obj.source), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppCloneSpecResourceMap_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.location? 
			get_closure_from_mor(Datastore(_obj.location)) : 0;
	case 1:
		return _obj.parent? 
			get_closure_from_mor(ResourcePool(_obj.parent)) : 0;
	case 2:
		if (_obj.resourceSpec)
			return new ResourceConfigSpec_closure(*_obj.resourceSpec);
		else
			return 0;
	case 3:
		return _obj.source? 
			get_closure_from_mor(ManagedEntity(_obj.source)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VAppConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppConfigInfo", context);
	update_member(update, "annotation", "xsd:string", basic2str(_obj.annotation), context);
	update_member(update, "entityConfig", "VAppEntityConfigInfo[]", a2s_object(_obj.entityConfig, _obj.__sizeentityConfig), context);
	update_member_with_version(update, "instanceUuid", "xsd:string", basic2str(_obj.instanceUuid), context, "4.1");
	update_member_with_version(update, "managedBy", "ManagedByInfo", handle_obj_ptr(_obj.managedBy), context, "5.0");
	update("Base", "VmConfigInfo", context);
	VmConfigInfo_closure(dynamic_cast<const vw1__VmConfigInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeentityConfig)
				return new VAppEntityConfigInfo_closure(*_obj.entityConfig[i]);
			else
				return 0;
		}
	case 3:
		if (_obj.managedBy)
			return new ManagedByInfo_closure(*_obj.managedBy);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmConfigInfo_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VAppConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppConfigSpec", context);
	update_member(update, "annotation", "xsd:string", basic2str(_obj.annotation), context);
	update_member(update, "entityConfig", "VAppEntityConfigInfo[]", a2s_object(_obj.entityConfig, _obj.__sizeentityConfig), context);
	update_member_with_version(update, "instanceUuid", "xsd:string", basic2str(_obj.instanceUuid), context, "4.1");
	update_member_with_version(update, "managedBy", "ManagedByInfo", handle_obj_ptr(_obj.managedBy), context, "5.0");
	update("Base", "VmConfigSpec", context);
	VmConfigSpec_closure(dynamic_cast<const vw1__VmConfigSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeentityConfig)
				return new VAppEntityConfigInfo_closure(*_obj.entityConfig[i]);
			else
				return 0;
		}
	case 3:
		if (_obj.managedBy)
			return new ManagedByInfo_closure(*_obj.managedBy);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmConfigSpec_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VAppEntityConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppEntityConfigInfo", context);
	update_member_with_version(update, "destroyWithParent", "xsd:boolean", basic2str(_obj.destroyWithParent), context, "4.1");
	update_member(update, "key", "ManagedEntity", handle_obj_ptr(_obj.key), context);
	update_member(update, "startAction", "xsd:string", basic2str(_obj.startAction), context);
	update_member(update, "startDelay", "xsd:int", basic2str(_obj.startDelay), context);
	update_member(update, "startOrder", "xsd:int", basic2str(_obj.startOrder), context);
	update_member(update, "stopAction", "xsd:string", basic2str(_obj.stopAction), context);
	update_member(update, "stopDelay", "xsd:int", basic2str(_obj.stopDelay), context);
	update_member(update, "tag", "xsd:string", basic2str(_obj.tag), context);
	update_member(update, "waitingForGuest", "xsd:boolean", basic2str(_obj.waitingForGuest), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppEntityConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.key? 
			get_closure_from_mor(ManagedEntity(_obj.key)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 9) << 16) + arr_index);
	}
	return 0;
}

void VAppIPAssignmentInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppIPAssignmentInfo", context);
	update_member(update, "ipAllocationPolicy", "xsd:string", basic2str(_obj.ipAllocationPolicy), context);
	update_member(update, "ipProtocol", "xsd:string", basic2str(_obj.ipProtocol), context);
	update_member(update, "supportedAllocationScheme", "xsd:string[]", a2s_basic(*_obj.supportedAllocationScheme, _obj.__sizesupportedAllocationScheme), context);
	update_member(update, "supportedIpProtocol", "xsd:string[]", a2s_basic(*_obj.supportedIpProtocol, _obj.__sizesupportedIpProtocol), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppIPAssignmentInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VAppOvfSectionInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppOvfSectionInfo", context);
	update_member(update, "atEnvelopeLevel", "xsd:boolean", basic2str(_obj.atEnvelopeLevel), context);
	update_member(update, "contents", "xsd:string", basic2str(_obj.contents), context);
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update_member(update, "namespace_", "xsd:string", basic2str(_obj.namespace_), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppOvfSectionInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VAppOvfSectionSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppOvfSectionSpec", context);
	update_member(update, "info", "VAppOvfSectionInfo", handle_obj_ptr(_obj.info), context);
	update("Base", "ArrayUpdateSpec", context);
	ArrayUpdateSpec_closure(dynamic_cast<const vw1__ArrayUpdateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppOvfSectionSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.info)
			return new VAppOvfSectionInfo_closure(*_obj.info);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ArrayUpdateSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VAppProductInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppProductInfo", context);
	update_member(update, "appUrl", "xsd:string", basic2str(_obj.appUrl), context);
	update_member(update, "classId", "xsd:string", basic2str(_obj.classId), context);
	update_member(update, "fullVersion", "xsd:string", basic2str(_obj.fullVersion), context);
	update_member(update, "instanceId", "xsd:string", basic2str(_obj.instanceId), context);
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "productUrl", "xsd:string", basic2str(_obj.productUrl), context);
	update_member(update, "vendor", "xsd:string", basic2str(_obj.vendor), context);
	update_member(update, "vendorUrl", "xsd:string", basic2str(_obj.vendorUrl), context);
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppProductInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VAppProductSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppProductSpec", context);
	update_member(update, "info", "VAppProductInfo", handle_obj_ptr(_obj.info), context);
	update("Base", "ArrayUpdateSpec", context);
	ArrayUpdateSpec_closure(dynamic_cast<const vw1__ArrayUpdateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppProductSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.info)
			return new VAppProductInfo_closure(*_obj.info);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ArrayUpdateSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VAppPropertyInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppPropertyInfo", context);
	update_member(update, "category", "xsd:string", basic2str(_obj.category), context);
	update_member(update, "classId", "xsd:string", basic2str(_obj.classId), context);
	update_member(update, "defaultValue", "xsd:string", basic2str(_obj.defaultValue), context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "instanceId", "xsd:string", basic2str(_obj.instanceId), context);
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update_member(update, "label", "xsd:string", basic2str(_obj.label), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update_member(update, "userConfigurable", "xsd:boolean", basic2str(_obj.userConfigurable), context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppPropertyInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VAppPropertySpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppPropertySpec", context);
	update_member(update, "info", "VAppPropertyInfo", handle_obj_ptr(_obj.info), context);
	update("Base", "ArrayUpdateSpec", context);
	ArrayUpdateSpec_closure(dynamic_cast<const vw1__ArrayUpdateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppPropertySpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.info)
			return new VAppPropertyInfo_closure(*_obj.info);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ArrayUpdateSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VMFSDatastoreCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMFSDatastoreCreatedEvent", context);
	update_member(update, "datastore", "DatastoreEventArgument", handle_obj_ptr(_obj.datastore), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMFSDatastoreCreatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.datastore)
			return new DatastoreEventArgument_closure(*_obj.datastore);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VMFSDatastoreExpandedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMFSDatastoreExpandedEvent", context);
	update_member(update, "datastore", "DatastoreEventArgument", handle_obj_ptr(_obj.datastore), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMFSDatastoreExpandedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.datastore)
			return new DatastoreEventArgument_closure(*_obj.datastore);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VMFSDatastoreExtendedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMFSDatastoreExtendedEvent", context);
	update_member(update, "datastore", "DatastoreEventArgument", handle_obj_ptr(_obj.datastore), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMFSDatastoreExtendedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.datastore)
			return new DatastoreEventArgument_closure(*_obj.datastore);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return HostEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VMotionLicenseExpiredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMotionLicenseExpiredEvent", context);
	update("Base", "LicenseEvent", context);
	LicenseEvent_closure(dynamic_cast<const vw1__LicenseEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMotionLicenseExpiredEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMwareDVSConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMwareDVSConfigInfo", context);
	update_member_with_version(update, "ipfixConfig", "VMwareIpfixConfig", handle_obj_ptr(_obj.ipfixConfig), context, "5.0");
	update_member(update, "linkDiscoveryProtocolConfig", "LinkDiscoveryProtocolConfig", handle_obj_ptr(_obj.linkDiscoveryProtocolConfig), context);
	update_member(update, "maxMtu", "xsd:int", basic2str(_obj.maxMtu), context);
	update_member(update, "pvlanConfig", "VMwareDVSPvlanMapEntry[]", a2s_object(_obj.pvlanConfig, _obj.__sizepvlanConfig), context);
	update_member_with_version(update, "vspanSession", "VMwareVspanSession[]", a2s_object(_obj.vspanSession, _obj.__sizevspanSession), context, "5.0");
	update("Base", "DVSConfigInfo", context);
	DVSConfigInfo_closure(dynamic_cast<const vw1__DVSConfigInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMwareDVSConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.ipfixConfig)
			return new VMwareIpfixConfig_closure(*_obj.ipfixConfig);
		else
			return 0;
	case 1:
		if (_obj.linkDiscoveryProtocolConfig)
			return new LinkDiscoveryProtocolConfig_closure(*_obj.linkDiscoveryProtocolConfig);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepvlanConfig)
				return new VMwareDVSPvlanMapEntry_closure(*_obj.pvlanConfig[i]);
			else
				return 0;
		}
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevspanSession)
				return new VMwareVspanSession_closure(*_obj.vspanSession[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DVSConfigInfo_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void VMwareDVSConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMwareDVSConfigSpec", context);
	update_member_with_version(update, "ipfixConfig", "VMwareIpfixConfig", handle_obj_ptr(_obj.ipfixConfig), context, "5.0");
	update_member(update, "linkDiscoveryProtocolConfig", "LinkDiscoveryProtocolConfig", handle_obj_ptr(_obj.linkDiscoveryProtocolConfig), context);
	update_member(update, "maxMtu", "xsd:int", basic2str(_obj.maxMtu), context);
	update_member(update, "pvlanConfigSpec", "VMwareDVSPvlanConfigSpec[]", a2s_object(_obj.pvlanConfigSpec, _obj.__sizepvlanConfigSpec), context);
	update_member_with_version(update, "vspanConfigSpec", "VMwareDVSVspanConfigSpec[]", a2s_object(_obj.vspanConfigSpec, _obj.__sizevspanConfigSpec), context, "5.0");
	update("Base", "DVSConfigSpec", context);
	DVSConfigSpec_closure(dynamic_cast<const vw1__DVSConfigSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMwareDVSConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.ipfixConfig)
			return new VMwareIpfixConfig_closure(*_obj.ipfixConfig);
		else
			return 0;
	case 1:
		if (_obj.linkDiscoveryProtocolConfig)
			return new LinkDiscoveryProtocolConfig_closure(*_obj.linkDiscoveryProtocolConfig);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepvlanConfigSpec)
				return new VMwareDVSPvlanConfigSpec_closure(*_obj.pvlanConfigSpec[i]);
			else
				return 0;
		}
	case 4:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevspanConfigSpec)
				return new VMwareDVSVspanConfigSpec_closure(*_obj.vspanConfigSpec[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DVSConfigSpec_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void VMwareDVSFeatureCapability_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMwareDVSFeatureCapability", context);
	update_member_with_version(update, "ipfixSupported", "xsd:boolean", basic2str(_obj.ipfixSupported), context, "5.0");
	update_member_with_version(update, "lldpSupported", "xsd:boolean", basic2str(_obj.lldpSupported), context, "5.0");
	update_member_with_version(update, "vspanSupported", "xsd:boolean", basic2str(_obj.vspanSupported), context, "5.0");
	update("Base", "DVSFeatureCapability", context);
	DVSFeatureCapability_closure(dynamic_cast<const vw1__DVSFeatureCapability&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMwareDVSFeatureCapability_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMwareDVSPortSetting_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMwareDVSPortSetting", context);
	update_member_with_version(update, "ipfixEnabled", "BoolPolicy", handle_obj_ptr(_obj.ipfixEnabled), context, "5.0");
	update_member(update, "qosTag", "IntPolicy", handle_obj_ptr(_obj.qosTag), context);
	update_member(update, "securityPolicy", "DVSSecurityPolicy", handle_obj_ptr(_obj.securityPolicy), context);
	update_member(update, "txUplink", "BoolPolicy", handle_obj_ptr(_obj.txUplink), context);
	update_member(update, "uplinkTeamingPolicy", "VmwareUplinkPortTeamingPolicy", handle_obj_ptr(_obj.uplinkTeamingPolicy), context);
	update_member(update, "vlan", "VmwareDistributedVirtualSwitchVlanSpec", handle_obj_ptr(_obj.vlan), context);
	update("Base", "DVPortSetting", context);
	DVPortSetting_closure(dynamic_cast<const vw1__DVPortSetting&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMwareDVSPortSetting_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.ipfixEnabled)
			return new BoolPolicy_closure(*_obj.ipfixEnabled);
		else
			return 0;
	case 1:
		if (_obj.qosTag)
			return new IntPolicy_closure(*_obj.qosTag);
		else
			return 0;
	case 2:
		if (_obj.securityPolicy)
			return new DVSSecurityPolicy_closure(*_obj.securityPolicy);
		else
			return 0;
	case 3:
		if (_obj.txUplink)
			return new BoolPolicy_closure(*_obj.txUplink);
		else
			return 0;
	case 4:
		if (_obj.uplinkTeamingPolicy)
			return new VmwareUplinkPortTeamingPolicy_closure(*_obj.uplinkTeamingPolicy);
		else
			return 0;
	case 5:
		if (_obj.vlan)
			return new VmwareDistributedVirtualSwitchVlanSpec_closure(*_obj.vlan);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DVPortSetting_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void VMwareDVSPortgroupPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMwareDVSPortgroupPolicy", context);
	update_member_with_version(update, "ipfixOverrideAllowed", "xsd:boolean", basic2str(_obj.ipfixOverrideAllowed), context, "5.0");
	update_member(update, "securityPolicyOverrideAllowed", "xsd:boolean", basic2str(_obj.securityPolicyOverrideAllowed), context);
	update_member(update, "uplinkTeamingOverrideAllowed", "xsd:boolean", basic2str(_obj.uplinkTeamingOverrideAllowed), context);
	update_member(update, "vlanOverrideAllowed", "xsd:boolean", basic2str(_obj.vlanOverrideAllowed), context);
	update("Base", "DVPortgroupPolicy", context);
	DVPortgroupPolicy_closure(dynamic_cast<const vw1__DVPortgroupPolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMwareDVSPortgroupPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMwareDVSPvlanConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMwareDVSPvlanConfigSpec", context);
	update_member(update, "operation", "xsd:string", basic2str(_obj.operation), context);
	update_member(update, "pvlanEntry", "VMwareDVSPvlanMapEntry", handle_obj_ptr(_obj.pvlanEntry), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMwareDVSPvlanConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.pvlanEntry)
			return new VMwareDVSPvlanMapEntry_closure(*_obj.pvlanEntry);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VMwareDVSPvlanMapEntry_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMwareDVSPvlanMapEntry", context);
	update_member(update, "primaryVlanId", "xsd:int", basic2str(_obj.primaryVlanId), context);
	update_member(update, "pvlanType", "xsd:string", basic2str(_obj.pvlanType), context);
	update_member(update, "secondaryVlanId", "xsd:int", basic2str(_obj.secondaryVlanId), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMwareDVSPvlanMapEntry_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMwareDVSVspanConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMwareDVSVspanConfigSpec", context);
	update_member(update, "operation", "xsd:string", basic2str(_obj.operation), context);
	update_member(update, "vspanSession", "VMwareVspanSession", handle_obj_ptr(_obj.vspanSession), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMwareDVSVspanConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.vspanSession)
			return new VMwareVspanSession_closure(*_obj.vspanSession);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VMwareIpfixConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMwareIpfixConfig", context);
	update_member(update, "activeFlowTimeout", "xsd:int", basic2str(_obj.activeFlowTimeout), context);
	update_member(update, "collectorIpAddress", "xsd:string", basic2str(_obj.collectorIpAddress), context);
	update_member(update, "collectorPort", "xsd:int", basic2str(_obj.collectorPort), context);
	update_member(update, "idleFlowTimeout", "xsd:int", basic2str(_obj.idleFlowTimeout), context);
	update_member(update, "internalFlowsOnly", "xsd:boolean", basic2str(_obj.internalFlowsOnly), context);
	update_member(update, "samplingRate", "xsd:int", basic2str(_obj.samplingRate), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMwareIpfixConfig_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMwareUplinkPortOrderPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMwareUplinkPortOrderPolicy", context);
	update_member(update, "activeUplinkPort", "xsd:string[]", a2s_basic(*_obj.activeUplinkPort, _obj.__sizeactiveUplinkPort), context);
	update_member(update, "standbyUplinkPort", "xsd:string[]", a2s_basic(*_obj.standbyUplinkPort, _obj.__sizestandbyUplinkPort), context);
	update("Base", "InheritablePolicy", context);
	InheritablePolicy_closure(dynamic_cast<const vw1__InheritablePolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMwareUplinkPortOrderPolicy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMwareVspanPort_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMwareVspanPort", context);
	update_member(update, "portKey", "xsd:string[]", a2s_basic(*_obj.portKey, _obj.__sizeportKey), context);
	update_member(update, "uplinkPortName", "xsd:string[]", a2s_basic(*_obj.uplinkPortName, _obj.__sizeuplinkPortName), context);
	update_member(update, "wildcardPortConnecteeType", "xsd:string[]", a2s_basic(*_obj.wildcardPortConnecteeType, _obj.__sizewildcardPortConnecteeType), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMwareVspanPort_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMwareVspanSession_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMwareVspanSession", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "destinationPort", "VMwareVspanPort", handle_obj_ptr(_obj.destinationPort), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "encapsulationVlanId", "xsd:int", basic2str(_obj.encapsulationVlanId), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "mirroredPacketLength", "xsd:int", basic2str(_obj.mirroredPacketLength), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "normalTrafficAllowed", "xsd:boolean", basic2str(_obj.normalTrafficAllowed), context);
	update_member(update, "sourcePortReceived", "VMwareVspanPort", handle_obj_ptr(_obj.sourcePortReceived), context);
	update_member(update, "sourcePortTransmitted", "VMwareVspanPort", handle_obj_ptr(_obj.sourcePortTransmitted), context);
	update_member(update, "stripOriginalVlan", "xsd:boolean", basic2str(_obj.stripOriginalVlan), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMwareVspanSession_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.destinationPort)
			return new VMwareVspanPort_closure(*_obj.destinationPort);
		else
			return 0;
	case 8:
		if (_obj.sourcePortReceived)
			return new VMwareVspanPort_closure(*_obj.sourcePortReceived);
		else
			return 0;
	case 9:
		if (_obj.sourcePortTransmitted)
			return new VMwareVspanPort_closure(*_obj.sourcePortTransmitted);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void VcAgentUninstallFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VcAgentUninstallFailedEvent", context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VcAgentUninstallFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VcAgentUninstalledEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VcAgentUninstalledEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VcAgentUninstalledEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VcAgentUpgradeFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VcAgentUpgradeFailedEvent", context);
	update_member_with_version(update, "reason", "xsd:string", basic2str(_obj.reason), context, "4.0");
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VcAgentUpgradeFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VcAgentUpgradedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VcAgentUpgradedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VcAgentUpgradedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VimAccountPasswordChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VimAccountPasswordChangedEvent", context);
	update("Base", "HostEvent", context);
	HostEvent_closure(dynamic_cast<const vw1__HostEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VimAccountPasswordChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualAppImportSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualAppImportSpec", context);
	update_member(update, "child", "ImportSpec[]", a2s_object(_obj.child, _obj.__sizechild), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "resourcePoolSpec", "ResourceConfigSpec", handle_obj_ptr(_obj.resourcePoolSpec), context);
	update_member(update, "vAppConfigSpec", "VAppConfigSpec", handle_obj_ptr(_obj.vAppConfigSpec), context);
	update("Base", "ImportSpec", context);
	ImportSpec_closure(dynamic_cast<const vw1__ImportSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualAppImportSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizechild)
				return new ImportSpec_closure(*_obj.child[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.resourcePoolSpec)
			return new ResourceConfigSpec_closure(*_obj.resourcePoolSpec);
		else
			return 0;
	case 3:
		if (_obj.vAppConfigSpec)
			return new VAppConfigSpec_closure(*_obj.vAppConfigSpec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ImportSpec_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VirtualAppLinkInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualAppLinkInfo", context);
	update_member(update, "destroyWithParent", "xsd:boolean", basic2str(_obj.destroyWithParent), context);
	update_member(update, "key", "ManagedEntity", handle_obj_ptr(_obj.key), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualAppLinkInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.key? 
			get_closure_from_mor(ManagedEntity(_obj.key)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualAppSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualAppSummary", context);
	update_member(update, "installBootRequired", "xsd:boolean", basic2str(_obj.installBootRequired), context);
	update_member_with_version(update, "instanceUuid", "xsd:string", basic2str(_obj.instanceUuid), context, "4.1");
	update_member(update, "product", "VAppProductInfo", handle_obj_ptr(_obj.product), context);
	update_member_with_version(update, "suspended", "xsd:boolean", basic2str(_obj.suspended), context, "4.1");
	update_member(update, "vAppState", "VirtualAppVAppState", handle_obj_ptr(_obj.vAppState), context);
	update("Base", "ResourcePoolSummary", context);
	ResourcePoolSummary_closure(dynamic_cast<const vw1__ResourcePoolSummary&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualAppSummary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.product)
			return new VAppProductInfo_closure(*_obj.product);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ResourcePoolSummary_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void VirtualBusLogicController_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualBusLogicController", context);
	update("Base", "VirtualSCSIController", context);
	VirtualSCSIController_closure(dynamic_cast<const vw1__VirtualSCSIController&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualBusLogicController_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualBusLogicControllerOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualBusLogicControllerOption", context);
	update("Base", "VirtualSCSIControllerOption", context);
	VirtualSCSIControllerOption_closure(dynamic_cast<const vw1__VirtualSCSIControllerOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualBusLogicControllerOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualCdrom_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualCdrom", context);
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualCdrom_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualCdromAtapiBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualCdromAtapiBackingInfo", context);
	update("Base", "VirtualDeviceDeviceBackingInfo", context);
	VirtualDeviceDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualCdromAtapiBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualCdromAtapiBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualCdromAtapiBackingOption", context);
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualCdromAtapiBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualCdromIsoBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualCdromIsoBackingInfo", context);
	update("Base", "VirtualDeviceFileBackingInfo", context);
	VirtualDeviceFileBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualCdromIsoBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualCdromIsoBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualCdromIsoBackingOption", context);
	update("Base", "VirtualDeviceFileBackingOption", context);
	VirtualDeviceFileBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualCdromIsoBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualCdromOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualCdromOption", context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualCdromOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualCdromPassthroughBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualCdromPassthroughBackingInfo", context);
	update_member(update, "exclusive", "xsd:boolean", basic2str(_obj.exclusive), context);
	update("Base", "VirtualDeviceDeviceBackingInfo", context);
	VirtualDeviceDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualCdromPassthroughBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualCdromPassthroughBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualCdromPassthroughBackingOption", context);
	update_member(update, "exclusive", "BoolOption", handle_obj_ptr(_obj.exclusive), context);
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualCdromPassthroughBackingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.exclusive)
			return new BoolOption_closure(*_obj.exclusive);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceDeviceBackingOption_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VirtualCdromRemoteAtapiBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualCdromRemoteAtapiBackingInfo", context);
	update("Base", "VirtualDeviceRemoteDeviceBackingInfo", context);
	VirtualDeviceRemoteDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceRemoteDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualCdromRemoteAtapiBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualCdromRemoteAtapiBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualCdromRemoteAtapiBackingOption", context);
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualCdromRemoteAtapiBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualCdromRemotePassthroughBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualCdromRemotePassthroughBackingInfo", context);
	update_member(update, "exclusive", "xsd:boolean", basic2str(_obj.exclusive), context);
	update("Base", "VirtualDeviceRemoteDeviceBackingInfo", context);
	VirtualDeviceRemoteDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceRemoteDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualCdromRemotePassthroughBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualCdromRemotePassthroughBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualCdromRemotePassthroughBackingOption", context);
	update_member(update, "exclusive", "BoolOption", handle_obj_ptr(_obj.exclusive), context);
	update("Base", "VirtualDeviceRemoteDeviceBackingOption", context);
	VirtualDeviceRemoteDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceRemoteDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualCdromRemotePassthroughBackingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.exclusive)
			return new BoolOption_closure(*_obj.exclusive);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceRemoteDeviceBackingOption_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VirtualController_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualController", context);
	update_member(update, "busNumber", "xsd:int", basic2str(_obj.busNumber), context);
	update_member(update, "device", "xsd:int[]", a2s_basic(_obj.device, _obj.__sizedevice), context);
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualController_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualControllerOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualControllerOption", context);
	update_member(update, "devices", "IntOption", handle_obj_ptr(_obj.devices), context);
	update_member(update, "supportedDevice", "xsd:string[]", a2s_basic(*_obj.supportedDevice, _obj.__sizesupportedDevice), context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualControllerOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.devices)
			return new IntOption_closure(*_obj.devices);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceOption_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDevice", context);
	update_member(update, "backing", "VirtualDeviceBackingInfo", handle_obj_ptr(_obj.backing), context);
	update_member(update, "connectable", "VirtualDeviceConnectInfo", handle_obj_ptr(_obj.connectable), context);
	update_member(update, "controllerKey", "xsd:int", basic2str(_obj.controllerKey), context);
	update_member(update, "deviceInfo", "Description", handle_obj_ptr(_obj.deviceInfo), context);
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update_member(update, "unitNumber", "xsd:int", basic2str(_obj.unitNumber), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDevice_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.backing)
			return new VirtualDeviceBackingInfo_closure(*_obj.backing);
		else
			return 0;
	case 1:
		if (_obj.connectable)
			return new VirtualDeviceConnectInfo_closure(*_obj.connectable);
		else
			return 0;
	case 3:
		if (_obj.deviceInfo)
			return new Description_closure(*_obj.deviceInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void VirtualDeviceBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDeviceBackingInfo", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDeviceBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualDeviceBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDeviceBackingOption", context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDeviceBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualDeviceConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDeviceConfigSpec", context);
	update_member(update, "device", "VirtualDevice", handle_obj_ptr(_obj.device), context);
	update_member(update, "fileOperation", "VirtualDeviceConfigSpecFileOperation", handle_obj_ptr(_obj.fileOperation), context);
	update_member(update, "operation", "VirtualDeviceConfigSpecOperation", handle_obj_ptr(_obj.operation), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDeviceConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.device)
			return new VirtualDevice_closure(*_obj.device);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VirtualDeviceConnectInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDeviceConnectInfo", context);
	update_member(update, "allowGuestControl", "xsd:boolean", basic2str(_obj.allowGuestControl), context);
	update_member(update, "connected", "xsd:boolean", basic2str(_obj.connected), context);
	update_member(update, "startConnected", "xsd:boolean", basic2str(_obj.startConnected), context);
	update_member_with_version(update, "status", "xsd:string", basic2str(_obj.status), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDeviceConnectInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualDeviceConnectOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDeviceConnectOption", context);
	update_member(update, "allowGuestControl", "BoolOption", handle_obj_ptr(_obj.allowGuestControl), context);
	update_member(update, "startConnected", "BoolOption", handle_obj_ptr(_obj.startConnected), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDeviceConnectOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.allowGuestControl)
			return new BoolOption_closure(*_obj.allowGuestControl);
		else
			return 0;
	case 1:
		if (_obj.startConnected)
			return new BoolOption_closure(*_obj.startConnected);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualDeviceDeviceBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDeviceDeviceBackingInfo", context);
	update_member(update, "deviceName", "xsd:string", basic2str(_obj.deviceName), context);
	update_member_with_version(update, "useAutoDetect", "xsd:boolean", basic2str(_obj.useAutoDetect), context, "2.5");
	update("Base", "VirtualDeviceBackingInfo", context);
	VirtualDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDeviceDeviceBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualDeviceDeviceBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDeviceDeviceBackingOption", context);
	update_member_with_version(update, "autoDetectAvailable", "BoolOption", handle_obj_ptr(_obj.autoDetectAvailable), context, "2.5");
	update("Base", "VirtualDeviceBackingOption", context);
	VirtualDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDeviceDeviceBackingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.autoDetectAvailable)
			return new BoolOption_closure(*_obj.autoDetectAvailable);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceBackingOption_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VirtualDeviceFileBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDeviceFileBackingInfo", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "fileName", "xsd:string", basic2str(_obj.fileName), context);
	update("Base", "VirtualDeviceBackingInfo", context);
	VirtualDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDeviceFileBackingInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceBackingInfo_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualDeviceFileBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDeviceFileBackingOption", context);
	update_member(update, "fileNameExtensions", "ChoiceOption", handle_obj_ptr(_obj.fileNameExtensions), context);
	update("Base", "VirtualDeviceBackingOption", context);
	VirtualDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDeviceFileBackingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fileNameExtensions)
			return new ChoiceOption_closure(*_obj.fileNameExtensions);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceBackingOption_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VirtualDeviceOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDeviceOption", context);
	update_member(update, "autoAssignController", "BoolOption", handle_obj_ptr(_obj.autoAssignController), context);
	update_member(update, "backingOption", "VirtualDeviceBackingOption[]", a2s_object(_obj.backingOption, _obj.__sizebackingOption), context);
	update_member(update, "connectOption", "VirtualDeviceConnectOption", handle_obj_ptr(_obj.connectOption), context);
	update_member(update, "controllerType", "xsd:string", basic2str(_obj.controllerType), context);
	update_member(update, "defaultBackingOptionIndex", "xsd:int", basic2str(_obj.defaultBackingOptionIndex), context);
	update_member(update, "deprecated", "xsd:boolean", basic2str(_obj.deprecated), context);
	update_member_with_version(update, "hotRemoveSupported", "xsd:boolean", basic2str(_obj.hotRemoveSupported), context, "4.0");
	update_member(update, "licensingLimit", "xsd:string[]", a2s_basic(*_obj.licensingLimit, _obj.__sizelicensingLimit), context);
	update_member(update, "plugAndPlay", "xsd:boolean", basic2str(_obj.plugAndPlay), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDeviceOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.autoAssignController)
			return new BoolOption_closure(*_obj.autoAssignController);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizebackingOption)
				return new VirtualDeviceBackingOption_closure(*_obj.backingOption[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.connectOption)
			return new VirtualDeviceConnectOption_closure(*_obj.connectOption);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 10) << 16) + arr_index);
	}
	return 0;
}

void VirtualDevicePipeBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDevicePipeBackingInfo", context);
	update_member(update, "pipeName", "xsd:string", basic2str(_obj.pipeName), context);
	update("Base", "VirtualDeviceBackingInfo", context);
	VirtualDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDevicePipeBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualDevicePipeBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDevicePipeBackingOption", context);
	update("Base", "VirtualDeviceBackingOption", context);
	VirtualDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDevicePipeBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualDeviceRemoteDeviceBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDeviceRemoteDeviceBackingInfo", context);
	update_member(update, "deviceName", "xsd:string", basic2str(_obj.deviceName), context);
	update_member_with_version(update, "useAutoDetect", "xsd:boolean", basic2str(_obj.useAutoDetect), context, "2.5");
	update("Base", "VirtualDeviceBackingInfo", context);
	VirtualDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDeviceRemoteDeviceBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualDeviceRemoteDeviceBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDeviceRemoteDeviceBackingOption", context);
	update_member_with_version(update, "autoDetectAvailable", "BoolOption", handle_obj_ptr(_obj.autoDetectAvailable), context, "2.5");
	update("Base", "VirtualDeviceBackingOption", context);
	VirtualDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDeviceRemoteDeviceBackingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.autoDetectAvailable)
			return new BoolOption_closure(*_obj.autoDetectAvailable);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceBackingOption_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VirtualDeviceURIBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDeviceURIBackingInfo", context);
	update_member(update, "direction", "xsd:string", basic2str(_obj.direction), context);
	update_member(update, "proxyURI", "xsd:string", basic2str(_obj.proxyURI), context);
	update_member(update, "serviceURI", "xsd:string", basic2str(_obj.serviceURI), context);
	update("Base", "VirtualDeviceBackingInfo", context);
	VirtualDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDeviceURIBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualDeviceURIBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDeviceURIBackingOption", context);
	update_member(update, "directions", "ChoiceOption", handle_obj_ptr(_obj.directions), context);
	update("Base", "VirtualDeviceBackingOption", context);
	VirtualDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDeviceURIBackingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.directions)
			return new ChoiceOption_closure(*_obj.directions);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceBackingOption_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VirtualDisk_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDisk", context);
	update_member(update, "capacityInKB", "xsd:long", basic2str(_obj.capacityInKB), context);
	update_member(update, "shares", "SharesInfo", handle_obj_ptr(_obj.shares), context);
	update_member_with_version(update, "storageIOAllocation", "StorageIOAllocationInfo", handle_obj_ptr(_obj.storageIOAllocation), context, "4.1");
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDisk_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.shares)
			return new SharesInfo_closure(*_obj.shares);
		else
			return 0;
	case 2:
		if (_obj.storageIOAllocation)
			return new StorageIOAllocationInfo_closure(*_obj.storageIOAllocation);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDevice_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskAntiAffinityRuleSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskAntiAffinityRuleSpec", context);
	update_member(update, "diskId", "xsd:int[]", a2s_basic(_obj.diskId, _obj.__sizediskId), context);
	update("Base", "ClusterRuleInfo", context);
	ClusterRuleInfo_closure(dynamic_cast<const vw1__ClusterRuleInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskAntiAffinityRuleSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualDiskFlatVer1BackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskFlatVer1BackingInfo", context);
	update_member_with_version(update, "contentId", "xsd:string", basic2str(_obj.contentId), context, "4.0");
	update_member(update, "diskMode", "xsd:string", basic2str(_obj.diskMode), context);
	update_member_with_version(update, "parent", "VirtualDiskFlatVer1BackingInfo", handle_obj_ptr(_obj.parent), context, "4.0");
	update_member(update, "split", "xsd:boolean", basic2str(_obj.split), context);
	update_member(update, "writeThrough", "xsd:boolean", basic2str(_obj.writeThrough), context);
	update("Base", "VirtualDeviceFileBackingInfo", context);
	VirtualDeviceFileBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskFlatVer1BackingInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.parent)
			return new VirtualDiskFlatVer1BackingInfo_closure(*_obj.parent);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceFileBackingInfo_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskFlatVer1BackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskFlatVer1BackingOption", context);
	update_member(update, "diskMode", "ChoiceOption", handle_obj_ptr(_obj.diskMode), context);
	update_member(update, "growable", "xsd:boolean", basic2str(_obj.growable), context);
	update_member(update, "split", "BoolOption", handle_obj_ptr(_obj.split), context);
	update_member(update, "writeThrough", "BoolOption", handle_obj_ptr(_obj.writeThrough), context);
	update("Base", "VirtualDeviceFileBackingOption", context);
	VirtualDeviceFileBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskFlatVer1BackingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.diskMode)
			return new ChoiceOption_closure(*_obj.diskMode);
		else
			return 0;
	case 2:
		if (_obj.split)
			return new BoolOption_closure(*_obj.split);
		else
			return 0;
	case 3:
		if (_obj.writeThrough)
			return new BoolOption_closure(*_obj.writeThrough);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceFileBackingOption_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskFlatVer2BackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskFlatVer2BackingInfo", context);
	update_member_with_version(update, "changeId", "xsd:string", basic2str(_obj.changeId), context, "4.0");
	update_member_with_version(update, "contentId", "xsd:string", basic2str(_obj.contentId), context, "4.0");
	update_member_with_version(update, "deltaDiskFormat", "xsd:string", basic2str(_obj.deltaDiskFormat), context, "5.0");
	update_member_with_version(update, "digestEnabled", "xsd:boolean", basic2str(_obj.digestEnabled), context, "5.0");
	update_member(update, "diskMode", "xsd:string", basic2str(_obj.diskMode), context);
	update_member_with_version(update, "eagerlyScrub", "xsd:boolean", basic2str(_obj.eagerlyScrub), context, "4.0");
	update_member_with_version(update, "parent", "VirtualDiskFlatVer2BackingInfo", handle_obj_ptr(_obj.parent), context, "4.0");
	update_member(update, "split", "xsd:boolean", basic2str(_obj.split), context);
	update_member(update, "thinProvisioned", "xsd:boolean", basic2str(_obj.thinProvisioned), context);
	update_member_with_version(update, "uuid", "xsd:string", basic2str(_obj.uuid), context, "2.5");
	update_member(update, "writeThrough", "xsd:boolean", basic2str(_obj.writeThrough), context);
	update("Base", "VirtualDeviceFileBackingInfo", context);
	VirtualDeviceFileBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskFlatVer2BackingInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 6:
		if (_obj.parent)
			return new VirtualDiskFlatVer2BackingInfo_closure(*_obj.parent);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceFileBackingInfo_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskFlatVer2BackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskFlatVer2BackingOption", context);
	update_member_with_version(update, "deltaDiskFormat", "ChoiceOption", handle_obj_ptr(_obj.deltaDiskFormat), context, "5.0");
	update_member(update, "diskMode", "ChoiceOption", handle_obj_ptr(_obj.diskMode), context);
	update_member_with_version(update, "eagerlyScrub", "BoolOption", handle_obj_ptr(_obj.eagerlyScrub), context, "4.0");
	update_member(update, "growable", "xsd:boolean", basic2str(_obj.growable), context);
	update_member_with_version(update, "hotGrowable", "xsd:boolean", basic2str(_obj.hotGrowable), context, "2.5");
	update_member(update, "split", "BoolOption", handle_obj_ptr(_obj.split), context);
	update_member_with_version(update, "thinProvisioned", "BoolOption", handle_obj_ptr(_obj.thinProvisioned), context, "4.0");
	update_member_with_version(update, "uuid", "xsd:boolean", basic2str(_obj.uuid), context, "2.5");
	update_member(update, "writeThrough", "BoolOption", handle_obj_ptr(_obj.writeThrough), context);
	update("Base", "VirtualDeviceFileBackingOption", context);
	VirtualDeviceFileBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskFlatVer2BackingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.deltaDiskFormat)
			return new ChoiceOption_closure(*_obj.deltaDiskFormat);
		else
			return 0;
	case 1:
		if (_obj.diskMode)
			return new ChoiceOption_closure(*_obj.diskMode);
		else
			return 0;
	case 2:
		if (_obj.eagerlyScrub)
			return new BoolOption_closure(*_obj.eagerlyScrub);
		else
			return 0;
	case 5:
		if (_obj.split)
			return new BoolOption_closure(*_obj.split);
		else
			return 0;
	case 6:
		if (_obj.thinProvisioned)
			return new BoolOption_closure(*_obj.thinProvisioned);
		else
			return 0;
	case 8:
		if (_obj.writeThrough)
			return new BoolOption_closure(*_obj.writeThrough);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceFileBackingOption_closure(_obj).get_sub_closure(((prop_index - 9) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskId_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskId", context);
	update_member(update, "diskId", "xsd:int", basic2str(_obj.diskId), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskId_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskOption", context);
	update_member(update, "capacityInKB", "LongOption", handle_obj_ptr(_obj.capacityInKB), context);
	update_member_with_version(update, "ioAllocationOption", "StorageIOAllocationOption", handle_obj_ptr(_obj.ioAllocationOption), context, "4.1");
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.capacityInKB)
			return new LongOption_closure(*_obj.capacityInKB);
		else
			return 0;
	case 1:
		if (_obj.ioAllocationOption)
			return new StorageIOAllocationOption_closure(*_obj.ioAllocationOption);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceOption_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskPartitionedRawDiskVer2BackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskPartitionedRawDiskVer2BackingInfo", context);
	update_member(update, "partition", "xsd:int[]", a2s_basic(_obj.partition, _obj.__sizepartition), context);
	update("Base", "VirtualDiskRawDiskVer2BackingInfo", context);
	VirtualDiskRawDiskVer2BackingInfo_closure(dynamic_cast<const vw1__VirtualDiskRawDiskVer2BackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskPartitionedRawDiskVer2BackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualDiskPartitionedRawDiskVer2BackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskPartitionedRawDiskVer2BackingOption", context);
	update("Base", "VirtualDiskRawDiskVer2BackingOption", context);
	VirtualDiskRawDiskVer2BackingOption_closure(dynamic_cast<const vw1__VirtualDiskRawDiskVer2BackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskPartitionedRawDiskVer2BackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualDiskRawDiskMappingVer1BackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskRawDiskMappingVer1BackingInfo", context);
	update_member_with_version(update, "changeId", "xsd:string", basic2str(_obj.changeId), context, "4.0");
	update_member(update, "compatibilityMode", "xsd:string", basic2str(_obj.compatibilityMode), context);
	update_member_with_version(update, "contentId", "xsd:string", basic2str(_obj.contentId), context, "4.0");
	update_member(update, "deviceName", "xsd:string", basic2str(_obj.deviceName), context);
	update_member(update, "diskMode", "xsd:string", basic2str(_obj.diskMode), context);
	update_member(update, "lunUuid", "xsd:string", basic2str(_obj.lunUuid), context);
	update_member_with_version(update, "parent", "VirtualDiskRawDiskMappingVer1BackingInfo", handle_obj_ptr(_obj.parent), context, "4.0");
	update_member_with_version(update, "uuid", "xsd:string", basic2str(_obj.uuid), context, "2.5");
	update("Base", "VirtualDeviceFileBackingInfo", context);
	VirtualDeviceFileBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskRawDiskMappingVer1BackingInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 6:
		if (_obj.parent)
			return new VirtualDiskRawDiskMappingVer1BackingInfo_closure(*_obj.parent);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceFileBackingInfo_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskRawDiskMappingVer1BackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskRawDiskMappingVer1BackingOption", context);
	update_member(update, "compatibilityMode", "ChoiceOption", handle_obj_ptr(_obj.compatibilityMode), context);
	update_member(update, "descriptorFileNameExtensions", "ChoiceOption", handle_obj_ptr(_obj.descriptorFileNameExtensions), context);
	update_member(update, "diskMode", "ChoiceOption", handle_obj_ptr(_obj.diskMode), context);
	update_member_with_version(update, "uuid", "xsd:boolean", basic2str(_obj.uuid), context, "2.5");
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskRawDiskMappingVer1BackingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.compatibilityMode)
			return new ChoiceOption_closure(*_obj.compatibilityMode);
		else
			return 0;
	case 1:
		if (_obj.descriptorFileNameExtensions)
			return new ChoiceOption_closure(*_obj.descriptorFileNameExtensions);
		else
			return 0;
	case 2:
		if (_obj.diskMode)
			return new ChoiceOption_closure(*_obj.diskMode);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceDeviceBackingOption_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskRawDiskVer2BackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskRawDiskVer2BackingInfo", context);
	update_member_with_version(update, "changeId", "xsd:string", basic2str(_obj.changeId), context, "4.0");
	update_member(update, "descriptorFileName", "xsd:string", basic2str(_obj.descriptorFileName), context);
	update_member_with_version(update, "uuid", "xsd:string", basic2str(_obj.uuid), context, "2.5");
	update("Base", "VirtualDeviceDeviceBackingInfo", context);
	VirtualDeviceDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskRawDiskVer2BackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualDiskRawDiskVer2BackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskRawDiskVer2BackingOption", context);
	update_member(update, "descriptorFileNameExtensions", "ChoiceOption", handle_obj_ptr(_obj.descriptorFileNameExtensions), context);
	update_member_with_version(update, "uuid", "xsd:boolean", basic2str(_obj.uuid), context, "2.5");
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskRawDiskVer2BackingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.descriptorFileNameExtensions)
			return new ChoiceOption_closure(*_obj.descriptorFileNameExtensions);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceDeviceBackingOption_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskSparseVer1BackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskSparseVer1BackingInfo", context);
	update_member_with_version(update, "contentId", "xsd:string", basic2str(_obj.contentId), context, "4.0");
	update_member(update, "diskMode", "xsd:string", basic2str(_obj.diskMode), context);
	update_member_with_version(update, "parent", "VirtualDiskSparseVer1BackingInfo", handle_obj_ptr(_obj.parent), context, "4.0");
	update_member(update, "spaceUsedInKB", "xsd:long", basic2str(_obj.spaceUsedInKB), context);
	update_member(update, "split", "xsd:boolean", basic2str(_obj.split), context);
	update_member(update, "writeThrough", "xsd:boolean", basic2str(_obj.writeThrough), context);
	update("Base", "VirtualDeviceFileBackingInfo", context);
	VirtualDeviceFileBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskSparseVer1BackingInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.parent)
			return new VirtualDiskSparseVer1BackingInfo_closure(*_obj.parent);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceFileBackingInfo_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskSparseVer1BackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskSparseVer1BackingOption", context);
	update_member(update, "diskModes", "ChoiceOption", handle_obj_ptr(_obj.diskModes), context);
	update_member(update, "growable", "xsd:boolean", basic2str(_obj.growable), context);
	update_member(update, "split", "BoolOption", handle_obj_ptr(_obj.split), context);
	update_member(update, "writeThrough", "BoolOption", handle_obj_ptr(_obj.writeThrough), context);
	update("Base", "VirtualDeviceFileBackingOption", context);
	VirtualDeviceFileBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskSparseVer1BackingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.diskModes)
			return new ChoiceOption_closure(*_obj.diskModes);
		else
			return 0;
	case 2:
		if (_obj.split)
			return new BoolOption_closure(*_obj.split);
		else
			return 0;
	case 3:
		if (_obj.writeThrough)
			return new BoolOption_closure(*_obj.writeThrough);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceFileBackingOption_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskSparseVer2BackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskSparseVer2BackingInfo", context);
	update_member_with_version(update, "changeId", "xsd:string", basic2str(_obj.changeId), context, "4.0");
	update_member_with_version(update, "contentId", "xsd:string", basic2str(_obj.contentId), context, "4.0");
	update_member(update, "diskMode", "xsd:string", basic2str(_obj.diskMode), context);
	update_member_with_version(update, "parent", "VirtualDiskSparseVer2BackingInfo", handle_obj_ptr(_obj.parent), context, "4.0");
	update_member(update, "spaceUsedInKB", "xsd:long", basic2str(_obj.spaceUsedInKB), context);
	update_member(update, "split", "xsd:boolean", basic2str(_obj.split), context);
	update_member_with_version(update, "uuid", "xsd:string", basic2str(_obj.uuid), context, "2.5");
	update_member(update, "writeThrough", "xsd:boolean", basic2str(_obj.writeThrough), context);
	update("Base", "VirtualDeviceFileBackingInfo", context);
	VirtualDeviceFileBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskSparseVer2BackingInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		if (_obj.parent)
			return new VirtualDiskSparseVer2BackingInfo_closure(*_obj.parent);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceFileBackingInfo_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskSparseVer2BackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskSparseVer2BackingOption", context);
	update_member(update, "diskMode", "ChoiceOption", handle_obj_ptr(_obj.diskMode), context);
	update_member(update, "growable", "xsd:boolean", basic2str(_obj.growable), context);
	update_member_with_version(update, "hotGrowable", "xsd:boolean", basic2str(_obj.hotGrowable), context, "2.5");
	update_member(update, "split", "BoolOption", handle_obj_ptr(_obj.split), context);
	update_member_with_version(update, "uuid", "xsd:boolean", basic2str(_obj.uuid), context, "2.5");
	update_member(update, "writeThrough", "BoolOption", handle_obj_ptr(_obj.writeThrough), context);
	update("Base", "VirtualDeviceFileBackingOption", context);
	VirtualDeviceFileBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskSparseVer2BackingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.diskMode)
			return new ChoiceOption_closure(*_obj.diskMode);
		else
			return 0;
	case 3:
		if (_obj.split)
			return new BoolOption_closure(*_obj.split);
		else
			return 0;
	case 5:
		if (_obj.writeThrough)
			return new BoolOption_closure(*_obj.writeThrough);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceFileBackingOption_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskSpec", context);
	update_member(update, "adapterType", "xsd:string", basic2str(_obj.adapterType), context);
	update_member(update, "diskType", "xsd:string", basic2str(_obj.diskType), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualE1000_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualE1000", context);
	update("Base", "VirtualEthernetCard", context);
	VirtualEthernetCard_closure(dynamic_cast<const vw1__VirtualEthernetCard&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualE1000_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualE1000Option_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualE1000Option", context);
	update("Base", "VirtualEthernetCardOption", context);
	VirtualEthernetCardOption_closure(dynamic_cast<const vw1__VirtualEthernetCardOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualE1000Option_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualE1000e_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualE1000e", context);
	update("Base", "VirtualEthernetCard", context);
	VirtualEthernetCard_closure(dynamic_cast<const vw1__VirtualEthernetCard&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualE1000e_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualE1000eOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualE1000eOption", context);
	update("Base", "VirtualEthernetCardOption", context);
	VirtualEthernetCardOption_closure(dynamic_cast<const vw1__VirtualEthernetCardOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualE1000eOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualEnsoniq1371_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualEnsoniq1371", context);
	update("Base", "VirtualSoundCard", context);
	VirtualSoundCard_closure(dynamic_cast<const vw1__VirtualSoundCard&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualEnsoniq1371_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualEnsoniq1371Option_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualEnsoniq1371Option", context);
	update("Base", "VirtualSoundCardOption", context);
	VirtualSoundCardOption_closure(dynamic_cast<const vw1__VirtualSoundCardOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualEnsoniq1371Option_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualEthernetCard_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualEthernetCard", context);
	update_member(update, "addressType", "xsd:string", basic2str(_obj.addressType), context);
	update_member(update, "macAddress", "xsd:string", basic2str(_obj.macAddress), context);
	update_member(update, "wakeOnLanEnabled", "xsd:boolean", basic2str(_obj.wakeOnLanEnabled), context);
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualEthernetCard_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualEthernetCardDVPortBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualEthernetCardDVPortBackingOption", context);
	update("Base", "VirtualDeviceBackingOption", context);
	VirtualDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualEthernetCardDVPortBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualEthernetCardDistributedVirtualPortBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualEthernetCardDistributedVirtualPortBackingInfo", context);
	update_member(update, "port", "DistributedVirtualSwitchPortConnection", handle_obj_ptr(_obj.port), context);
	update("Base", "VirtualDeviceBackingInfo", context);
	VirtualDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualEthernetCardDistributedVirtualPortBackingInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.port)
			return new DistributedVirtualSwitchPortConnection_closure(*_obj.port);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceBackingInfo_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VirtualEthernetCardLegacyNetworkBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualEthernetCardLegacyNetworkBackingInfo", context);
	update("Base", "VirtualDeviceDeviceBackingInfo", context);
	VirtualDeviceDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualEthernetCardLegacyNetworkBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualEthernetCardLegacyNetworkBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualEthernetCardLegacyNetworkBackingOption", context);
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualEthernetCardLegacyNetworkBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualEthernetCardNetworkBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualEthernetCardNetworkBackingInfo", context);
	update_member_with_version(update, "inPassthroughMode", "xsd:boolean", basic2str(_obj.inPassthroughMode), context, "4.0");
	update_member(update, "network", "Network", handle_obj_ptr(_obj.network), context);
	update("Base", "VirtualDeviceDeviceBackingInfo", context);
	VirtualDeviceDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualEthernetCardNetworkBackingInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.network? 
			get_closure_from_mor(Network(_obj.network)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceDeviceBackingInfo_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualEthernetCardNetworkBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualEthernetCardNetworkBackingOption", context);
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualEthernetCardNetworkBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualEthernetCardOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualEthernetCardOption", context);
	update_member(update, "macType", "ChoiceOption", handle_obj_ptr(_obj.macType), context);
	update_member(update, "supportedOUI", "ChoiceOption", handle_obj_ptr(_obj.supportedOUI), context);
	update_member_with_version(update, "vmDirectPathGen2Supported", "xsd:boolean", basic2str(_obj.vmDirectPathGen2Supported), context, "4.1");
	update_member(update, "wakeOnLanEnabled", "BoolOption", handle_obj_ptr(_obj.wakeOnLanEnabled), context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualEthernetCardOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.macType)
			return new ChoiceOption_closure(*_obj.macType);
		else
			return 0;
	case 1:
		if (_obj.supportedOUI)
			return new ChoiceOption_closure(*_obj.supportedOUI);
		else
			return 0;
	case 3:
		if (_obj.wakeOnLanEnabled)
			return new BoolOption_closure(*_obj.wakeOnLanEnabled);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceOption_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VirtualFloppy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualFloppy", context);
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualFloppy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualFloppyDeviceBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualFloppyDeviceBackingInfo", context);
	update("Base", "VirtualDeviceDeviceBackingInfo", context);
	VirtualDeviceDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualFloppyDeviceBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualFloppyDeviceBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualFloppyDeviceBackingOption", context);
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualFloppyDeviceBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualFloppyImageBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualFloppyImageBackingInfo", context);
	update("Base", "VirtualDeviceFileBackingInfo", context);
	VirtualDeviceFileBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualFloppyImageBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualFloppyImageBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualFloppyImageBackingOption", context);
	update("Base", "VirtualDeviceFileBackingOption", context);
	VirtualDeviceFileBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualFloppyImageBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualFloppyOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualFloppyOption", context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualFloppyOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualFloppyRemoteDeviceBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualFloppyRemoteDeviceBackingInfo", context);
	update("Base", "VirtualDeviceRemoteDeviceBackingInfo", context);
	VirtualDeviceRemoteDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceRemoteDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualFloppyRemoteDeviceBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualFloppyRemoteDeviceBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualFloppyRemoteDeviceBackingOption", context);
	update("Base", "VirtualDeviceRemoteDeviceBackingOption", context);
	VirtualDeviceRemoteDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceRemoteDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualFloppyRemoteDeviceBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualHardware_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualHardware", context);
	update_member(update, "device", "VirtualDevice[]", a2s_object(_obj.device, _obj.__sizedevice), context);
	update_member(update, "memoryMB", "xsd:int", basic2str(_obj.memoryMB), context);
	update_member_with_version(update, "numCoresPerSocket", "xsd:int", basic2str(_obj.numCoresPerSocket), context, "5.0");
	update_member(update, "numCPU", "xsd:int", basic2str(_obj.numCPU), context);
	update_member_with_version(update, "virtualICH7MPresent", "xsd:boolean", basic2str(_obj.virtualICH7MPresent), context, "5.0");
	update_member_with_version(update, "virtualSMCPresent", "xsd:boolean", basic2str(_obj.virtualSMCPresent), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualHardware_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedevice)
				return new VirtualDevice_closure(*_obj.device[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void VirtualHardwareOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualHardwareOption", context);
	update_member(update, "deviceListReadonly", "xsd:boolean", basic2str(_obj.deviceListReadonly), context);
	update_member(update, "hwVersion", "xsd:int", basic2str(_obj.hwVersion), context);
	update_member(update, "licensingLimit", "xsd:string[]", a2s_basic(*_obj.licensingLimit, _obj.__sizelicensingLimit), context);
	update_member(update, "memoryMB", "LongOption", handle_obj_ptr(_obj.memoryMB), context);
	update_member_with_version(update, "numCoresPerSocket", "IntOption", handle_obj_ptr(_obj.numCoresPerSocket), context, "5.0");
	update_member(update, "numCPU", "xsd:int[]", a2s_basic(_obj.numCPU, _obj.__sizenumCPU), context);
	update_member(update, "numCpuReadonly", "xsd:boolean", basic2str(_obj.numCpuReadonly), context);
	update_member(update, "numIDEControllers", "IntOption", handle_obj_ptr(_obj.numIDEControllers), context);
	update_member(update, "numPCIControllers", "IntOption", handle_obj_ptr(_obj.numPCIControllers), context);
	update_member(update, "numPS2Controllers", "IntOption", handle_obj_ptr(_obj.numPS2Controllers), context);
	update_member(update, "numSIOControllers", "IntOption", handle_obj_ptr(_obj.numSIOControllers), context);
	update_member_with_version(update, "numSupportedWwnNodes", "IntOption", handle_obj_ptr(_obj.numSupportedWwnNodes), context, "4.0");
	update_member_with_version(update, "numSupportedWwnPorts", "IntOption", handle_obj_ptr(_obj.numSupportedWwnPorts), context, "4.0");
	update_member(update, "numUSBControllers", "IntOption", handle_obj_ptr(_obj.numUSBControllers), context);
	update_member_with_version(update, "numUSBXHCIControllers", "IntOption", handle_obj_ptr(_obj.numUSBXHCIControllers), context, "5.0");
	update_member_with_version(update, "resourceConfigOption", "ResourceConfigOption", handle_obj_ptr(_obj.resourceConfigOption), context, "4.1");
	update_member(update, "virtualDeviceOption", "VirtualDeviceOption[]", a2s_object(_obj.virtualDeviceOption, _obj.__sizevirtualDeviceOption), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualHardwareOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		if (_obj.memoryMB)
			return new LongOption_closure(*_obj.memoryMB);
		else
			return 0;
	case 4:
		if (_obj.numCoresPerSocket)
			return new IntOption_closure(*_obj.numCoresPerSocket);
		else
			return 0;
	case 7:
		if (_obj.numIDEControllers)
			return new IntOption_closure(*_obj.numIDEControllers);
		else
			return 0;
	case 8:
		if (_obj.numPCIControllers)
			return new IntOption_closure(*_obj.numPCIControllers);
		else
			return 0;
	case 9:
		if (_obj.numPS2Controllers)
			return new IntOption_closure(*_obj.numPS2Controllers);
		else
			return 0;
	case 10:
		if (_obj.numSIOControllers)
			return new IntOption_closure(*_obj.numSIOControllers);
		else
			return 0;
	case 11:
		if (_obj.numSupportedWwnNodes)
			return new IntOption_closure(*_obj.numSupportedWwnNodes);
		else
			return 0;
	case 12:
		if (_obj.numSupportedWwnPorts)
			return new IntOption_closure(*_obj.numSupportedWwnPorts);
		else
			return 0;
	case 13:
		if (_obj.numUSBControllers)
			return new IntOption_closure(*_obj.numUSBControllers);
		else
			return 0;
	case 14:
		if (_obj.numUSBXHCIControllers)
			return new IntOption_closure(*_obj.numUSBXHCIControllers);
		else
			return 0;
	case 15:
		if (_obj.resourceConfigOption)
			return new ResourceConfigOption_closure(*_obj.resourceConfigOption);
		else
			return 0;
	case 16:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevirtualDeviceOption)
				return new VirtualDeviceOption_closure(*_obj.virtualDeviceOption[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 17) << 16) + arr_index);
	}
	return 0;
}

void VirtualHdAudioCard_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualHdAudioCard", context);
	update("Base", "VirtualSoundCard", context);
	VirtualSoundCard_closure(dynamic_cast<const vw1__VirtualSoundCard&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualHdAudioCard_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualHdAudioCardOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualHdAudioCardOption", context);
	update("Base", "VirtualSoundCardOption", context);
	VirtualSoundCardOption_closure(dynamic_cast<const vw1__VirtualSoundCardOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualHdAudioCardOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualIDEController_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualIDEController", context);
	update("Base", "VirtualController", context);
	VirtualController_closure(dynamic_cast<const vw1__VirtualController&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualIDEController_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualIDEControllerOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualIDEControllerOption", context);
	update_member(update, "numIDECdroms", "IntOption", handle_obj_ptr(_obj.numIDECdroms), context);
	update_member(update, "numIDEDisks", "IntOption", handle_obj_ptr(_obj.numIDEDisks), context);
	update("Base", "VirtualControllerOption", context);
	VirtualControllerOption_closure(dynamic_cast<const vw1__VirtualControllerOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualIDEControllerOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.numIDECdroms)
			return new IntOption_closure(*_obj.numIDECdroms);
		else
			return 0;
	case 1:
		if (_obj.numIDEDisks)
			return new IntOption_closure(*_obj.numIDEDisks);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualControllerOption_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualKeyboard_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualKeyboard", context);
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualKeyboard_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualKeyboardOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualKeyboardOption", context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualKeyboardOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualLsiLogicController_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualLsiLogicController", context);
	update("Base", "VirtualSCSIController", context);
	VirtualSCSIController_closure(dynamic_cast<const vw1__VirtualSCSIController&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualLsiLogicController_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualLsiLogicControllerOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualLsiLogicControllerOption", context);
	update("Base", "VirtualSCSIControllerOption", context);
	VirtualSCSIControllerOption_closure(dynamic_cast<const vw1__VirtualSCSIControllerOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualLsiLogicControllerOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualLsiLogicSASController_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualLsiLogicSASController", context);
	update("Base", "VirtualSCSIController", context);
	VirtualSCSIController_closure(dynamic_cast<const vw1__VirtualSCSIController&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualLsiLogicSASController_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualLsiLogicSASControllerOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualLsiLogicSASControllerOption", context);
	update("Base", "VirtualSCSIControllerOption", context);
	VirtualSCSIControllerOption_closure(dynamic_cast<const vw1__VirtualSCSIControllerOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualLsiLogicSASControllerOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineAffinityInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineAffinityInfo", context);
	update_member(update, "affinitySet", "xsd:int[]", a2s_basic(_obj.affinitySet, _obj.__sizeaffinitySet), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineAffinityInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineBootOptions_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineBootOptions", context);
	update_member(update, "bootDelay", "xsd:long", basic2str(_obj.bootDelay), context);
	update_member_with_version(update, "bootOrder", "VirtualMachineBootOptionsBootableDevice[]", a2s_object(_obj.bootOrder, _obj.__sizebootOrder), context, "5.0");
	update_member_with_version(update, "bootRetryDelay", "xsd:long", basic2str(_obj.bootRetryDelay), context, "4.1");
	update_member_with_version(update, "bootRetryEnabled", "xsd:boolean", basic2str(_obj.bootRetryEnabled), context, "4.1");
	update_member(update, "enterBIOSSetup", "xsd:boolean", basic2str(_obj.enterBIOSSetup), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineBootOptions_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizebootOrder)
				return new VirtualMachineBootOptionsBootableDevice_closure(*_obj.bootOrder[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineBootOptionsBootableCdromDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineBootOptionsBootableCdromDevice", context);
	update("Base", "VirtualMachineBootOptionsBootableDevice", context);
	VirtualMachineBootOptionsBootableDevice_closure(dynamic_cast<const vw1__VirtualMachineBootOptionsBootableDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineBootOptionsBootableCdromDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineBootOptionsBootableDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineBootOptionsBootableDevice", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineBootOptionsBootableDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineBootOptionsBootableDiskDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineBootOptionsBootableDiskDevice", context);
	update_member(update, "deviceKey", "xsd:int", basic2str(_obj.deviceKey), context);
	update("Base", "VirtualMachineBootOptionsBootableDevice", context);
	VirtualMachineBootOptionsBootableDevice_closure(dynamic_cast<const vw1__VirtualMachineBootOptionsBootableDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineBootOptionsBootableDiskDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineBootOptionsBootableEthernetDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineBootOptionsBootableEthernetDevice", context);
	update_member(update, "deviceKey", "xsd:int", basic2str(_obj.deviceKey), context);
	update("Base", "VirtualMachineBootOptionsBootableDevice", context);
	VirtualMachineBootOptionsBootableDevice_closure(dynamic_cast<const vw1__VirtualMachineBootOptionsBootableDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineBootOptionsBootableEthernetDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineBootOptionsBootableFloppyDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineBootOptionsBootableFloppyDevice", context);
	update("Base", "VirtualMachineBootOptionsBootableDevice", context);
	VirtualMachineBootOptionsBootableDevice_closure(dynamic_cast<const vw1__VirtualMachineBootOptionsBootableDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineBootOptionsBootableFloppyDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineCapability_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineCapability", context);
	update_member_with_version(update, "bootOptionsSupported", "xsd:boolean", basic2str(_obj.bootOptionsSupported), context, "2.5");
	update_member_with_version(update, "bootRetryOptionsSupported", "xsd:boolean", basic2str(_obj.bootRetryOptionsSupported), context, "4.1");
	update_member_with_version(update, "changeTrackingSupported", "xsd:boolean", basic2str(_obj.changeTrackingSupported), context, "4.0");
	update_member(update, "consolePreferencesSupported", "xsd:boolean", basic2str(_obj.consolePreferencesSupported), context);
	update_member(update, "cpuFeatureMaskSupported", "xsd:boolean", basic2str(_obj.cpuFeatureMaskSupported), context);
	update_member_with_version(update, "disableSnapshotsSupported", "xsd:boolean", basic2str(_obj.disableSnapshotsSupported), context, "2.5");
	update_member_with_version(update, "diskSharesSupported", "xsd:boolean", basic2str(_obj.diskSharesSupported), context, "2.5");
	update_member_with_version(update, "guestAutoLockSupported", "xsd:boolean", basic2str(_obj.guestAutoLockSupported), context, "5.0");
	update_member_with_version(update, "hostBasedReplicationSupported", "xsd:boolean", basic2str(_obj.hostBasedReplicationSupported), context, "5.0");
	update_member_with_version(update, "lockSnapshotsSupported", "xsd:boolean", basic2str(_obj.lockSnapshotsSupported), context, "2.5");
	update_member_with_version(update, "memoryReservationLockSupported", "xsd:boolean", basic2str(_obj.memoryReservationLockSupported), context, "5.0");
	update_member(update, "memorySnapshotsSupported", "xsd:boolean", basic2str(_obj.memorySnapshotsSupported), context);
	update_member_with_version(update, "multipleCoresPerSocketSupported", "xsd:boolean", basic2str(_obj.multipleCoresPerSocketSupported), context, "5.0");
	update_member(update, "multipleSnapshotsSupported", "xsd:boolean", basic2str(_obj.multipleSnapshotsSupported), context);
	update_member_with_version(update, "npivWwnOnNonRdmVmSupported", "xsd:boolean", basic2str(_obj.npivWwnOnNonRdmVmSupported), context, "2.5");
	update_member(update, "poweredOffSnapshotsSupported", "xsd:boolean", basic2str(_obj.poweredOffSnapshotsSupported), context);
	update_member(update, "quiescedSnapshotsSupported", "xsd:boolean", basic2str(_obj.quiescedSnapshotsSupported), context);
	update_member_with_version(update, "recordReplaySupported", "xsd:boolean", basic2str(_obj.recordReplaySupported), context, "4.0");
	update_member(update, "revertToSnapshotSupported", "xsd:boolean", basic2str(_obj.revertToSnapshotSupported), context);
	update_member(update, "s1AcpiManagementSupported", "xsd:boolean", basic2str(_obj.s1AcpiManagementSupported), context);
	update_member_with_version(update, "settingDisplayTopologySupported", "xsd:boolean", basic2str(_obj.settingDisplayTopologySupported), context, "4.0");
	update_member(update, "settingScreenResolutionSupported", "xsd:boolean", basic2str(_obj.settingScreenResolutionSupported), context);
	update_member_with_version(update, "settingVideoRamSizeSupported", "xsd:boolean", basic2str(_obj.settingVideoRamSizeSupported), context, "2.5");
	update_member(update, "snapshotConfigSupported", "xsd:boolean", basic2str(_obj.snapshotConfigSupported), context);
	update_member(update, "snapshotOperationsSupported", "xsd:boolean", basic2str(_obj.snapshotOperationsSupported), context);
	update_member_with_version(update, "swapPlacementSupported", "xsd:boolean", basic2str(_obj.swapPlacementSupported), context, "2.5");
	update_member(update, "toolsAutoUpdateSupported", "xsd:boolean", basic2str(_obj.toolsAutoUpdateSupported), context);
	update_member_with_version(update, "toolsSyncTimeSupported", "xsd:boolean", basic2str(_obj.toolsSyncTimeSupported), context, "2.5");
	update_member_with_version(update, "virtualMmuUsageSupported", "xsd:boolean", basic2str(_obj.virtualMmuUsageSupported), context, "2.5");
	update_member_with_version(update, "vmNpivWwnDisableSupported", "xsd:boolean", basic2str(_obj.vmNpivWwnDisableSupported), context, "4.0");
	update_member_with_version(update, "vmNpivWwnSupported", "xsd:boolean", basic2str(_obj.vmNpivWwnSupported), context, "2.5");
	update_member_with_version(update, "vmNpivWwnUpdateSupported", "xsd:boolean", basic2str(_obj.vmNpivWwnUpdateSupported), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineCapability_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineCdromInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineCdromInfo", context);
	update("Base", "VirtualMachineTargetInfo", context);
	VirtualMachineTargetInfo_closure(dynamic_cast<const vw1__VirtualMachineTargetInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineCdromInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineCloneSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineCloneSpec", context);
	update_member(update, "config", "VirtualMachineConfigSpec", handle_obj_ptr(_obj.config), context);
	update_member(update, "customization", "CustomizationSpec", handle_obj_ptr(_obj.customization), context);
	update_member(update, "location", "VirtualMachineRelocateSpec", handle_obj_ptr(_obj.location), context);
	update_member(update, "powerOn", "xsd:boolean", basic2str(_obj.powerOn), context);
	update_member_with_version(update, "snapshot", "VirtualMachineSnapshot", handle_obj_ptr(_obj.snapshot), context, "4.0");
	update_member(update, "template_", "xsd:boolean", basic2str(_obj.template_), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineCloneSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.config)
			return new VirtualMachineConfigSpec_closure(*_obj.config);
		else
			return 0;
	case 1:
		if (_obj.customization)
			return new CustomizationSpec_closure(*_obj.customization);
		else
			return 0;
	case 2:
		if (_obj.location)
			return new VirtualMachineRelocateSpec_closure(*_obj.location);
		else
			return 0;
	case 4:
		return _obj.snapshot? 
			get_closure_from_mor(VirtualMachineSnapshot(_obj.snapshot)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineConfigInfo", context);
	update_member_with_version(update, "alternateGuestName", "xsd:string", basic2str(_obj.alternateGuestName), context, "2.5");
	update_member(update, "annotation", "xsd:string", basic2str(_obj.annotation), context);
	update_member_with_version(update, "bootOptions", "VirtualMachineBootOptions", handle_obj_ptr(_obj.bootOptions), context, "2.5");
	update_member_with_version(update, "changeTrackingEnabled", "xsd:boolean", basic2str(_obj.changeTrackingEnabled), context, "4.0");
	update_member(update, "changeVersion", "xsd:string", basic2str(_obj.changeVersion), context);
	update_member(update, "consolePreferences", "VirtualMachineConsolePreferences", handle_obj_ptr(_obj.consolePreferences), context);
	update_member(update, "cpuAffinity", "VirtualMachineAffinityInfo", handle_obj_ptr(_obj.cpuAffinity), context);
	update_member(update, "cpuAllocation", "ResourceAllocationInfo", handle_obj_ptr(_obj.cpuAllocation), context);
	update_member(update, "cpuFeatureMask", "HostCpuIdInfo[]", a2s_object(_obj.cpuFeatureMask, _obj.__sizecpuFeatureMask), context);
	update_member_with_version(update, "cpuHotAddEnabled", "xsd:boolean", basic2str(_obj.cpuHotAddEnabled), context, "4.0");
	update_member_with_version(update, "cpuHotRemoveEnabled", "xsd:boolean", basic2str(_obj.cpuHotRemoveEnabled), context, "4.0");
	update_member(update, "datastoreUrl", "VirtualMachineConfigInfoDatastoreUrlPair[]", a2s_object(_obj.datastoreUrl, _obj.__sizedatastoreUrl), context);
	update_member(update, "defaultPowerOps", "VirtualMachineDefaultPowerOpInfo", handle_obj_ptr(_obj.defaultPowerOps), context);
	update_member(update, "extraConfig", "OptionValue[]", a2s_object(_obj.extraConfig, _obj.__sizeextraConfig), context);
	update_member(update, "files", "VirtualMachineFileInfo", handle_obj_ptr(_obj.files), context);
	update_member_with_version(update, "firmware", "xsd:string", basic2str(_obj.firmware), context, "5.0");
	update_member(update, "flags", "VirtualMachineFlagInfo", handle_obj_ptr(_obj.flags), context);
	update_member_with_version(update, "ftInfo", "FaultToleranceConfigInfo", handle_obj_ptr(_obj.ftInfo), context, "4.0");
	update_member_with_version(update, "guestAutoLockEnabled", "xsd:boolean", basic2str(_obj.guestAutoLockEnabled), context, "5.0");
	update_member(update, "guestFullName", "xsd:string", basic2str(_obj.guestFullName), context);
	update_member(update, "guestId", "xsd:string", basic2str(_obj.guestId), context);
	update_member(update, "hardware", "VirtualHardware", handle_obj_ptr(_obj.hardware), context);
	update_member_with_version(update, "hotPlugMemoryIncrementSize", "xsd:long", basic2str(_obj.hotPlugMemoryIncrementSize), context, "4.0");
	update_member_with_version(update, "hotPlugMemoryLimit", "xsd:long", basic2str(_obj.hotPlugMemoryLimit), context, "4.0");
	update_member_with_version(update, "initialOverhead", "VirtualMachineConfigInfoOverheadInfo", handle_obj_ptr(_obj.initialOverhead), context, "5.0");
	update_member_with_version(update, "instanceUuid", "xsd:string", basic2str(_obj.instanceUuid), context, "4.0");
	update_member(update, "locationId", "xsd:string", basic2str(_obj.locationId), context);
	update_member_with_version(update, "managedBy", "ManagedByInfo", handle_obj_ptr(_obj.managedBy), context, "5.0");
	update_member_with_version(update, "maxMksConnections", "xsd:int", basic2str(_obj.maxMksConnections), context, "5.0");
	update_member(update, "memoryAffinity", "VirtualMachineAffinityInfo", handle_obj_ptr(_obj.memoryAffinity), context);
	update_member(update, "memoryAllocation", "ResourceAllocationInfo", handle_obj_ptr(_obj.memoryAllocation), context);
	update_member_with_version(update, "memoryHotAddEnabled", "xsd:boolean", basic2str(_obj.memoryHotAddEnabled), context, "4.0");
	update_member_with_version(update, "memoryReservationLockedToMax", "xsd:boolean", basic2str(_obj.memoryReservationLockedToMax), context, "5.0");
	update_member(update, "modified", "xsd:dateTime", basic2str(_obj.modified), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "networkShaper", "VirtualMachineNetworkShaperInfo", handle_obj_ptr(_obj.networkShaper), context);
	update_member_with_version(update, "npivDesiredNodeWwns", "xsd:short", basic2str(_obj.npivDesiredNodeWwns), context, "4.0");
	update_member_with_version(update, "npivDesiredPortWwns", "xsd:short", basic2str(_obj.npivDesiredPortWwns), context, "4.0");
	update_member_with_version(update, "npivNodeWorldWideName", "xsd:long[]", a2s_basic(_obj.npivNodeWorldWideName, _obj.__sizenpivNodeWorldWideName), context, "2.5");
	update_member_with_version(update, "npivOnNonRdmDisks", "xsd:boolean", basic2str(_obj.npivOnNonRdmDisks), context, "4.0");
	update_member_with_version(update, "npivPortWorldWideName", "xsd:long[]", a2s_basic(_obj.npivPortWorldWideName, _obj.__sizenpivPortWorldWideName), context, "2.5");
	update_member_with_version(update, "npivTemporaryDisabled", "xsd:boolean", basic2str(_obj.npivTemporaryDisabled), context, "4.0");
	update_member_with_version(update, "npivWorldWideNameType", "xsd:string", basic2str(_obj.npivWorldWideNameType), context, "2.5");
	update_member_with_version(update, "swapPlacement", "xsd:string", basic2str(_obj.swapPlacement), context, "2.5");
	update_member(update, "template_", "xsd:boolean", basic2str(_obj.template_), context);
	update_member(update, "tools", "ToolsConfigInfo", handle_obj_ptr(_obj.tools), context);
	update_member(update, "uuid", "xsd:string", basic2str(_obj.uuid), context);
	update_member_with_version(update, "vAppConfig", "VmConfigInfo", handle_obj_ptr(_obj.vAppConfig), context, "4.0");
	update_member_with_version(update, "vAssertsEnabled", "xsd:boolean", basic2str(_obj.vAssertsEnabled), context, "4.0");
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.bootOptions)
			return new VirtualMachineBootOptions_closure(*_obj.bootOptions);
		else
			return 0;
	case 5:
		if (_obj.consolePreferences)
			return new VirtualMachineConsolePreferences_closure(*_obj.consolePreferences);
		else
			return 0;
	case 6:
		if (_obj.cpuAffinity)
			return new VirtualMachineAffinityInfo_closure(*_obj.cpuAffinity);
		else
			return 0;
	case 7:
		if (_obj.cpuAllocation)
			return new ResourceAllocationInfo_closure(*_obj.cpuAllocation);
		else
			return 0;
	case 8:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecpuFeatureMask)
				return new HostCpuIdInfo_closure(*_obj.cpuFeatureMask[i]);
			else
				return 0;
		}
	case 11:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedatastoreUrl)
				return new VirtualMachineConfigInfoDatastoreUrlPair_closure(*_obj.datastoreUrl[i]);
			else
				return 0;
		}
	case 12:
		if (_obj.defaultPowerOps)
			return new VirtualMachineDefaultPowerOpInfo_closure(*_obj.defaultPowerOps);
		else
			return 0;
	case 13:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeextraConfig)
				return new OptionValue_closure(*_obj.extraConfig[i]);
			else
				return 0;
		}
	case 14:
		if (_obj.files)
			return new VirtualMachineFileInfo_closure(*_obj.files);
		else
			return 0;
	case 16:
		if (_obj.flags)
			return new VirtualMachineFlagInfo_closure(*_obj.flags);
		else
			return 0;
	case 17:
		if (_obj.ftInfo)
			return new FaultToleranceConfigInfo_closure(*_obj.ftInfo);
		else
			return 0;
	case 21:
		if (_obj.hardware)
			return new VirtualHardware_closure(*_obj.hardware);
		else
			return 0;
	case 24:
		if (_obj.initialOverhead)
			return new VirtualMachineConfigInfoOverheadInfo_closure(*_obj.initialOverhead);
		else
			return 0;
	case 27:
		if (_obj.managedBy)
			return new ManagedByInfo_closure(*_obj.managedBy);
		else
			return 0;
	case 29:
		if (_obj.memoryAffinity)
			return new VirtualMachineAffinityInfo_closure(*_obj.memoryAffinity);
		else
			return 0;
	case 30:
		if (_obj.memoryAllocation)
			return new ResourceAllocationInfo_closure(*_obj.memoryAllocation);
		else
			return 0;
	case 35:
		if (_obj.networkShaper)
			return new VirtualMachineNetworkShaperInfo_closure(*_obj.networkShaper);
		else
			return 0;
	case 45:
		if (_obj.tools)
			return new ToolsConfigInfo_closure(*_obj.tools);
		else
			return 0;
	case 47:
		if (_obj.vAppConfig)
			return new VmConfigInfo_closure(*_obj.vAppConfig);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 50) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineConfigInfoDatastoreUrlPair_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineConfigInfoDatastoreUrlPair", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "url", "xsd:string", basic2str(_obj.url), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineConfigInfoDatastoreUrlPair_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineConfigInfoOverheadInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineConfigInfoOverheadInfo", context);
	update_member(update, "initialMemoryReservation", "xsd:long", basic2str(_obj.initialMemoryReservation), context);
	update_member(update, "initialSwapReservation", "xsd:long", basic2str(_obj.initialSwapReservation), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineConfigInfoOverheadInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineConfigOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineConfigOption", context);
	update_member(update, "capabilities", "VirtualMachineCapability", handle_obj_ptr(_obj.capabilities), context);
	update_member(update, "datastore", "DatastoreOption", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "defaultDevice", "VirtualDevice[]", a2s_object(_obj.defaultDevice, _obj.__sizedefaultDevice), context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "guestOSDefaultIndex", "xsd:int", basic2str(_obj.guestOSDefaultIndex), context);
	update_member(update, "guestOSDescriptor", "GuestOsDescriptor[]", a2s_object(_obj.guestOSDescriptor, _obj.__sizeguestOSDescriptor), context);
	update_member(update, "hardwareOptions", "VirtualHardwareOption", handle_obj_ptr(_obj.hardwareOptions), context);
	update_member_with_version(update, "supportedMonitorType", "xsd:string[]", a2s_basic(*_obj.supportedMonitorType, _obj.__sizesupportedMonitorType), context, "2.5");
	update_member_with_version(update, "supportedOvfEnvironmentTransport", "xsd:string[]", a2s_basic(*_obj.supportedOvfEnvironmentTransport, _obj.__sizesupportedOvfEnvironmentTransport), context, "4.0");
	update_member_with_version(update, "supportedOvfInstallTransport", "xsd:string[]", a2s_basic(*_obj.supportedOvfInstallTransport, _obj.__sizesupportedOvfInstallTransport), context, "4.0");
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineConfigOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.capabilities)
			return new VirtualMachineCapability_closure(*_obj.capabilities);
		else
			return 0;
	case 1:
		if (_obj.datastore)
			return new DatastoreOption_closure(*_obj.datastore);
		else
			return 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedefaultDevice)
				return new VirtualDevice_closure(*_obj.defaultDevice[i]);
			else
				return 0;
		}
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeguestOSDescriptor)
				return new GuestOsDescriptor_closure(*_obj.guestOSDescriptor[i]);
			else
				return 0;
		}
	case 6:
		if (_obj.hardwareOptions)
			return new VirtualHardwareOption_closure(*_obj.hardwareOptions);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineConfigOptionDescriptor_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineConfigOptionDescriptor", context);
	update_member_with_version(update, "createSupported", "xsd:boolean", basic2str(_obj.createSupported), context, "4.0");
	update_member_with_version(update, "defaultConfigOption", "xsd:boolean", basic2str(_obj.defaultConfigOption), context, "4.0");
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "host", "HostSystem[]", a2s_object(_obj.host, _obj.__sizehost), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineConfigOptionDescriptor_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehost)
				return new HostSystem_closure(_obj.host[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineConfigSpec", context);
	update_member_with_version(update, "alternateGuestName", "xsd:string", basic2str(_obj.alternateGuestName), context, "2.5");
	update_member(update, "annotation", "xsd:string", basic2str(_obj.annotation), context);
	update_member_with_version(update, "bootOptions", "VirtualMachineBootOptions", handle_obj_ptr(_obj.bootOptions), context, "2.5");
	update_member_with_version(update, "changeTrackingEnabled", "xsd:boolean", basic2str(_obj.changeTrackingEnabled), context, "4.0");
	update_member(update, "changeVersion", "xsd:string", basic2str(_obj.changeVersion), context);
	update_member(update, "consolePreferences", "VirtualMachineConsolePreferences", handle_obj_ptr(_obj.consolePreferences), context);
	update_member(update, "cpuAffinity", "VirtualMachineAffinityInfo", handle_obj_ptr(_obj.cpuAffinity), context);
	update_member(update, "cpuAllocation", "ResourceAllocationInfo", handle_obj_ptr(_obj.cpuAllocation), context);
	update_member(update, "cpuFeatureMask", "VirtualMachineCpuIdInfoSpec[]", a2s_object(_obj.cpuFeatureMask, _obj.__sizecpuFeatureMask), context);
	update_member_with_version(update, "cpuHotAddEnabled", "xsd:boolean", basic2str(_obj.cpuHotAddEnabled), context, "4.0");
	update_member_with_version(update, "cpuHotRemoveEnabled", "xsd:boolean", basic2str(_obj.cpuHotRemoveEnabled), context, "4.0");
	update_member(update, "deviceChange", "VirtualDeviceConfigSpec[]", a2s_object(_obj.deviceChange, _obj.__sizedeviceChange), context);
	update_member(update, "extraConfig", "OptionValue[]", a2s_object(_obj.extraConfig, _obj.__sizeextraConfig), context);
	update_member(update, "files", "VirtualMachineFileInfo", handle_obj_ptr(_obj.files), context);
	update_member_with_version(update, "firmware", "xsd:string", basic2str(_obj.firmware), context, "5.0");
	update_member(update, "flags", "VirtualMachineFlagInfo", handle_obj_ptr(_obj.flags), context);
	update_member_with_version(update, "ftInfo", "FaultToleranceConfigInfo", handle_obj_ptr(_obj.ftInfo), context, "4.0");
	update_member_with_version(update, "guestAutoLockEnabled", "xsd:boolean", basic2str(_obj.guestAutoLockEnabled), context, "5.0");
	update_member(update, "guestId", "xsd:string", basic2str(_obj.guestId), context);
	update_member_with_version(update, "instanceUuid", "xsd:string", basic2str(_obj.instanceUuid), context, "4.0");
	update_member(update, "locationId", "xsd:string", basic2str(_obj.locationId), context);
	update_member_with_version(update, "managedBy", "ManagedByInfo", handle_obj_ptr(_obj.managedBy), context, "5.0");
	update_member_with_version(update, "maxMksConnections", "xsd:int", basic2str(_obj.maxMksConnections), context, "5.0");
	update_member(update, "memoryAffinity", "VirtualMachineAffinityInfo", handle_obj_ptr(_obj.memoryAffinity), context);
	update_member(update, "memoryAllocation", "ResourceAllocationInfo", handle_obj_ptr(_obj.memoryAllocation), context);
	update_member_with_version(update, "memoryHotAddEnabled", "xsd:boolean", basic2str(_obj.memoryHotAddEnabled), context, "4.0");
	update_member(update, "memoryMB", "xsd:long", basic2str(_obj.memoryMB), context);
	update_member_with_version(update, "memoryReservationLockedToMax", "xsd:boolean", basic2str(_obj.memoryReservationLockedToMax), context, "5.0");
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "networkShaper", "VirtualMachineNetworkShaperInfo", handle_obj_ptr(_obj.networkShaper), context);
	update_member_with_version(update, "npivDesiredNodeWwns", "xsd:short", basic2str(_obj.npivDesiredNodeWwns), context, "4.0");
	update_member_with_version(update, "npivDesiredPortWwns", "xsd:short", basic2str(_obj.npivDesiredPortWwns), context, "4.0");
	update_member_with_version(update, "npivNodeWorldWideName", "xsd:long[]", a2s_basic(_obj.npivNodeWorldWideName, _obj.__sizenpivNodeWorldWideName), context, "2.5");
	update_member_with_version(update, "npivOnNonRdmDisks", "xsd:boolean", basic2str(_obj.npivOnNonRdmDisks), context, "4.0");
	update_member_with_version(update, "npivPortWorldWideName", "xsd:long[]", a2s_basic(_obj.npivPortWorldWideName, _obj.__sizenpivPortWorldWideName), context, "2.5");
	update_member_with_version(update, "npivTemporaryDisabled", "xsd:boolean", basic2str(_obj.npivTemporaryDisabled), context, "4.0");
	update_member_with_version(update, "npivWorldWideNameOp", "xsd:string", basic2str(_obj.npivWorldWideNameOp), context, "2.5");
	update_member_with_version(update, "npivWorldWideNameType", "xsd:string", basic2str(_obj.npivWorldWideNameType), context, "2.5");
	update_member_with_version(update, "numCoresPerSocket", "xsd:int", basic2str(_obj.numCoresPerSocket), context, "5.0");
	update_member(update, "numCPUs", "xsd:int", basic2str(_obj.numCPUs), context);
	update_member(update, "powerOpInfo", "VirtualMachineDefaultPowerOpInfo", handle_obj_ptr(_obj.powerOpInfo), context);
	update_member_with_version(update, "swapPlacement", "xsd:string", basic2str(_obj.swapPlacement), context, "2.5");
	update_member(update, "tools", "ToolsConfigInfo", handle_obj_ptr(_obj.tools), context);
	update_member(update, "uuid", "xsd:string", basic2str(_obj.uuid), context);
	update_member_with_version(update, "vAppConfig", "VmConfigSpec", handle_obj_ptr(_obj.vAppConfig), context, "4.0");
	update_member_with_version(update, "vAppConfigRemoved", "xsd:boolean", basic2str(_obj.vAppConfigRemoved), context, "4.0");
	update_member_with_version(update, "vAssertsEnabled", "xsd:boolean", basic2str(_obj.vAssertsEnabled), context, "4.0");
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update_member_with_version(update, "virtualICH7MPresent", "xsd:boolean", basic2str(_obj.virtualICH7MPresent), context, "5.0");
	update_member_with_version(update, "virtualSMCPresent", "xsd:boolean", basic2str(_obj.virtualSMCPresent), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.bootOptions)
			return new VirtualMachineBootOptions_closure(*_obj.bootOptions);
		else
			return 0;
	case 5:
		if (_obj.consolePreferences)
			return new VirtualMachineConsolePreferences_closure(*_obj.consolePreferences);
		else
			return 0;
	case 6:
		if (_obj.cpuAffinity)
			return new VirtualMachineAffinityInfo_closure(*_obj.cpuAffinity);
		else
			return 0;
	case 7:
		if (_obj.cpuAllocation)
			return new ResourceAllocationInfo_closure(*_obj.cpuAllocation);
		else
			return 0;
	case 8:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecpuFeatureMask)
				return new VirtualMachineCpuIdInfoSpec_closure(*_obj.cpuFeatureMask[i]);
			else
				return 0;
		}
	case 11:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedeviceChange)
				return new VirtualDeviceConfigSpec_closure(*_obj.deviceChange[i]);
			else
				return 0;
		}
	case 12:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeextraConfig)
				return new OptionValue_closure(*_obj.extraConfig[i]);
			else
				return 0;
		}
	case 13:
		if (_obj.files)
			return new VirtualMachineFileInfo_closure(*_obj.files);
		else
			return 0;
	case 15:
		if (_obj.flags)
			return new VirtualMachineFlagInfo_closure(*_obj.flags);
		else
			return 0;
	case 16:
		if (_obj.ftInfo)
			return new FaultToleranceConfigInfo_closure(*_obj.ftInfo);
		else
			return 0;
	case 21:
		if (_obj.managedBy)
			return new ManagedByInfo_closure(*_obj.managedBy);
		else
			return 0;
	case 23:
		if (_obj.memoryAffinity)
			return new VirtualMachineAffinityInfo_closure(*_obj.memoryAffinity);
		else
			return 0;
	case 24:
		if (_obj.memoryAllocation)
			return new ResourceAllocationInfo_closure(*_obj.memoryAllocation);
		else
			return 0;
	case 29:
		if (_obj.networkShaper)
			return new VirtualMachineNetworkShaperInfo_closure(*_obj.networkShaper);
		else
			return 0;
	case 40:
		if (_obj.powerOpInfo)
			return new VirtualMachineDefaultPowerOpInfo_closure(*_obj.powerOpInfo);
		else
			return 0;
	case 42:
		if (_obj.tools)
			return new ToolsConfigInfo_closure(*_obj.tools);
		else
			return 0;
	case 44:
		if (_obj.vAppConfig)
			return new VmConfigSpec_closure(*_obj.vAppConfig);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 50) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineConfigSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineConfigSummary", context);
	update_member(update, "annotation", "xsd:string", basic2str(_obj.annotation), context);
	update_member(update, "cpuReservation", "xsd:int", basic2str(_obj.cpuReservation), context);
	update_member_with_version(update, "ftInfo", "FaultToleranceConfigInfo", handle_obj_ptr(_obj.ftInfo), context, "4.0");
	update_member(update, "guestFullName", "xsd:string", basic2str(_obj.guestFullName), context);
	update_member(update, "guestId", "xsd:string", basic2str(_obj.guestId), context);
	update_member_with_version(update, "installBootRequired", "xsd:boolean", basic2str(_obj.installBootRequired), context, "4.0");
	update_member_with_version(update, "instanceUuid", "xsd:string", basic2str(_obj.instanceUuid), context, "4.0");
	update_member_with_version(update, "managedBy", "ManagedByInfo", handle_obj_ptr(_obj.managedBy), context, "5.0");
	update_member(update, "memoryReservation", "xsd:int", basic2str(_obj.memoryReservation), context);
	update_member(update, "memorySizeMB", "xsd:int", basic2str(_obj.memorySizeMB), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "numCpu", "xsd:int", basic2str(_obj.numCpu), context);
	update_member(update, "numEthernetCards", "xsd:int", basic2str(_obj.numEthernetCards), context);
	update_member(update, "numVirtualDisks", "xsd:int", basic2str(_obj.numVirtualDisks), context);
	update_member_with_version(update, "product", "VAppProductInfo", handle_obj_ptr(_obj.product), context, "4.0");
	update_member(update, "template_", "xsd:boolean", basic2str(_obj.template_), context);
	update_member(update, "uuid", "xsd:string", basic2str(_obj.uuid), context);
	update_member(update, "vmPathName", "xsd:string", basic2str(_obj.vmPathName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineConfigSummary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		if (_obj.ftInfo)
			return new FaultToleranceConfigInfo_closure(*_obj.ftInfo);
		else
			return 0;
	case 7:
		if (_obj.managedBy)
			return new ManagedByInfo_closure(*_obj.managedBy);
		else
			return 0;
	case 14:
		if (_obj.product)
			return new VAppProductInfo_closure(*_obj.product);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 18) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineConsolePreferences_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineConsolePreferences", context);
	update_member(update, "closeOnPowerOffOrSuspend", "xsd:boolean", basic2str(_obj.closeOnPowerOffOrSuspend), context);
	update_member(update, "enterFullScreenOnPowerOn", "xsd:boolean", basic2str(_obj.enterFullScreenOnPowerOn), context);
	update_member(update, "powerOnWhenOpened", "xsd:boolean", basic2str(_obj.powerOnWhenOpened), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineConsolePreferences_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineCpuIdInfoSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineCpuIdInfoSpec", context);
	update_member(update, "info", "HostCpuIdInfo", handle_obj_ptr(_obj.info), context);
	update("Base", "ArrayUpdateSpec", context);
	ArrayUpdateSpec_closure(dynamic_cast<const vw1__ArrayUpdateSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineCpuIdInfoSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.info)
			return new HostCpuIdInfo_closure(*_obj.info);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ArrayUpdateSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineDatastoreInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineDatastoreInfo", context);
	update_member(update, "capability", "DatastoreCapability", handle_obj_ptr(_obj.capability), context);
	update_member(update, "datastore", "DatastoreSummary", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "maxFileSize", "xsd:long", basic2str(_obj.maxFileSize), context);
	update_member(update, "mode", "xsd:string", basic2str(_obj.mode), context);
	update_member_with_version(update, "vStorageSupport", "xsd:string", basic2str(_obj.vStorageSupport), context, "5.0");
	update("Base", "VirtualMachineTargetInfo", context);
	VirtualMachineTargetInfo_closure(dynamic_cast<const vw1__VirtualMachineTargetInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineDatastoreInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.capability)
			return new DatastoreCapability_closure(*_obj.capability);
		else
			return 0;
	case 1:
		if (_obj.datastore)
			return new DatastoreSummary_closure(*_obj.datastore);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualMachineTargetInfo_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineDatastoreVolumeOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineDatastoreVolumeOption", context);
	update_member(update, "fileSystemType", "xsd:string", basic2str(_obj.fileSystemType), context);
	update_member(update, "majorVersion", "xsd:int", basic2str(_obj.majorVersion), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineDatastoreVolumeOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineDefaultPowerOpInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineDefaultPowerOpInfo", context);
	update_member(update, "defaultPowerOffType", "xsd:string", basic2str(_obj.defaultPowerOffType), context);
	update_member(update, "defaultResetType", "xsd:string", basic2str(_obj.defaultResetType), context);
	update_member(update, "defaultSuspendType", "xsd:string", basic2str(_obj.defaultSuspendType), context);
	update_member(update, "powerOffType", "xsd:string", basic2str(_obj.powerOffType), context);
	update_member(update, "resetType", "xsd:string", basic2str(_obj.resetType), context);
	update_member(update, "standbyAction", "xsd:string", basic2str(_obj.standbyAction), context);
	update_member(update, "suspendType", "xsd:string", basic2str(_obj.suspendType), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineDefaultPowerOpInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineDeviceRuntimeInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineDeviceRuntimeInfo", context);
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update_member(update, "runtimeState", "VirtualMachineDeviceRuntimeInfoDeviceRuntimeState", handle_obj_ptr(_obj.runtimeState), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineDeviceRuntimeInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.runtimeState)
			return new VirtualMachineDeviceRuntimeInfoDeviceRuntimeState_closure(*_obj.runtimeState);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineDeviceRuntimeInfoDeviceRuntimeState_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineDeviceRuntimeInfoDeviceRuntimeState", context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineDeviceRuntimeInfoDeviceRuntimeState_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState", context);
	update_member(update, "vmDirectPathGen2Active", "xsd:boolean", basic2str(_obj.vmDirectPathGen2Active), context);
	update_member(update, "vmDirectPathGen2InactiveReasonExtended", "xsd:string", basic2str(_obj.vmDirectPathGen2InactiveReasonExtended), context);
	update_member(update, "vmDirectPathGen2InactiveReasonOther", "xsd:string[]", a2s_basic(*_obj.vmDirectPathGen2InactiveReasonOther, _obj.__sizevmDirectPathGen2InactiveReasonOther), context);
	update_member(update, "vmDirectPathGen2InactiveReasonVm", "xsd:string[]", a2s_basic(*_obj.vmDirectPathGen2InactiveReasonVm, _obj.__sizevmDirectPathGen2InactiveReasonVm), context);
	update("Base", "VirtualMachineDeviceRuntimeInfoDeviceRuntimeState", context);
	VirtualMachineDeviceRuntimeInfoDeviceRuntimeState_closure(dynamic_cast<const vw1__VirtualMachineDeviceRuntimeInfoDeviceRuntimeState&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineDiskDeviceInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineDiskDeviceInfo", context);
	update_member(update, "capacity", "xsd:long", basic2str(_obj.capacity), context);
	update_member(update, "vm", "VirtualMachine[]", a2s_object(_obj.vm, _obj.__sizevm), context);
	update("Base", "VirtualMachineTargetInfo", context);
	VirtualMachineTargetInfo_closure(dynamic_cast<const vw1__VirtualMachineTargetInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineDiskDeviceInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevm)
				return new VirtualMachine_closure(_obj.vm[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VirtualMachineTargetInfo_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineDisplayTopology_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineDisplayTopology", context);
	update_member(update, "height", "xsd:int", basic2str(_obj.height), context);
	update_member(update, "width", "xsd:int", basic2str(_obj.width), context);
	update_member(update, "x", "xsd:int", basic2str(_obj.x), context);
	update_member(update, "y", "xsd:int", basic2str(_obj.y), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineDisplayTopology_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineFileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineFileInfo", context);
	update_member(update, "logDirectory", "xsd:string", basic2str(_obj.logDirectory), context);
	update_member(update, "snapshotDirectory", "xsd:string", basic2str(_obj.snapshotDirectory), context);
	update_member(update, "suspendDirectory", "xsd:string", basic2str(_obj.suspendDirectory), context);
	update_member(update, "vmPathName", "xsd:string", basic2str(_obj.vmPathName), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineFileInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineFileLayout_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineFileLayout", context);
	update_member(update, "configFile", "xsd:string[]", a2s_basic(*_obj.configFile, _obj.__sizeconfigFile), context);
	update_member(update, "disk", "VirtualMachineFileLayoutDiskLayout[]", a2s_object(_obj.disk, _obj.__sizedisk), context);
	update_member(update, "logFile", "xsd:string[]", a2s_basic(*_obj.logFile, _obj.__sizelogFile), context);
	update_member(update, "snapshot", "VirtualMachineFileLayoutSnapshotLayout[]", a2s_object(_obj.snapshot, _obj.__sizesnapshot), context);
	update_member(update, "swapFile", "xsd:string", basic2str(_obj.swapFile), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineFileLayout_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedisk)
				return new VirtualMachineFileLayoutDiskLayout_closure(*_obj.disk[i]);
			else
				return 0;
		}
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesnapshot)
				return new VirtualMachineFileLayoutSnapshotLayout_closure(*_obj.snapshot[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineFileLayoutDiskLayout_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineFileLayoutDiskLayout", context);
	update_member(update, "diskFile", "xsd:string[]", a2s_basic(*_obj.diskFile, _obj.__sizediskFile), context);
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineFileLayoutDiskLayout_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineFileLayoutEx_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineFileLayoutEx", context);
	update_member(update, "disk", "VirtualMachineFileLayoutExDiskLayout[]", a2s_object(_obj.disk, _obj.__sizedisk), context);
	update_member(update, "file", "VirtualMachineFileLayoutExFileInfo[]", a2s_object(_obj.file, _obj.__sizefile), context);
	update_member(update, "snapshot", "VirtualMachineFileLayoutExSnapshotLayout[]", a2s_object(_obj.snapshot, _obj.__sizesnapshot), context);
	update_member(update, "timestamp", "xsd:dateTime", basic2str(_obj.timestamp), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineFileLayoutEx_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedisk)
				return new VirtualMachineFileLayoutExDiskLayout_closure(*_obj.disk[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefile)
				return new VirtualMachineFileLayoutExFileInfo_closure(*_obj.file[i]);
			else
				return 0;
		}
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizesnapshot)
				return new VirtualMachineFileLayoutExSnapshotLayout_closure(*_obj.snapshot[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineFileLayoutExDiskLayout_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineFileLayoutExDiskLayout", context);
	update_member(update, "chain", "VirtualMachineFileLayoutExDiskUnit[]", a2s_object(_obj.chain, _obj.__sizechain), context);
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineFileLayoutExDiskLayout_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizechain)
				return new VirtualMachineFileLayoutExDiskUnit_closure(*_obj.chain[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineFileLayoutExDiskUnit_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineFileLayoutExDiskUnit", context);
	update_member(update, "fileKey", "xsd:int[]", a2s_basic(_obj.fileKey, _obj.__sizefileKey), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineFileLayoutExDiskUnit_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineFileLayoutExFileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineFileLayoutExFileInfo", context);
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "size", "xsd:long", basic2str(_obj.size), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineFileLayoutExFileInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineFileLayoutExSnapshotLayout_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineFileLayoutExSnapshotLayout", context);
	update_member(update, "dataKey", "xsd:int", basic2str(_obj.dataKey), context);
	update_member(update, "disk", "VirtualMachineFileLayoutExDiskLayout[]", a2s_object(_obj.disk, _obj.__sizedisk), context);
	update_member(update, "key", "VirtualMachineSnapshot", handle_obj_ptr(_obj.key), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineFileLayoutExSnapshotLayout_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedisk)
				return new VirtualMachineFileLayoutExDiskLayout_closure(*_obj.disk[i]);
			else
				return 0;
		}
	case 2:
		return _obj.key? 
			get_closure_from_mor(VirtualMachineSnapshot(_obj.key)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineFileLayoutSnapshotLayout_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineFileLayoutSnapshotLayout", context);
	update_member(update, "key", "VirtualMachineSnapshot", handle_obj_ptr(_obj.key), context);
	update_member(update, "snapshotFile", "xsd:string[]", a2s_basic(*_obj.snapshotFile, _obj.__sizesnapshotFile), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineFileLayoutSnapshotLayout_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.key? 
			get_closure_from_mor(VirtualMachineSnapshot(_obj.key)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineFlagInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineFlagInfo", context);
	update_member(update, "disableAcceleration", "xsd:boolean", basic2str(_obj.disableAcceleration), context);
	update_member_with_version(update, "diskUuidEnabled", "xsd:boolean", basic2str(_obj.diskUuidEnabled), context, "2.5");
	update_member(update, "enableLogging", "xsd:boolean", basic2str(_obj.enableLogging), context);
	update_member(update, "htSharing", "xsd:string", basic2str(_obj.htSharing), context);
	update_member_with_version(update, "monitorType", "xsd:string", basic2str(_obj.monitorType), context, "2.5");
	update_member_with_version(update, "recordReplayEnabled", "xsd:boolean", basic2str(_obj.recordReplayEnabled), context, "4.0");
	update_member(update, "runWithDebugInfo", "xsd:boolean", basic2str(_obj.runWithDebugInfo), context);
	update_member_with_version(update, "snapshotDisabled", "xsd:boolean", basic2str(_obj.snapshotDisabled), context, "2.5");
	update_member_with_version(update, "snapshotLocked", "xsd:boolean", basic2str(_obj.snapshotLocked), context, "2.5");
	update_member_with_version(update, "snapshotPowerOffBehavior", "xsd:string", basic2str(_obj.snapshotPowerOffBehavior), context, "2.5");
	update_member(update, "useToe", "xsd:boolean", basic2str(_obj.useToe), context);
	update_member_with_version(update, "virtualExecUsage", "xsd:string", basic2str(_obj.virtualExecUsage), context, "4.0");
	update_member_with_version(update, "virtualMmuUsage", "xsd:string", basic2str(_obj.virtualMmuUsage), context, "2.5");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineFlagInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineFloppyInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineFloppyInfo", context);
	update("Base", "VirtualMachineTargetInfo", context);
	VirtualMachineTargetInfo_closure(dynamic_cast<const vw1__VirtualMachineTargetInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineFloppyInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineGuestSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineGuestSummary", context);
	update_member(update, "guestFullName", "xsd:string", basic2str(_obj.guestFullName), context);
	update_member(update, "guestId", "xsd:string", basic2str(_obj.guestId), context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update_member_with_version(update, "toolsRunningStatus", "xsd:string", basic2str(_obj.toolsRunningStatus), context, "4.0");
	update_member(update, "toolsStatus", "VirtualMachineToolsStatus", handle_obj_ptr(_obj.toolsStatus), context);
	update_member_with_version(update, "toolsVersionStatus", "xsd:string", basic2str(_obj.toolsVersionStatus), context, "4.0");
	update_member_with_version(update, "toolsVersionStatus2", "xsd:string", basic2str(_obj.toolsVersionStatus2), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineGuestSummary_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineIdeDiskDeviceInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineIdeDiskDeviceInfo", context);
	update_member(update, "partitionTable", "VirtualMachineIdeDiskDevicePartitionInfo[]", a2s_object(_obj.partitionTable, _obj.__sizepartitionTable), context);
	update("Base", "VirtualMachineDiskDeviceInfo", context);
	VirtualMachineDiskDeviceInfo_closure(dynamic_cast<const vw1__VirtualMachineDiskDeviceInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineIdeDiskDeviceInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizepartitionTable)
				return new VirtualMachineIdeDiskDevicePartitionInfo_closure(*_obj.partitionTable[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VirtualMachineDiskDeviceInfo_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineIdeDiskDevicePartitionInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineIdeDiskDevicePartitionInfo", context);
	update_member(update, "capacity", "xsd:int", basic2str(_obj.capacity), context);
	update_member(update, "id", "xsd:int", basic2str(_obj.id), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineIdeDiskDevicePartitionInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineImportSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineImportSpec", context);
	update_member(update, "configSpec", "VirtualMachineConfigSpec", handle_obj_ptr(_obj.configSpec), context);
	update_member_with_version(update, "resPoolEntity", "ResourcePool", handle_obj_ptr(_obj.resPoolEntity), context, "4.1");
	update("Base", "ImportSpec", context);
	ImportSpec_closure(dynamic_cast<const vw1__ImportSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineImportSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.configSpec)
			return new VirtualMachineConfigSpec_closure(*_obj.configSpec);
		else
			return 0;
	case 1:
		return _obj.resPoolEntity? 
			get_closure_from_mor(ResourcePool(_obj.resPoolEntity)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return ImportSpec_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineLegacyNetworkSwitchInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineLegacyNetworkSwitchInfo", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineLegacyNetworkSwitchInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineMemoryReservationInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineMemoryReservationInfo", context);
	update_member(update, "allocationPolicy", "xsd:string", basic2str(_obj.allocationPolicy), context);
	update_member(update, "virtualMachineMax", "xsd:long", basic2str(_obj.virtualMachineMax), context);
	update_member(update, "virtualMachineMin", "xsd:long", basic2str(_obj.virtualMachineMin), context);
	update_member(update, "virtualMachineReserved", "xsd:long", basic2str(_obj.virtualMachineReserved), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineMemoryReservationInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineMemoryReservationSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineMemoryReservationSpec", context);
	update_member(update, "allocationPolicy", "xsd:string", basic2str(_obj.allocationPolicy), context);
	update_member(update, "virtualMachineReserved", "xsd:long", basic2str(_obj.virtualMachineReserved), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineMemoryReservationSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineMessage_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineMessage", context);
	update_member(update, "argument", "xsd:anyType[]", a2s_basic(_obj.argument, _obj.__sizeargument), context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member_with_version(update, "text", "xsd:string", basic2str(_obj.text), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineMessage_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineMksTicket_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineMksTicket", context);
	update_member(update, "cfgFile", "xsd:string", basic2str(_obj.cfgFile), context);
	update_member(update, "host", "xsd:string", basic2str(_obj.host), context);
	update_member(update, "port", "xsd:int", basic2str(_obj.port), context);
	update_member_with_version(update, "sslThumbprint", "xsd:string", basic2str(_obj.sslThumbprint), context, "2.5");
	update_member(update, "ticket", "xsd:string", basic2str(_obj.ticket), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineMksTicket_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineNetworkInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineNetworkInfo", context);
	update_member(update, "network", "NetworkSummary", handle_obj_ptr(_obj.network), context);
	update("Base", "VirtualMachineTargetInfo", context);
	VirtualMachineTargetInfo_closure(dynamic_cast<const vw1__VirtualMachineTargetInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineNetworkInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.network)
			return new NetworkSummary_closure(*_obj.network);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualMachineTargetInfo_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineNetworkShaperInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineNetworkShaperInfo", context);
	update_member(update, "averageBps", "xsd:long", basic2str(_obj.averageBps), context);
	update_member(update, "burstSize", "xsd:long", basic2str(_obj.burstSize), context);
	update_member(update, "enabled", "xsd:boolean", basic2str(_obj.enabled), context);
	update_member(update, "peakBps", "xsd:long", basic2str(_obj.peakBps), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineNetworkShaperInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineParallelInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineParallelInfo", context);
	update("Base", "VirtualMachineTargetInfo", context);
	VirtualMachineTargetInfo_closure(dynamic_cast<const vw1__VirtualMachineTargetInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineParallelInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachinePciPassthroughInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachinePciPassthroughInfo", context);
	update_member(update, "pciDevice", "HostPciDevice", handle_obj_ptr(_obj.pciDevice), context);
	update_member(update, "systemId", "xsd:string", basic2str(_obj.systemId), context);
	update("Base", "VirtualMachineTargetInfo", context);
	VirtualMachineTargetInfo_closure(dynamic_cast<const vw1__VirtualMachineTargetInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachinePciPassthroughInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.pciDevice)
			return new HostPciDevice_closure(*_obj.pciDevice);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualMachineTargetInfo_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineQuestionInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineQuestionInfo", context);
	update_member(update, "choice", "ChoiceOption", handle_obj_ptr(_obj.choice), context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member_with_version(update, "message", "VirtualMachineMessage[]", a2s_object(_obj.message, _obj.__sizemessage), context, "2.5");
	update_member(update, "text", "xsd:string", basic2str(_obj.text), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineQuestionInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.choice)
			return new ChoiceOption_closure(*_obj.choice);
		else
			return 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemessage)
				return new VirtualMachineMessage_closure(*_obj.message[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineQuickStats_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineQuickStats", context);
	update_member_with_version(update, "balloonedMemory", "xsd:int", basic2str(_obj.balloonedMemory), context, "4.0");
	update_member_with_version(update, "compressedMemory", "xsd:long", basic2str(_obj.compressedMemory), context, "4.1");
	update_member_with_version(update, "consumedOverheadMemory", "xsd:int", basic2str(_obj.consumedOverheadMemory), context, "4.0");
	update_member(update, "distributedCpuEntitlement", "xsd:int", basic2str(_obj.distributedCpuEntitlement), context);
	update_member(update, "distributedMemoryEntitlement", "xsd:int", basic2str(_obj.distributedMemoryEntitlement), context);
	update_member_with_version(update, "ftLatencyStatus", "ManagedEntityStatus", handle_obj_ptr(_obj.ftLatencyStatus), context, "4.0");
	update_member_with_version(update, "ftLogBandwidth", "xsd:int", basic2str(_obj.ftLogBandwidth), context, "4.0");
	update_member_with_version(update, "ftSecondaryLatency", "xsd:int", basic2str(_obj.ftSecondaryLatency), context, "4.0");
	update_member(update, "guestHeartbeatStatus", "ManagedEntityStatus", handle_obj(_obj.guestHeartbeatStatus), context);
	update_member(update, "guestMemoryUsage", "xsd:int", basic2str(_obj.guestMemoryUsage), context);
	update_member(update, "hostMemoryUsage", "xsd:int", basic2str(_obj.hostMemoryUsage), context);
	update_member_with_version(update, "overallCpuDemand", "xsd:int", basic2str(_obj.overallCpuDemand), context, "4.0");
	update_member(update, "overallCpuUsage", "xsd:int", basic2str(_obj.overallCpuUsage), context);
	update_member_with_version(update, "privateMemory", "xsd:int", basic2str(_obj.privateMemory), context, "4.0");
	update_member_with_version(update, "sharedMemory", "xsd:int", basic2str(_obj.sharedMemory), context, "4.0");
	update_member_with_version(update, "ssdSwappedMemory", "xsd:long", basic2str(_obj.ssdSwappedMemory), context, "5.0");
	update_member_with_version(update, "staticCpuEntitlement", "xsd:int", basic2str(_obj.staticCpuEntitlement), context, "4.0");
	update_member_with_version(update, "staticMemoryEntitlement", "xsd:int", basic2str(_obj.staticMemoryEntitlement), context, "4.0");
	update_member_with_version(update, "swappedMemory", "xsd:int", basic2str(_obj.swappedMemory), context, "4.0");
	update_member_with_version(update, "uptimeSeconds", "xsd:int", basic2str(_obj.uptimeSeconds), context, "4.1");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineQuickStats_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineRelocateSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineRelocateSpec", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "disk", "VirtualMachineRelocateSpecDiskLocator[]", a2s_object(_obj.disk, _obj.__sizedisk), context);
	update_member_with_version(update, "diskMoveType", "xsd:string", basic2str(_obj.diskMoveType), context, "4.0");
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "pool", "ResourcePool", handle_obj_ptr(_obj.pool), context);
	update_member(update, "transform", "VirtualMachineRelocateTransformation", handle_obj_ptr(_obj.transform), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineRelocateSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedisk)
				return new VirtualMachineRelocateSpecDiskLocator_closure(*_obj.disk[i]);
			else
				return 0;
		}
	case 3:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	case 4:
		return _obj.pool? 
			get_closure_from_mor(ResourcePool(_obj.pool)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineRelocateSpecDiskLocator_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineRelocateSpecDiskLocator", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member_with_version(update, "diskBackingInfo", "VirtualDeviceBackingInfo", handle_obj_ptr(_obj.diskBackingInfo), context, "5.0");
	update_member(update, "diskId", "xsd:int", basic2str(_obj.diskId), context);
	update_member_with_version(update, "diskMoveType", "xsd:string", basic2str(_obj.diskMoveType), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineRelocateSpecDiskLocator_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	case 1:
		if (_obj.diskBackingInfo)
			return new VirtualDeviceBackingInfo_closure(*_obj.diskBackingInfo);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineRuntimeInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineRuntimeInfo", context);
	update_member(update, "bootTime", "xsd:dateTime", basic2str(_obj.bootTime), context);
	update_member_with_version(update, "cleanPowerOff", "xsd:boolean", basic2str(_obj.cleanPowerOff), context, "4.0");
	update_member(update, "connectionState", "VirtualMachineConnectionState", handle_obj(_obj.connectionState), context);
	update_member_with_version(update, "consolidationNeeded", "xsd:boolean", basic2str(_obj.consolidationNeeded), context, "5.0");
	update_member_with_version(update, "dasVmProtection", "VirtualMachineRuntimeInfoDasProtectionState", handle_obj_ptr(_obj.dasVmProtection), context, "5.0");
	update_member_with_version(update, "device", "VirtualMachineDeviceRuntimeInfo[]", a2s_object(_obj.device, _obj.__sizedevice), context, "4.1");
	update_member_with_version(update, "faultToleranceState", "VirtualMachineFaultToleranceState", handle_obj_ptr(_obj.faultToleranceState), context, "4.0");
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "maxCpuUsage", "xsd:int", basic2str(_obj.maxCpuUsage), context);
	update_member(update, "maxMemoryUsage", "xsd:int", basic2str(_obj.maxMemoryUsage), context);
	update_member(update, "memoryOverhead", "xsd:long", basic2str(_obj.memoryOverhead), context);
	update_member_with_version(update, "minRequiredEVCModeKey", "xsd:string", basic2str(_obj.minRequiredEVCModeKey), context, "4.1");
	update_member_with_version(update, "needSecondaryReason", "xsd:string", basic2str(_obj.needSecondaryReason), context, "4.0");
	update_member(update, "numMksConnections", "xsd:int", basic2str(_obj.numMksConnections), context);
	update_member(update, "powerState", "VirtualMachinePowerState", handle_obj(_obj.powerState), context);
	update_member(update, "question", "VirtualMachineQuestionInfo", handle_obj_ptr(_obj.question), context);
	update_member_with_version(update, "recordReplayState", "VirtualMachineRecordReplayState", handle_obj_ptr(_obj.recordReplayState), context, "4.0");
	update_member(update, "suspendInterval", "xsd:long", basic2str(_obj.suspendInterval), context);
	update_member(update, "suspendTime", "xsd:dateTime", basic2str(_obj.suspendTime), context);
	update_member(update, "toolsInstallerMounted", "xsd:boolean", basic2str(_obj.toolsInstallerMounted), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineRuntimeInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 4:
		if (_obj.dasVmProtection)
			return new VirtualMachineRuntimeInfoDasProtectionState_closure(*_obj.dasVmProtection);
		else
			return 0;
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedevice)
				return new VirtualMachineDeviceRuntimeInfo_closure(*_obj.device[i]);
			else
				return 0;
		}
	case 7:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	case 15:
		if (_obj.question)
			return new VirtualMachineQuestionInfo_closure(*_obj.question);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 20) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineRuntimeInfoDasProtectionState_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineRuntimeInfoDasProtectionState", context);
	update_member(update, "dasProtected", "xsd:boolean", basic2str(_obj.dasProtected), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineRuntimeInfoDasProtectionState_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineScsiDiskDeviceInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineScsiDiskDeviceInfo", context);
	update_member(update, "disk", "HostScsiDisk", handle_obj_ptr(_obj.disk), context);
	update_member_with_version(update, "lunNumber", "xsd:int", basic2str(_obj.lunNumber), context, "4.0");
	update_member_with_version(update, "transportHint", "xsd:string", basic2str(_obj.transportHint), context, "4.0");
	update("Base", "VirtualMachineDiskDeviceInfo", context);
	VirtualMachineDiskDeviceInfo_closure(dynamic_cast<const vw1__VirtualMachineDiskDeviceInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineScsiDiskDeviceInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.disk)
			return new HostScsiDisk_closure(*_obj.disk);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualMachineDiskDeviceInfo_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineScsiPassthroughInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineScsiPassthroughInfo", context);
	update_member(update, "physicalUnitNumber", "xsd:int", basic2str(_obj.physicalUnitNumber), context);
	update_member(update, "scsiClass", "xsd:string", basic2str(_obj.scsiClass), context);
	update_member(update, "vendor", "xsd:string", basic2str(_obj.vendor), context);
	update("Base", "VirtualMachineTargetInfo", context);
	VirtualMachineTargetInfo_closure(dynamic_cast<const vw1__VirtualMachineTargetInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineScsiPassthroughInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineSerialInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineSerialInfo", context);
	update("Base", "VirtualMachineTargetInfo", context);
	VirtualMachineTargetInfo_closure(dynamic_cast<const vw1__VirtualMachineTargetInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineSerialInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineSnapshotInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineSnapshotInfo", context);
	update_member(update, "currentSnapshot", "VirtualMachineSnapshot", handle_obj_ptr(_obj.currentSnapshot), context);
	update_member(update, "rootSnapshotList", "VirtualMachineSnapshotTree[]", a2s_object(_obj.rootSnapshotList, _obj.__sizerootSnapshotList), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineSnapshotInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.currentSnapshot? 
			get_closure_from_mor(VirtualMachineSnapshot(_obj.currentSnapshot)) : 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizerootSnapshotList)
				return new VirtualMachineSnapshotTree_closure(*_obj.rootSnapshotList[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineSnapshotTree_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineSnapshotTree", context);
	update_member_with_version(update, "backupManifest", "xsd:string", basic2str(_obj.backupManifest), context, "4.0");
	update_member(update, "childSnapshotList", "VirtualMachineSnapshotTree[]", a2s_object(_obj.childSnapshotList, _obj.__sizechildSnapshotList), context);
	update_member(update, "createTime", "xsd:dateTime", basic2str(_obj.createTime), context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member_with_version(update, "id", "xsd:int", basic2str(_obj.id), context, "4.0");
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "quiesced", "xsd:boolean", basic2str(_obj.quiesced), context);
	update_member_with_version(update, "replaySupported", "xsd:boolean", basic2str(_obj.replaySupported), context, "4.0");
	update_member(update, "snapshot", "VirtualMachineSnapshot", handle_obj_ptr(_obj.snapshot), context);
	update_member(update, "state", "VirtualMachinePowerState", handle_obj(_obj.state), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineSnapshotTree_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizechildSnapshotList)
				return new VirtualMachineSnapshotTree_closure(*_obj.childSnapshotList[i]);
			else
				return 0;
		}
	case 8:
		return _obj.snapshot? 
			get_closure_from_mor(VirtualMachineSnapshot(_obj.snapshot)) : 0;
	case 10:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 11) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineSoundInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineSoundInfo", context);
	update("Base", "VirtualMachineTargetInfo", context);
	VirtualMachineTargetInfo_closure(dynamic_cast<const vw1__VirtualMachineTargetInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineSoundInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineStorageInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineStorageInfo", context);
	update_member(update, "perDatastoreUsage", "VirtualMachineUsageOnDatastore[]", a2s_object(_obj.perDatastoreUsage, _obj.__sizeperDatastoreUsage), context);
	update_member(update, "timestamp", "xsd:dateTime", basic2str(_obj.timestamp), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineStorageInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeperDatastoreUsage)
				return new VirtualMachineUsageOnDatastore_closure(*_obj.perDatastoreUsage[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineStorageSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineStorageSummary", context);
	update_member(update, "committed", "xsd:long", basic2str(_obj.committed), context);
	update_member(update, "timestamp", "xsd:dateTime", basic2str(_obj.timestamp), context);
	update_member(update, "uncommitted", "xsd:long", basic2str(_obj.uncommitted), context);
	update_member(update, "unshared", "xsd:long", basic2str(_obj.unshared), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineStorageSummary_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineSummary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineSummary", context);
	update_member(update, "config", "VirtualMachineConfigSummary", handle_obj_ptr(_obj.config), context);
	update_member(update, "customValue", "CustomFieldValue[]", a2s_object(_obj.customValue, _obj.__sizecustomValue), context);
	update_member(update, "guest", "VirtualMachineGuestSummary", handle_obj_ptr(_obj.guest), context);
	update_member(update, "overallStatus", "ManagedEntityStatus", handle_obj(_obj.overallStatus), context);
	update_member(update, "quickStats", "VirtualMachineQuickStats", handle_obj_ptr(_obj.quickStats), context);
	update_member(update, "runtime", "VirtualMachineRuntimeInfo", handle_obj_ptr(_obj.runtime), context);
	update_member_with_version(update, "storage", "VirtualMachineStorageSummary", handle_obj_ptr(_obj.storage), context, "4.0");
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineSummary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.config)
			return new VirtualMachineConfigSummary_closure(*_obj.config);
		else
			return 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecustomValue)
				return new CustomFieldValue_closure(*_obj.customValue[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.guest)
			return new VirtualMachineGuestSummary_closure(*_obj.guest);
		else
			return 0;
	case 4:
		if (_obj.quickStats)
			return new VirtualMachineQuickStats_closure(*_obj.quickStats);
		else
			return 0;
	case 5:
		if (_obj.runtime)
			return new VirtualMachineRuntimeInfo_closure(*_obj.runtime);
		else
			return 0;
	case 6:
		if (_obj.storage)
			return new VirtualMachineStorageSummary_closure(*_obj.storage);
		else
			return 0;
	case 7:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineTargetInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineTargetInfo", context);
	update_member(update, "configurationTag", "xsd:string[]", a2s_basic(*_obj.configurationTag, _obj.__sizeconfigurationTag), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineTargetInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineTicket_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineTicket", context);
	update_member(update, "cfgFile", "xsd:string", basic2str(_obj.cfgFile), context);
	update_member(update, "host", "xsd:string", basic2str(_obj.host), context);
	update_member(update, "port", "xsd:int", basic2str(_obj.port), context);
	update_member(update, "sslThumbprint", "xsd:string", basic2str(_obj.sslThumbprint), context);
	update_member(update, "ticket", "xsd:string", basic2str(_obj.ticket), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineTicket_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineUsageOnDatastore_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineUsageOnDatastore", context);
	update_member(update, "committed", "xsd:long", basic2str(_obj.committed), context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "uncommitted", "xsd:long", basic2str(_obj.uncommitted), context);
	update_member(update, "unshared", "xsd:long", basic2str(_obj.unshared), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineUsageOnDatastore_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineUsbInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineUsbInfo", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "family", "xsd:string[]", a2s_basic(*_obj.family, _obj.__sizefamily), context);
	update_member(update, "physicalPath", "xsd:string", basic2str(_obj.physicalPath), context);
	update_member(update, "product", "xsd:int", basic2str(_obj.product), context);
	update_member(update, "speed", "xsd:string[]", a2s_basic(*_obj.speed, _obj.__sizespeed), context);
	update_member(update, "summary", "VirtualMachineSummary", handle_obj_ptr(_obj.summary), context);
	update_member(update, "vendor", "xsd:int", basic2str(_obj.vendor), context);
	update("Base", "VirtualMachineTargetInfo", context);
	VirtualMachineTargetInfo_closure(dynamic_cast<const vw1__VirtualMachineTargetInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineUsbInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 5:
		if (_obj.summary)
			return new VirtualMachineSummary_closure(*_obj.summary);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualMachineTargetInfo_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineVMCIDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineVMCIDevice", context);
	update_member(update, "allowUnrestrictedCommunication", "xsd:boolean", basic2str(_obj.allowUnrestrictedCommunication), context);
	update_member(update, "id", "xsd:long", basic2str(_obj.id), context);
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineVMCIDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineVMCIDeviceOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineVMCIDeviceOption", context);
	update_member(update, "allowUnrestrictedCommunication", "BoolOption", handle_obj_ptr(_obj.allowUnrestrictedCommunication), context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineVMCIDeviceOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.allowUnrestrictedCommunication)
			return new BoolOption_closure(*_obj.allowUnrestrictedCommunication);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceOption_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineVMIROM_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineVMIROM", context);
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineVMIROM_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualMachineVideoCard_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineVideoCard", context);
	update_member_with_version(update, "enable3DSupport", "xsd:boolean", basic2str(_obj.enable3DSupport), context, "4.0");
	update_member_with_version(update, "numDisplays", "xsd:int", basic2str(_obj.numDisplays), context, "4.0");
	update_member_with_version(update, "useAutoDetect", "xsd:boolean", basic2str(_obj.useAutoDetect), context, "4.0");
	update_member(update, "videoRamSizeInKB", "xsd:long", basic2str(_obj.videoRamSizeInKB), context);
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineVideoCard_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualNicManagerNetConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualNicManagerNetConfig", context);
	update_member(update, "candidateVnic", "HostVirtualNic[]", a2s_object(_obj.candidateVnic, _obj.__sizecandidateVnic), context);
	update_member(update, "multiSelectAllowed", "xsd:boolean", basic2str(_obj.multiSelectAllowed), context);
	update_member(update, "nicType", "xsd:string", basic2str(_obj.nicType), context);
	update_member(update, "selectedVnic", "xsd:string[]", a2s_basic(*_obj.selectedVnic, _obj.__sizeselectedVnic), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualNicManagerNetConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizecandidateVnic)
				return new HostVirtualNic_closure(*_obj.candidateVnic[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VirtualPCIController_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualPCIController", context);
	update("Base", "VirtualController", context);
	VirtualController_closure(dynamic_cast<const vw1__VirtualController&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualPCIController_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualPCIControllerOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualPCIControllerOption", context);
	update_member(update, "numEthernetCards", "IntOption", handle_obj_ptr(_obj.numEthernetCards), context);
	update_member_with_version(update, "numParaVirtualSCSIControllers", "IntOption", handle_obj_ptr(_obj.numParaVirtualSCSIControllers), context, "4.0");
	update_member_with_version(update, "numPCIPassthroughDevices", "IntOption", handle_obj_ptr(_obj.numPCIPassthroughDevices), context, "4.0");
	update_member_with_version(update, "numSasSCSIControllers", "IntOption", handle_obj_ptr(_obj.numSasSCSIControllers), context, "4.0");
	update_member(update, "numSCSIControllers", "IntOption", handle_obj_ptr(_obj.numSCSIControllers), context);
	update_member(update, "numSoundCards", "IntOption", handle_obj_ptr(_obj.numSoundCards), context);
	update_member(update, "numVideoCards", "IntOption", handle_obj_ptr(_obj.numVideoCards), context);
	update_member_with_version(update, "numVmciDevices", "IntOption", handle_obj_ptr(_obj.numVmciDevices), context, "4.0");
	update_member_with_version(update, "numVmiRoms", "IntOption", handle_obj_ptr(_obj.numVmiRoms), context, "2.5");
	update_member_with_version(update, "numVmxnet3EthernetCards", "IntOption", handle_obj_ptr(_obj.numVmxnet3EthernetCards), context, "4.0");
	update("Base", "VirtualControllerOption", context);
	VirtualControllerOption_closure(dynamic_cast<const vw1__VirtualControllerOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualPCIControllerOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.numEthernetCards)
			return new IntOption_closure(*_obj.numEthernetCards);
		else
			return 0;
	case 1:
		if (_obj.numParaVirtualSCSIControllers)
			return new IntOption_closure(*_obj.numParaVirtualSCSIControllers);
		else
			return 0;
	case 2:
		if (_obj.numPCIPassthroughDevices)
			return new IntOption_closure(*_obj.numPCIPassthroughDevices);
		else
			return 0;
	case 3:
		if (_obj.numSasSCSIControllers)
			return new IntOption_closure(*_obj.numSasSCSIControllers);
		else
			return 0;
	case 4:
		if (_obj.numSCSIControllers)
			return new IntOption_closure(*_obj.numSCSIControllers);
		else
			return 0;
	case 5:
		if (_obj.numSoundCards)
			return new IntOption_closure(*_obj.numSoundCards);
		else
			return 0;
	case 6:
		if (_obj.numVideoCards)
			return new IntOption_closure(*_obj.numVideoCards);
		else
			return 0;
	case 7:
		if (_obj.numVmciDevices)
			return new IntOption_closure(*_obj.numVmciDevices);
		else
			return 0;
	case 8:
		if (_obj.numVmiRoms)
			return new IntOption_closure(*_obj.numVmiRoms);
		else
			return 0;
	case 9:
		if (_obj.numVmxnet3EthernetCards)
			return new IntOption_closure(*_obj.numVmxnet3EthernetCards);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualControllerOption_closure(_obj).get_sub_closure(((prop_index - 10) << 16) + arr_index);
	}
	return 0;
}

void VirtualPCIPassthrough_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualPCIPassthrough", context);
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualPCIPassthrough_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualPCIPassthroughDeviceBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualPCIPassthroughDeviceBackingInfo", context);
	update_member(update, "deviceId", "xsd:string", basic2str(_obj.deviceId), context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "systemId", "xsd:string", basic2str(_obj.systemId), context);
	update_member(update, "vendorId", "xsd:short", basic2str(_obj.vendorId), context);
	update("Base", "VirtualDeviceDeviceBackingInfo", context);
	VirtualDeviceDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualPCIPassthroughDeviceBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualPCIPassthroughDeviceBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualPCIPassthroughDeviceBackingOption", context);
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualPCIPassthroughDeviceBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualPCIPassthroughOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualPCIPassthroughOption", context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualPCIPassthroughOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualPCNet32_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualPCNet32", context);
	update("Base", "VirtualEthernetCard", context);
	VirtualEthernetCard_closure(dynamic_cast<const vw1__VirtualEthernetCard&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualPCNet32_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualPCNet32Option_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualPCNet32Option", context);
	update_member(update, "supportsMorphing", "xsd:boolean", basic2str(_obj.supportsMorphing), context);
	update("Base", "VirtualEthernetCardOption", context);
	VirtualEthernetCardOption_closure(dynamic_cast<const vw1__VirtualEthernetCardOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualPCNet32Option_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualPS2Controller_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualPS2Controller", context);
	update("Base", "VirtualController", context);
	VirtualController_closure(dynamic_cast<const vw1__VirtualController&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualPS2Controller_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualPS2ControllerOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualPS2ControllerOption", context);
	update_member(update, "numKeyboards", "IntOption", handle_obj_ptr(_obj.numKeyboards), context);
	update_member(update, "numPointingDevices", "IntOption", handle_obj_ptr(_obj.numPointingDevices), context);
	update("Base", "VirtualControllerOption", context);
	VirtualControllerOption_closure(dynamic_cast<const vw1__VirtualControllerOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualPS2ControllerOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.numKeyboards)
			return new IntOption_closure(*_obj.numKeyboards);
		else
			return 0;
	case 1:
		if (_obj.numPointingDevices)
			return new IntOption_closure(*_obj.numPointingDevices);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualControllerOption_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualParallelPort_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualParallelPort", context);
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualParallelPort_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualParallelPortDeviceBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualParallelPortDeviceBackingInfo", context);
	update("Base", "VirtualDeviceDeviceBackingInfo", context);
	VirtualDeviceDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualParallelPortDeviceBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualParallelPortDeviceBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualParallelPortDeviceBackingOption", context);
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualParallelPortDeviceBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualParallelPortFileBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualParallelPortFileBackingInfo", context);
	update("Base", "VirtualDeviceFileBackingInfo", context);
	VirtualDeviceFileBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualParallelPortFileBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualParallelPortFileBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualParallelPortFileBackingOption", context);
	update("Base", "VirtualDeviceFileBackingOption", context);
	VirtualDeviceFileBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualParallelPortFileBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualParallelPortOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualParallelPortOption", context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualParallelPortOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualPointingDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualPointingDevice", context);
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualPointingDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualPointingDeviceBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualPointingDeviceBackingOption", context);
	update_member(update, "hostPointingDevice", "ChoiceOption", handle_obj_ptr(_obj.hostPointingDevice), context);
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualPointingDeviceBackingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.hostPointingDevice)
			return new ChoiceOption_closure(*_obj.hostPointingDevice);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceDeviceBackingOption_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VirtualPointingDeviceDeviceBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualPointingDeviceDeviceBackingInfo", context);
	update_member(update, "hostPointingDevice", "xsd:string", basic2str(_obj.hostPointingDevice), context);
	update("Base", "VirtualDeviceDeviceBackingInfo", context);
	VirtualDeviceDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualPointingDeviceDeviceBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualPointingDeviceOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualPointingDeviceOption", context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualPointingDeviceOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSCSIController_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSCSIController", context);
	update_member(update, "hotAddRemove", "xsd:boolean", basic2str(_obj.hotAddRemove), context);
	update_member(update, "scsiCtlrUnitNumber", "xsd:int", basic2str(_obj.scsiCtlrUnitNumber), context);
	update_member(update, "sharedBus", "VirtualSCSISharing", handle_obj(_obj.sharedBus), context);
	update("Base", "VirtualController", context);
	VirtualController_closure(dynamic_cast<const vw1__VirtualController&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSCSIController_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSCSIControllerOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSCSIControllerOption", context);
	update_member(update, "defaultSharedIndex", "xsd:int", basic2str(_obj.defaultSharedIndex), context);
	update_member(update, "hotAddRemove", "BoolOption", handle_obj_ptr(_obj.hotAddRemove), context);
	update_member(update, "numSCSICdroms", "IntOption", handle_obj_ptr(_obj.numSCSICdroms), context);
	update_member(update, "numSCSIDisks", "IntOption", handle_obj_ptr(_obj.numSCSIDisks), context);
	update_member(update, "numSCSIPassthrough", "IntOption", handle_obj_ptr(_obj.numSCSIPassthrough), context);
	update_member(update, "scsiCtlrUnitNumber", "xsd:int", basic2str(_obj.scsiCtlrUnitNumber), context);
	update_member(update, "sharing", "VirtualSCSISharing[]", a2s_basic(_obj.sharing, _obj.__sizesharing), context);
	update("Base", "VirtualControllerOption", context);
	VirtualControllerOption_closure(dynamic_cast<const vw1__VirtualControllerOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSCSIControllerOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.hotAddRemove)
			return new BoolOption_closure(*_obj.hotAddRemove);
		else
			return 0;
	case 2:
		if (_obj.numSCSICdroms)
			return new IntOption_closure(*_obj.numSCSICdroms);
		else
			return 0;
	case 3:
		if (_obj.numSCSIDisks)
			return new IntOption_closure(*_obj.numSCSIDisks);
		else
			return 0;
	case 4:
		if (_obj.numSCSIPassthrough)
			return new IntOption_closure(*_obj.numSCSIPassthrough);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualControllerOption_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void VirtualSCSIPassthrough_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSCSIPassthrough", context);
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSCSIPassthrough_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSCSIPassthroughDeviceBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSCSIPassthroughDeviceBackingInfo", context);
	update("Base", "VirtualDeviceDeviceBackingInfo", context);
	VirtualDeviceDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSCSIPassthroughDeviceBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSCSIPassthroughDeviceBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSCSIPassthroughDeviceBackingOption", context);
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSCSIPassthroughDeviceBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSCSIPassthroughOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSCSIPassthroughOption", context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSCSIPassthroughOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSIOController_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSIOController", context);
	update("Base", "VirtualController", context);
	VirtualController_closure(dynamic_cast<const vw1__VirtualController&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSIOController_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSIOControllerOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSIOControllerOption", context);
	update_member(update, "numFloppyDrives", "IntOption", handle_obj_ptr(_obj.numFloppyDrives), context);
	update_member(update, "numParallelPorts", "IntOption", handle_obj_ptr(_obj.numParallelPorts), context);
	update_member(update, "numSerialPorts", "IntOption", handle_obj_ptr(_obj.numSerialPorts), context);
	update("Base", "VirtualControllerOption", context);
	VirtualControllerOption_closure(dynamic_cast<const vw1__VirtualControllerOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSIOControllerOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.numFloppyDrives)
			return new IntOption_closure(*_obj.numFloppyDrives);
		else
			return 0;
	case 1:
		if (_obj.numParallelPorts)
			return new IntOption_closure(*_obj.numParallelPorts);
		else
			return 0;
	case 2:
		if (_obj.numSerialPorts)
			return new IntOption_closure(*_obj.numSerialPorts);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualControllerOption_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VirtualSerialPort_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSerialPort", context);
	update_member(update, "yieldOnPoll", "xsd:boolean", basic2str(_obj.yieldOnPoll), context);
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSerialPort_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSerialPortDeviceBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSerialPortDeviceBackingInfo", context);
	update("Base", "VirtualDeviceDeviceBackingInfo", context);
	VirtualDeviceDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSerialPortDeviceBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSerialPortDeviceBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSerialPortDeviceBackingOption", context);
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSerialPortDeviceBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSerialPortFileBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSerialPortFileBackingInfo", context);
	update("Base", "VirtualDeviceFileBackingInfo", context);
	VirtualDeviceFileBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSerialPortFileBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSerialPortFileBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSerialPortFileBackingOption", context);
	update("Base", "VirtualDeviceFileBackingOption", context);
	VirtualDeviceFileBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceFileBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSerialPortFileBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSerialPortOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSerialPortOption", context);
	update_member(update, "yieldOnPoll", "BoolOption", handle_obj_ptr(_obj.yieldOnPoll), context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSerialPortOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.yieldOnPoll)
			return new BoolOption_closure(*_obj.yieldOnPoll);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceOption_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VirtualSerialPortPipeBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSerialPortPipeBackingInfo", context);
	update_member(update, "endpoint", "xsd:string", basic2str(_obj.endpoint), context);
	update_member(update, "noRxLoss", "xsd:boolean", basic2str(_obj.noRxLoss), context);
	update("Base", "VirtualDevicePipeBackingInfo", context);
	VirtualDevicePipeBackingInfo_closure(dynamic_cast<const vw1__VirtualDevicePipeBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSerialPortPipeBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSerialPortPipeBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSerialPortPipeBackingOption", context);
	update_member(update, "endpoint", "ChoiceOption", handle_obj_ptr(_obj.endpoint), context);
	update_member(update, "noRxLoss", "BoolOption", handle_obj_ptr(_obj.noRxLoss), context);
	update("Base", "VirtualDevicePipeBackingOption", context);
	VirtualDevicePipeBackingOption_closure(dynamic_cast<const vw1__VirtualDevicePipeBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSerialPortPipeBackingOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.endpoint)
			return new ChoiceOption_closure(*_obj.endpoint);
		else
			return 0;
	case 1:
		if (_obj.noRxLoss)
			return new BoolOption_closure(*_obj.noRxLoss);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDevicePipeBackingOption_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualSerialPortURIBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSerialPortURIBackingInfo", context);
	update("Base", "VirtualDeviceURIBackingInfo", context);
	VirtualDeviceURIBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceURIBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSerialPortURIBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSerialPortURIBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSerialPortURIBackingOption", context);
	update("Base", "VirtualDeviceURIBackingOption", context);
	VirtualDeviceURIBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceURIBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSerialPortURIBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSoundBlaster16_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSoundBlaster16", context);
	update("Base", "VirtualSoundCard", context);
	VirtualSoundCard_closure(dynamic_cast<const vw1__VirtualSoundCard&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSoundBlaster16_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSoundBlaster16Option_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSoundBlaster16Option", context);
	update("Base", "VirtualSoundCardOption", context);
	VirtualSoundCardOption_closure(dynamic_cast<const vw1__VirtualSoundCardOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSoundBlaster16Option_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSoundCard_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSoundCard", context);
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSoundCard_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSoundCardDeviceBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSoundCardDeviceBackingInfo", context);
	update("Base", "VirtualDeviceDeviceBackingInfo", context);
	VirtualDeviceDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSoundCardDeviceBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSoundCardDeviceBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSoundCardDeviceBackingOption", context);
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSoundCardDeviceBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSoundCardOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSoundCardOption", context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSoundCardOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualSwitchProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSwitchProfile", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update_member(update, "link", "LinkProfile", handle_obj_ptr(_obj.link), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "networkPolicy", "NetworkPolicyProfile", handle_obj_ptr(_obj.networkPolicy), context);
	update_member(update, "numPorts", "NumPortsProfile", handle_obj_ptr(_obj.numPorts), context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSwitchProfile_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.link)
			return new LinkProfile_closure(*_obj.link);
		else
			return 0;
	case 3:
		if (_obj.networkPolicy)
			return new NetworkPolicyProfile_closure(*_obj.networkPolicy);
		else
			return 0;
	case 4:
		if (_obj.numPorts)
			return new NumPortsProfile_closure(*_obj.numPorts);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return ApplyProfile_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void VirtualSwitchSelectionProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualSwitchSelectionProfile", context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualSwitchSelectionProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualUSB_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualUSB", context);
	update_member_with_version(update, "connected", "xsd:boolean", basic2str(_obj.connected), context, "2.5");
	update_member_with_version(update, "family", "xsd:string[]", a2s_basic(*_obj.family, _obj.__sizefamily), context, "4.1");
	update_member_with_version(update, "product", "xsd:int", basic2str(_obj.product), context, "4.1");
	update_member_with_version(update, "speed", "xsd:string[]", a2s_basic(*_obj.speed, _obj.__sizespeed), context, "4.1");
	update_member_with_version(update, "vendor", "xsd:int", basic2str(_obj.vendor), context, "4.1");
	update("Base", "VirtualDevice", context);
	VirtualDevice_closure(dynamic_cast<const vw1__VirtualDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualUSB_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualUSBController_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualUSBController", context);
	update_member(update, "autoConnectDevices", "xsd:boolean", basic2str(_obj.autoConnectDevices), context);
	update_member_with_version(update, "ehciEnabled", "xsd:boolean", basic2str(_obj.ehciEnabled), context, "2.5");
	update("Base", "VirtualController", context);
	VirtualController_closure(dynamic_cast<const vw1__VirtualController&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualUSBController_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualUSBControllerOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualUSBControllerOption", context);
	update_member(update, "autoConnectDevices", "BoolOption", handle_obj_ptr(_obj.autoConnectDevices), context);
	update_member_with_version(update, "ehciSupported", "BoolOption", handle_obj_ptr(_obj.ehciSupported), context, "2.5");
	update_member_with_version(update, "supportedSpeeds", "xsd:string[]", a2s_basic(*_obj.supportedSpeeds, _obj.__sizesupportedSpeeds), context, "5.0");
	update("Base", "VirtualControllerOption", context);
	VirtualControllerOption_closure(dynamic_cast<const vw1__VirtualControllerOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualUSBControllerOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.autoConnectDevices)
			return new BoolOption_closure(*_obj.autoConnectDevices);
		else
			return 0;
	case 1:
		if (_obj.ehciSupported)
			return new BoolOption_closure(*_obj.ehciSupported);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualControllerOption_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VirtualUSBOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualUSBOption", context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualUSBOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualUSBRemoteClientBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualUSBRemoteClientBackingInfo", context);
	update_member(update, "hostname", "xsd:string", basic2str(_obj.hostname), context);
	update("Base", "VirtualDeviceRemoteDeviceBackingInfo", context);
	VirtualDeviceRemoteDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceRemoteDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualUSBRemoteClientBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualUSBRemoteClientBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualUSBRemoteClientBackingOption", context);
	update("Base", "VirtualDeviceRemoteDeviceBackingOption", context);
	VirtualDeviceRemoteDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceRemoteDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualUSBRemoteClientBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualUSBRemoteHostBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualUSBRemoteHostBackingInfo", context);
	update_member(update, "hostname", "xsd:string", basic2str(_obj.hostname), context);
	update("Base", "VirtualDeviceDeviceBackingInfo", context);
	VirtualDeviceDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualUSBRemoteHostBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualUSBRemoteHostBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualUSBRemoteHostBackingOption", context);
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualUSBRemoteHostBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualUSBUSBBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualUSBUSBBackingInfo", context);
	update("Base", "VirtualDeviceDeviceBackingInfo", context);
	VirtualDeviceDeviceBackingInfo_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualUSBUSBBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualUSBUSBBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualUSBUSBBackingOption", context);
	update("Base", "VirtualDeviceDeviceBackingOption", context);
	VirtualDeviceDeviceBackingOption_closure(dynamic_cast<const vw1__VirtualDeviceDeviceBackingOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualUSBUSBBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualUSBXHCIController_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualUSBXHCIController", context);
	update_member(update, "autoConnectDevices", "xsd:boolean", basic2str(_obj.autoConnectDevices), context);
	update("Base", "VirtualController", context);
	VirtualController_closure(dynamic_cast<const vw1__VirtualController&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualUSBXHCIController_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualUSBXHCIControllerOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualUSBXHCIControllerOption", context);
	update_member(update, "autoConnectDevices", "BoolOption", handle_obj_ptr(_obj.autoConnectDevices), context);
	update_member(update, "supportedSpeeds", "xsd:string[]", a2s_basic(*_obj.supportedSpeeds, _obj.__sizesupportedSpeeds), context);
	update("Base", "VirtualControllerOption", context);
	VirtualControllerOption_closure(dynamic_cast<const vw1__VirtualControllerOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualUSBXHCIControllerOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.autoConnectDevices)
			return new BoolOption_closure(*_obj.autoConnectDevices);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualControllerOption_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualVMIROMOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualVMIROMOption", context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualVMIROMOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualVideoCardOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualVideoCardOption", context);
	update_member_with_version(update, "numDisplays", "IntOption", handle_obj_ptr(_obj.numDisplays), context, "4.0");
	update_member_with_version(update, "support3D", "BoolOption", handle_obj_ptr(_obj.support3D), context, "4.0");
	update_member_with_version(update, "useAutoDetect", "BoolOption", handle_obj_ptr(_obj.useAutoDetect), context, "4.0");
	update_member(update, "videoRamSizeInKB", "LongOption", handle_obj_ptr(_obj.videoRamSizeInKB), context);
	update("Base", "VirtualDeviceOption", context);
	VirtualDeviceOption_closure(dynamic_cast<const vw1__VirtualDeviceOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualVideoCardOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.numDisplays)
			return new IntOption_closure(*_obj.numDisplays);
		else
			return 0;
	case 1:
		if (_obj.support3D)
			return new BoolOption_closure(*_obj.support3D);
		else
			return 0;
	case 2:
		if (_obj.useAutoDetect)
			return new BoolOption_closure(*_obj.useAutoDetect);
		else
			return 0;
	case 3:
		if (_obj.videoRamSizeInKB)
			return new LongOption_closure(*_obj.videoRamSizeInKB);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualDeviceOption_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VirtualVmxnet_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualVmxnet", context);
	update("Base", "VirtualEthernetCard", context);
	VirtualEthernetCard_closure(dynamic_cast<const vw1__VirtualEthernetCard&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualVmxnet_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualVmxnet2_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualVmxnet2", context);
	update("Base", "VirtualVmxnet", context);
	VirtualVmxnet_closure(dynamic_cast<const vw1__VirtualVmxnet&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualVmxnet2_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualVmxnet2Option_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualVmxnet2Option", context);
	update("Base", "VirtualVmxnetOption", context);
	VirtualVmxnetOption_closure(dynamic_cast<const vw1__VirtualVmxnetOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualVmxnet2Option_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualVmxnet3_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualVmxnet3", context);
	update("Base", "VirtualVmxnet", context);
	VirtualVmxnet_closure(dynamic_cast<const vw1__VirtualVmxnet&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualVmxnet3_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualVmxnet3Option_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualVmxnet3Option", context);
	update("Base", "VirtualVmxnetOption", context);
	VirtualVmxnetOption_closure(dynamic_cast<const vw1__VirtualVmxnetOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualVmxnet3Option_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualVmxnetOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualVmxnetOption", context);
	update("Base", "VirtualEthernetCardOption", context);
	VirtualEthernetCardOption_closure(dynamic_cast<const vw1__VirtualEthernetCardOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualVmxnetOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VlanProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VlanProfile", context);
	update("Base", "ApplyProfile", context);
	ApplyProfile_closure(dynamic_cast<const vw1__ApplyProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VlanProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmAcquiredMksTicketEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmAcquiredMksTicketEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmAcquiredMksTicketEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmAcquiredTicketEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmAcquiredTicketEvent", context);
	update_member(update, "ticketType", "xsd:string", basic2str(_obj.ticketType), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmAcquiredTicketEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmAutoRenameEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmAutoRenameEvent", context);
	update_member(update, "newName", "xsd:string", basic2str(_obj.newName), context);
	update_member(update, "oldName", "xsd:string", basic2str(_obj.oldName), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmAutoRenameEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmBeingClonedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmBeingClonedEvent", context);
	update_member(update, "destFolder", "FolderEventArgument", handle_obj_ptr(_obj.destFolder), context);
	update_member(update, "destHost", "HostEventArgument", handle_obj_ptr(_obj.destHost), context);
	update_member(update, "destName", "xsd:string", basic2str(_obj.destName), context);
	update("Base", "VmCloneEvent", context);
	VmCloneEvent_closure(dynamic_cast<const vw1__VmCloneEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmBeingClonedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.destFolder)
			return new FolderEventArgument_closure(*_obj.destFolder);
		else
			return 0;
	case 1:
		if (_obj.destHost)
			return new HostEventArgument_closure(*_obj.destHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmCloneEvent_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VmBeingClonedNoFolderEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmBeingClonedNoFolderEvent", context);
	update_member(update, "destHost", "HostEventArgument", handle_obj_ptr(_obj.destHost), context);
	update_member(update, "destName", "xsd:string", basic2str(_obj.destName), context);
	update("Base", "VmCloneEvent", context);
	VmCloneEvent_closure(dynamic_cast<const vw1__VmCloneEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmBeingClonedNoFolderEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.destHost)
			return new HostEventArgument_closure(*_obj.destHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmCloneEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmBeingCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmBeingCreatedEvent", context);
	update_member(update, "configSpec", "VirtualMachineConfigSpec", handle_obj_ptr(_obj.configSpec), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmBeingCreatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.configSpec)
			return new VirtualMachineConfigSpec_closure(*_obj.configSpec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmBeingDeployedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmBeingDeployedEvent", context);
	update_member(update, "srcTemplate", "VmEventArgument", handle_obj_ptr(_obj.srcTemplate), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmBeingDeployedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.srcTemplate)
			return new VmEventArgument_closure(*_obj.srcTemplate);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmBeingHotMigratedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmBeingHotMigratedEvent", context);
	update_member_with_version(update, "destDatacenter", "DatacenterEventArgument", handle_obj_ptr(_obj.destDatacenter), context, "5.0");
	update_member_with_version(update, "destDatastore", "DatastoreEventArgument", handle_obj_ptr(_obj.destDatastore), context, "5.0");
	update_member(update, "destHost", "HostEventArgument", handle_obj_ptr(_obj.destHost), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmBeingHotMigratedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.destDatacenter)
			return new DatacenterEventArgument_closure(*_obj.destDatacenter);
		else
			return 0;
	case 1:
		if (_obj.destDatastore)
			return new DatastoreEventArgument_closure(*_obj.destDatastore);
		else
			return 0;
	case 2:
		if (_obj.destHost)
			return new HostEventArgument_closure(*_obj.destHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VmBeingMigratedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmBeingMigratedEvent", context);
	update_member_with_version(update, "destDatacenter", "DatacenterEventArgument", handle_obj_ptr(_obj.destDatacenter), context, "5.0");
	update_member_with_version(update, "destDatastore", "DatastoreEventArgument", handle_obj_ptr(_obj.destDatastore), context, "5.0");
	update_member(update, "destHost", "HostEventArgument", handle_obj_ptr(_obj.destHost), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmBeingMigratedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.destDatacenter)
			return new DatacenterEventArgument_closure(*_obj.destDatacenter);
		else
			return 0;
	case 1:
		if (_obj.destDatastore)
			return new DatastoreEventArgument_closure(*_obj.destDatastore);
		else
			return 0;
	case 2:
		if (_obj.destHost)
			return new HostEventArgument_closure(*_obj.destHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VmBeingRelocatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmBeingRelocatedEvent", context);
	update_member_with_version(update, "destDatacenter", "DatacenterEventArgument", handle_obj_ptr(_obj.destDatacenter), context, "5.0");
	update_member_with_version(update, "destDatastore", "DatastoreEventArgument", handle_obj_ptr(_obj.destDatastore), context, "5.0");
	update_member(update, "destHost", "HostEventArgument", handle_obj_ptr(_obj.destHost), context);
	update("Base", "VmRelocateSpecEvent", context);
	VmRelocateSpecEvent_closure(dynamic_cast<const vw1__VmRelocateSpecEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmBeingRelocatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.destDatacenter)
			return new DatacenterEventArgument_closure(*_obj.destDatacenter);
		else
			return 0;
	case 1:
		if (_obj.destDatastore)
			return new DatastoreEventArgument_closure(*_obj.destDatastore);
		else
			return 0;
	case 2:
		if (_obj.destHost)
			return new HostEventArgument_closure(*_obj.destHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmRelocateSpecEvent_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VmCloneEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmCloneEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmCloneEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmCloneFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmCloneFailedEvent", context);
	update_member(update, "destFolder", "FolderEventArgument", handle_obj_ptr(_obj.destFolder), context);
	update_member(update, "destHost", "HostEventArgument", handle_obj_ptr(_obj.destHost), context);
	update_member(update, "destName", "xsd:string", basic2str(_obj.destName), context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "VmCloneEvent", context);
	VmCloneEvent_closure(dynamic_cast<const vw1__VmCloneEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmCloneFailedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.destFolder)
			return new FolderEventArgument_closure(*_obj.destFolder);
		else
			return 0;
	case 1:
		if (_obj.destHost)
			return new HostEventArgument_closure(*_obj.destHost);
		else
			return 0;
	case 3:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmCloneEvent_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VmClonedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmClonedEvent", context);
	update_member(update, "sourceVm", "VmEventArgument", handle_obj_ptr(_obj.sourceVm), context);
	update("Base", "VmCloneEvent", context);
	VmCloneEvent_closure(dynamic_cast<const vw1__VmCloneEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmClonedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.sourceVm)
			return new VmEventArgument_closure(*_obj.sourceVm);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmCloneEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmConfigFileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmConfigFileInfo", context);
	update_member(update, "configVersion", "xsd:int", basic2str(_obj.configVersion), context);
	update("Base", "FileInfo", context);
	FileInfo_closure(dynamic_cast<const vw1__FileInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmConfigFileInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmConfigFileQuery_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmConfigFileQuery", context);
	update_member(update, "details", "VmConfigFileQueryFlags", handle_obj_ptr(_obj.details), context);
	update_member(update, "filter", "VmConfigFileQueryFilter", handle_obj_ptr(_obj.filter), context);
	update("Base", "FileQuery", context);
	FileQuery_closure(dynamic_cast<const vw1__FileQuery&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmConfigFileQuery_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.details)
			return new VmConfigFileQueryFlags_closure(*_obj.details);
		else
			return 0;
	case 1:
		if (_obj.filter)
			return new VmConfigFileQueryFilter_closure(*_obj.filter);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return FileQuery_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmConfigFileQueryFilter_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmConfigFileQueryFilter", context);
	update_member(update, "matchConfigVersion", "xsd:int[]", a2s_basic(_obj.matchConfigVersion, _obj.__sizematchConfigVersion), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmConfigFileQueryFilter_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmConfigFileQueryFlags_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmConfigFileQueryFlags", context);
	update_member(update, "configVersion", "xsd:boolean", basic2str(_obj.configVersion), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmConfigFileQueryFlags_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmConfigInfo", context);
	update_member(update, "eula", "xsd:string[]", a2s_basic(*_obj.eula, _obj.__sizeeula), context);
	update_member(update, "installBootRequired", "xsd:boolean", basic2str(_obj.installBootRequired), context);
	update_member(update, "installBootStopDelay", "xsd:int", basic2str(_obj.installBootStopDelay), context);
	update_member(update, "ipAssignment", "VAppIPAssignmentInfo", handle_obj_ptr(_obj.ipAssignment), context);
	update_member(update, "ovfEnvironmentTransport", "xsd:string[]", a2s_basic(*_obj.ovfEnvironmentTransport, _obj.__sizeovfEnvironmentTransport), context);
	update_member(update, "ovfSection", "VAppOvfSectionInfo[]", a2s_object(_obj.ovfSection, _obj.__sizeovfSection), context);
	update_member(update, "product", "VAppProductInfo[]", a2s_object(_obj.product, _obj.__sizeproduct), context);
	update_member(update, "property", "VAppPropertyInfo[]", a2s_object(_obj.property, _obj.__sizeproperty), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmConfigInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		if (_obj.ipAssignment)
			return new VAppIPAssignmentInfo_closure(*_obj.ipAssignment);
		else
			return 0;
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeovfSection)
				return new VAppOvfSectionInfo_closure(*_obj.ovfSection[i]);
			else
				return 0;
		}
	case 6:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeproduct)
				return new VAppProductInfo_closure(*_obj.product[i]);
			else
				return 0;
		}
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeproperty)
				return new VAppPropertyInfo_closure(*_obj.property[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void VmConfigMissingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmConfigMissingEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmConfigMissingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmConfigSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmConfigSpec", context);
	update_member(update, "eula", "xsd:string[]", a2s_basic(*_obj.eula, _obj.__sizeeula), context);
	update_member(update, "installBootRequired", "xsd:boolean", basic2str(_obj.installBootRequired), context);
	update_member(update, "installBootStopDelay", "xsd:int", basic2str(_obj.installBootStopDelay), context);
	update_member(update, "ipAssignment", "VAppIPAssignmentInfo", handle_obj_ptr(_obj.ipAssignment), context);
	update_member(update, "ovfEnvironmentTransport", "xsd:string[]", a2s_basic(*_obj.ovfEnvironmentTransport, _obj.__sizeovfEnvironmentTransport), context);
	update_member(update, "ovfSection", "VAppOvfSectionSpec[]", a2s_object(_obj.ovfSection, _obj.__sizeovfSection), context);
	update_member(update, "product", "VAppProductSpec[]", a2s_object(_obj.product, _obj.__sizeproduct), context);
	update_member(update, "property", "VAppPropertySpec[]", a2s_object(_obj.property, _obj.__sizeproperty), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmConfigSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		if (_obj.ipAssignment)
			return new VAppIPAssignmentInfo_closure(*_obj.ipAssignment);
		else
			return 0;
	case 5:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeovfSection)
				return new VAppOvfSectionSpec_closure(*_obj.ovfSection[i]);
			else
				return 0;
		}
	case 6:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeproduct)
				return new VAppProductSpec_closure(*_obj.product[i]);
			else
				return 0;
		}
	case 7:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeproperty)
				return new VAppPropertySpec_closure(*_obj.property[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 8) << 16) + arr_index);
	}
	return 0;
}

void VmConnectedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmConnectedEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmConnectedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmCreatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmCreatedEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmCreatedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmDasBeingResetEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDasBeingResetEvent", context);
	update_member_with_version(update, "reason", "xsd:string", basic2str(_obj.reason), context, "4.1");
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDasBeingResetEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmDasBeingResetWithScreenshotEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDasBeingResetWithScreenshotEvent", context);
	update_member(update, "screenshotFilePath", "xsd:string", basic2str(_obj.screenshotFilePath), context);
	update("Base", "VmDasBeingResetEvent", context);
	VmDasBeingResetEvent_closure(dynamic_cast<const vw1__VmDasBeingResetEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDasBeingResetWithScreenshotEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmDasResetFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDasResetFailedEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDasResetFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmDasUpdateErrorEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDasUpdateErrorEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDasUpdateErrorEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmDasUpdateOkEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDasUpdateOkEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDasUpdateOkEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmDateRolledBackEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDateRolledBackEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDateRolledBackEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmDeployFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDeployFailedEvent", context);
	update_member(update, "destDatastore", "EntityEventArgument", handle_obj_ptr(_obj.destDatastore), context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDeployFailedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.destDatastore)
			return new EntityEventArgument_closure(*_obj.destDatastore);
		else
			return 0;
	case 1:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmDeployedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDeployedEvent", context);
	update_member(update, "srcTemplate", "VmEventArgument", handle_obj_ptr(_obj.srcTemplate), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDeployedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.srcTemplate)
			return new VmEventArgument_closure(*_obj.srcTemplate);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmDisconnectedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDisconnectedEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDisconnectedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmDiscoveredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDiscoveredEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDiscoveredEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmDiskFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDiskFailedEvent", context);
	update_member(update, "disk", "xsd:string", basic2str(_obj.disk), context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDiskFailedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmDiskFileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDiskFileInfo", context);
	update_member(update, "capacityKb", "xsd:long", basic2str(_obj.capacityKb), context);
	update_member_with_version(update, "controllerType", "xsd:string", basic2str(_obj.controllerType), context, "2.5");
	update_member_with_version(update, "diskExtents", "xsd:string[]", a2s_basic(*_obj.diskExtents, _obj.__sizediskExtents), context, "2.5");
	update_member(update, "diskType", "xsd:string", basic2str(_obj.diskType), context);
	update_member(update, "hardwareVersion", "xsd:int", basic2str(_obj.hardwareVersion), context);
	update_member_with_version(update, "thin", "xsd:boolean", basic2str(_obj.thin), context, "4.0");
	update("Base", "FileInfo", context);
	FileInfo_closure(dynamic_cast<const vw1__FileInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDiskFileInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmDiskFileQuery_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDiskFileQuery", context);
	update_member(update, "details", "VmDiskFileQueryFlags", handle_obj_ptr(_obj.details), context);
	update_member(update, "filter", "VmDiskFileQueryFilter", handle_obj_ptr(_obj.filter), context);
	update("Base", "FileQuery", context);
	FileQuery_closure(dynamic_cast<const vw1__FileQuery&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDiskFileQuery_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.details)
			return new VmDiskFileQueryFlags_closure(*_obj.details);
		else
			return 0;
	case 1:
		if (_obj.filter)
			return new VmDiskFileQueryFilter_closure(*_obj.filter);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return FileQuery_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmDiskFileQueryFilter_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDiskFileQueryFilter", context);
	update_member_with_version(update, "controllerType", "xsd:string[]", a2s_basic(*_obj.controllerType, _obj.__sizecontrollerType), context, "2.5");
	update_member(update, "diskType", "xsd:string[]", a2s_basic(*_obj.diskType, _obj.__sizediskType), context);
	update_member(update, "matchHardwareVersion", "xsd:int[]", a2s_basic(_obj.matchHardwareVersion, _obj.__sizematchHardwareVersion), context);
	update_member_with_version(update, "thin", "xsd:boolean", basic2str(_obj.thin), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDiskFileQueryFilter_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmDiskFileQueryFlags_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmDiskFileQueryFlags", context);
	update_member(update, "capacityKb", "xsd:boolean", basic2str(_obj.capacityKb), context);
	update_member_with_version(update, "controllerType", "xsd:boolean", basic2str(_obj.controllerType), context, "2.5");
	update_member_with_version(update, "diskExtents", "xsd:boolean", basic2str(_obj.diskExtents), context, "2.5");
	update_member(update, "diskType", "xsd:boolean", basic2str(_obj.diskType), context);
	update_member(update, "hardwareVersion", "xsd:boolean", basic2str(_obj.hardwareVersion), context);
	update_member_with_version(update, "thin", "xsd:boolean", basic2str(_obj.thin), context, "4.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmDiskFileQueryFlags_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmEmigratingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmEmigratingEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmEmigratingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmEndRecordingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmEndRecordingEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmEndRecordingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmEndReplayingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmEndReplayingEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmEndReplayingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmEvent", context);
	update_member(update, "template_", "xsd:boolean", basic2str(_obj.template_), context);
	update("Base", "Event", context);
	Event_closure(dynamic_cast<const vw1__Event&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmEventArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmEventArgument", context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "EntityEventArgument", context);
	EntityEventArgument_closure(dynamic_cast<const vw1__EntityEventArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmEventArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return EntityEventArgument_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmFailedMigrateEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFailedMigrateEvent", context);
	update_member_with_version(update, "destDatacenter", "DatacenterEventArgument", handle_obj_ptr(_obj.destDatacenter), context, "5.0");
	update_member_with_version(update, "destDatastore", "DatastoreEventArgument", handle_obj_ptr(_obj.destDatastore), context, "5.0");
	update_member(update, "destHost", "HostEventArgument", handle_obj_ptr(_obj.destHost), context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFailedMigrateEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.destDatacenter)
			return new DatacenterEventArgument_closure(*_obj.destDatacenter);
		else
			return 0;
	case 1:
		if (_obj.destDatastore)
			return new DatastoreEventArgument_closure(*_obj.destDatastore);
		else
			return 0;
	case 2:
		if (_obj.destHost)
			return new HostEventArgument_closure(*_obj.destHost);
		else
			return 0;
	case 3:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VmFailedRelayoutEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFailedRelayoutEvent", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFailedRelayoutEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmFailedRelayoutOnVmfs2DatastoreEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFailedRelayoutOnVmfs2DatastoreEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFailedRelayoutOnVmfs2DatastoreEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmFailedStartingSecondaryEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFailedStartingSecondaryEvent", context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFailedStartingSecondaryEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmFailedToPowerOffEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFailedToPowerOffEvent", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFailedToPowerOffEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmFailedToPowerOnEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFailedToPowerOnEvent", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFailedToPowerOnEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmFailedToRebootGuestEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFailedToRebootGuestEvent", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFailedToRebootGuestEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmFailedToResetEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFailedToResetEvent", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFailedToResetEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmFailedToShutdownGuestEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFailedToShutdownGuestEvent", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFailedToShutdownGuestEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmFailedToStandbyGuestEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFailedToStandbyGuestEvent", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFailedToStandbyGuestEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmFailedToSuspendEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFailedToSuspendEvent", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFailedToSuspendEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmFailedUpdatingSecondaryConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFailedUpdatingSecondaryConfig", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFailedUpdatingSecondaryConfig_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmFailoverFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFailoverFailed", context);
	update_member_with_version(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context, "4.1");
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFailoverFailed_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmFaultToleranceStateChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFaultToleranceStateChangedEvent", context);
	update_member(update, "newState", "VirtualMachineFaultToleranceState", handle_obj(_obj.newState), context);
	update_member(update, "oldState", "VirtualMachineFaultToleranceState", handle_obj(_obj.oldState), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFaultToleranceStateChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmFaultToleranceTurnedOffEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFaultToleranceTurnedOffEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFaultToleranceTurnedOffEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmFaultToleranceVmTerminatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFaultToleranceVmTerminatedEvent", context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFaultToleranceVmTerminatedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmGuestRebootEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmGuestRebootEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmGuestRebootEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmGuestShutdownEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmGuestShutdownEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmGuestShutdownEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmGuestStandbyEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmGuestStandbyEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmGuestStandbyEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmHealthMonitoringStateChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmHealthMonitoringStateChangedEvent", context);
	update_member(update, "state", "xsd:string", basic2str(_obj.state), context);
	update("Base", "ClusterEvent", context);
	ClusterEvent_closure(dynamic_cast<const vw1__ClusterEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmHealthMonitoringStateChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmInstanceUuidAssignedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmInstanceUuidAssignedEvent", context);
	update_member(update, "instanceUuid", "xsd:string", basic2str(_obj.instanceUuid), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmInstanceUuidAssignedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmInstanceUuidChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmInstanceUuidChangedEvent", context);
	update_member(update, "newInstanceUuid", "xsd:string", basic2str(_obj.newInstanceUuid), context);
	update_member(update, "oldInstanceUuid", "xsd:string", basic2str(_obj.oldInstanceUuid), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmInstanceUuidChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmInstanceUuidConflictEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmInstanceUuidConflictEvent", context);
	update_member(update, "conflictedVm", "VmEventArgument", handle_obj_ptr(_obj.conflictedVm), context);
	update_member(update, "instanceUuid", "xsd:string", basic2str(_obj.instanceUuid), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmInstanceUuidConflictEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.conflictedVm)
			return new VmEventArgument_closure(*_obj.conflictedVm);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmLogFileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmLogFileInfo", context);
	update("Base", "FileInfo", context);
	FileInfo_closure(dynamic_cast<const vw1__FileInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmLogFileInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmLogFileQuery_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmLogFileQuery", context);
	update("Base", "FileQuery", context);
	FileQuery_closure(dynamic_cast<const vw1__FileQuery&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmLogFileQuery_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmMacAssignedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmMacAssignedEvent", context);
	update_member(update, "adapter", "xsd:string", basic2str(_obj.adapter), context);
	update_member(update, "mac", "xsd:string", basic2str(_obj.mac), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmMacAssignedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmMacChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmMacChangedEvent", context);
	update_member(update, "adapter", "xsd:string", basic2str(_obj.adapter), context);
	update_member(update, "newMac", "xsd:string", basic2str(_obj.newMac), context);
	update_member(update, "oldMac", "xsd:string", basic2str(_obj.oldMac), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmMacChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmMacConflictEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmMacConflictEvent", context);
	update_member(update, "conflictedVm", "VmEventArgument", handle_obj_ptr(_obj.conflictedVm), context);
	update_member(update, "mac", "xsd:string", basic2str(_obj.mac), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmMacConflictEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.conflictedVm)
			return new VmEventArgument_closure(*_obj.conflictedVm);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmMaxFTRestartCountReached_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmMaxFTRestartCountReached", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmMaxFTRestartCountReached_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmMaxRestartCountReached_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmMaxRestartCountReached", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmMaxRestartCountReached_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmMessageErrorEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmMessageErrorEvent", context);
	update_member(update, "message", "xsd:string", basic2str(_obj.message), context);
	update_member(update, "messageInfo", "VirtualMachineMessage[]", a2s_object(_obj.messageInfo, _obj.__sizemessageInfo), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmMessageErrorEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemessageInfo)
				return new VirtualMachineMessage_closure(*_obj.messageInfo[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmMessageEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmMessageEvent", context);
	update_member(update, "message", "xsd:string", basic2str(_obj.message), context);
	update_member_with_version(update, "messageInfo", "VirtualMachineMessage[]", a2s_object(_obj.messageInfo, _obj.__sizemessageInfo), context, "2.5");
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmMessageEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemessageInfo)
				return new VirtualMachineMessage_closure(*_obj.messageInfo[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmMessageWarningEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmMessageWarningEvent", context);
	update_member(update, "message", "xsd:string", basic2str(_obj.message), context);
	update_member(update, "messageInfo", "VirtualMachineMessage[]", a2s_object(_obj.messageInfo, _obj.__sizemessageInfo), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmMessageWarningEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizemessageInfo)
				return new VirtualMachineMessage_closure(*_obj.messageInfo[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmMigratedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmMigratedEvent", context);
	update_member_with_version(update, "sourceDatacenter", "DatacenterEventArgument", handle_obj_ptr(_obj.sourceDatacenter), context, "5.0");
	update_member_with_version(update, "sourceDatastore", "DatastoreEventArgument", handle_obj_ptr(_obj.sourceDatastore), context, "5.0");
	update_member(update, "sourceHost", "HostEventArgument", handle_obj_ptr(_obj.sourceHost), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmMigratedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.sourceDatacenter)
			return new DatacenterEventArgument_closure(*_obj.sourceDatacenter);
		else
			return 0;
	case 1:
		if (_obj.sourceDatastore)
			return new DatastoreEventArgument_closure(*_obj.sourceDatastore);
		else
			return 0;
	case 2:
		if (_obj.sourceHost)
			return new HostEventArgument_closure(*_obj.sourceHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VmNoCompatibleHostForSecondaryEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmNoCompatibleHostForSecondaryEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmNoCompatibleHostForSecondaryEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmNoNetworkAccessEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmNoNetworkAccessEvent", context);
	update_member(update, "destHost", "HostEventArgument", handle_obj_ptr(_obj.destHost), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmNoNetworkAccessEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.destHost)
			return new HostEventArgument_closure(*_obj.destHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmNvramFileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmNvramFileInfo", context);
	update("Base", "FileInfo", context);
	FileInfo_closure(dynamic_cast<const vw1__FileInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmNvramFileInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmNvramFileQuery_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmNvramFileQuery", context);
	update("Base", "FileQuery", context);
	FileQuery_closure(dynamic_cast<const vw1__FileQuery&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmNvramFileQuery_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmOrphanedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmOrphanedEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmOrphanedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmPodConfigForPlacement_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmPodConfigForPlacement", context);
	update_member(update, "disk", "PodDiskLocator[]", a2s_object(_obj.disk, _obj.__sizedisk), context);
	update_member(update, "interVmRule", "ClusterRuleInfo[]", a2s_object(_obj.interVmRule, _obj.__sizeinterVmRule), context);
	update_member(update, "storagePod", "StoragePod", handle_obj_ptr(_obj.storagePod), context);
	update_member(update, "vmConfig", "StorageDrsVmConfigInfo", handle_obj_ptr(_obj.vmConfig), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmPodConfigForPlacement_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedisk)
				return new PodDiskLocator_closure(*_obj.disk[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeinterVmRule)
				return new ClusterRuleInfo_closure(*_obj.interVmRule[i]);
			else
				return 0;
		}
	case 2:
		return _obj.storagePod? 
			get_closure_from_mor(StoragePod(_obj.storagePod)) : 0;
	case 3:
		if (_obj.vmConfig)
			return new StorageDrsVmConfigInfo_closure(*_obj.vmConfig);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VmPortGroupProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmPortGroupProfile", context);
	update("Base", "PortGroupProfile", context);
	PortGroupProfile_closure(dynamic_cast<const vw1__PortGroupProfile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmPortGroupProfile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmPowerOffOnIsolationEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmPowerOffOnIsolationEvent", context);
	update_member(update, "isolatedHost", "HostEventArgument", handle_obj_ptr(_obj.isolatedHost), context);
	update("Base", "VmPoweredOffEvent", context);
	VmPoweredOffEvent_closure(dynamic_cast<const vw1__VmPoweredOffEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmPowerOffOnIsolationEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.isolatedHost)
			return new HostEventArgument_closure(*_obj.isolatedHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmPoweredOffEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmPoweredOffEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmPoweredOffEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmPoweredOffEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmPoweredOnEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmPoweredOnEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmPoweredOnEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmPoweringOnWithCustomizedDVPortEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmPoweringOnWithCustomizedDVPortEvent", context);
	update_member(update, "vnic", "VnicPortArgument[]", a2s_object(_obj.vnic, _obj.__sizevnic), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmPoweringOnWithCustomizedDVPortEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevnic)
				return new VnicPortArgument_closure(*_obj.vnic[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmPrimaryFailoverEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmPrimaryFailoverEvent", context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmPrimaryFailoverEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmReconfiguredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmReconfiguredEvent", context);
	update_member(update, "configSpec", "VirtualMachineConfigSpec", handle_obj_ptr(_obj.configSpec), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmReconfiguredEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.configSpec)
			return new VirtualMachineConfigSpec_closure(*_obj.configSpec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmRegisteredEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmRegisteredEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmRegisteredEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmRelayoutSuccessfulEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmRelayoutSuccessfulEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmRelayoutSuccessfulEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmRelayoutUpToDateEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmRelayoutUpToDateEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmRelayoutUpToDateEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmReloadFromPathEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmReloadFromPathEvent", context);
	update_member(update, "configPath", "xsd:string", basic2str(_obj.configPath), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmReloadFromPathEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmReloadFromPathFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmReloadFromPathFailedEvent", context);
	update_member(update, "configPath", "xsd:string", basic2str(_obj.configPath), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmReloadFromPathFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmRelocateFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmRelocateFailedEvent", context);
	update_member_with_version(update, "destDatacenter", "DatacenterEventArgument", handle_obj_ptr(_obj.destDatacenter), context, "5.0");
	update_member_with_version(update, "destDatastore", "DatastoreEventArgument", handle_obj_ptr(_obj.destDatastore), context, "5.0");
	update_member(update, "destHost", "HostEventArgument", handle_obj_ptr(_obj.destHost), context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "VmRelocateSpecEvent", context);
	VmRelocateSpecEvent_closure(dynamic_cast<const vw1__VmRelocateSpecEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmRelocateFailedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.destDatacenter)
			return new DatacenterEventArgument_closure(*_obj.destDatacenter);
		else
			return 0;
	case 1:
		if (_obj.destDatastore)
			return new DatastoreEventArgument_closure(*_obj.destDatastore);
		else
			return 0;
	case 2:
		if (_obj.destHost)
			return new HostEventArgument_closure(*_obj.destHost);
		else
			return 0;
	case 3:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmRelocateSpecEvent_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VmRelocateSpecEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmRelocateSpecEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmRelocateSpecEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmRelocatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmRelocatedEvent", context);
	update_member_with_version(update, "sourceDatacenter", "DatacenterEventArgument", handle_obj_ptr(_obj.sourceDatacenter), context, "5.0");
	update_member_with_version(update, "sourceDatastore", "DatastoreEventArgument", handle_obj_ptr(_obj.sourceDatastore), context, "5.0");
	update_member(update, "sourceHost", "HostEventArgument", handle_obj_ptr(_obj.sourceHost), context);
	update("Base", "VmRelocateSpecEvent", context);
	VmRelocateSpecEvent_closure(dynamic_cast<const vw1__VmRelocateSpecEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmRelocatedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.sourceDatacenter)
			return new DatacenterEventArgument_closure(*_obj.sourceDatacenter);
		else
			return 0;
	case 1:
		if (_obj.sourceDatastore)
			return new DatastoreEventArgument_closure(*_obj.sourceDatastore);
		else
			return 0;
	case 2:
		if (_obj.sourceHost)
			return new HostEventArgument_closure(*_obj.sourceHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmRelocateSpecEvent_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VmRemoteConsoleConnectedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmRemoteConsoleConnectedEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmRemoteConsoleConnectedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmRemoteConsoleDisconnectedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmRemoteConsoleDisconnectedEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmRemoteConsoleDisconnectedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmRemovedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmRemovedEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmRemovedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmRenamedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmRenamedEvent", context);
	update_member(update, "newName", "xsd:string", basic2str(_obj.newName), context);
	update_member(update, "oldName", "xsd:string", basic2str(_obj.oldName), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmRenamedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmResettingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmResettingEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmResettingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmResourcePoolMovedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmResourcePoolMovedEvent", context);
	update_member(update, "newParent", "ResourcePoolEventArgument", handle_obj_ptr(_obj.newParent), context);
	update_member(update, "oldParent", "ResourcePoolEventArgument", handle_obj_ptr(_obj.oldParent), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmResourcePoolMovedEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.newParent)
			return new ResourcePoolEventArgument_closure(*_obj.newParent);
		else
			return 0;
	case 1:
		if (_obj.oldParent)
			return new ResourcePoolEventArgument_closure(*_obj.oldParent);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmResourceReallocatedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmResourceReallocatedEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmResourceReallocatedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmRestartedOnAlternateHostEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmRestartedOnAlternateHostEvent", context);
	update_member(update, "sourceHost", "HostEventArgument", handle_obj_ptr(_obj.sourceHost), context);
	update("Base", "VmPoweredOnEvent", context);
	VmPoweredOnEvent_closure(dynamic_cast<const vw1__VmPoweredOnEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmRestartedOnAlternateHostEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.sourceHost)
			return new HostEventArgument_closure(*_obj.sourceHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmPoweredOnEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmResumingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmResumingEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmResumingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmSecondaryAddedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmSecondaryAddedEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmSecondaryAddedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmSecondaryDisabledBySystemEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmSecondaryDisabledBySystemEvent", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmSecondaryDisabledBySystemEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmSecondaryDisabledEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmSecondaryDisabledEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmSecondaryDisabledEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmSecondaryEnabledEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmSecondaryEnabledEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmSecondaryEnabledEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmSecondaryStartedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmSecondaryStartedEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmSecondaryStartedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmShutdownOnIsolationEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmShutdownOnIsolationEvent", context);
	update_member(update, "isolatedHost", "HostEventArgument", handle_obj_ptr(_obj.isolatedHost), context);
	update_member(update, "shutdownResult", "xsd:string", basic2str(_obj.shutdownResult), context);
	update("Base", "VmPoweredOffEvent", context);
	VmPoweredOffEvent_closure(dynamic_cast<const vw1__VmPoweredOffEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmShutdownOnIsolationEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.isolatedHost)
			return new HostEventArgument_closure(*_obj.isolatedHost);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmPoweredOffEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmSnapshotFileInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmSnapshotFileInfo", context);
	update("Base", "FileInfo", context);
	FileInfo_closure(dynamic_cast<const vw1__FileInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmSnapshotFileInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmSnapshotFileQuery_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmSnapshotFileQuery", context);
	update("Base", "FileQuery", context);
	FileQuery_closure(dynamic_cast<const vw1__FileQuery&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmSnapshotFileQuery_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmStartRecordingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmStartRecordingEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmStartRecordingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmStartReplayingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmStartReplayingEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmStartReplayingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmStartingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmStartingEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmStartingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmStartingSecondaryEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmStartingSecondaryEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmStartingSecondaryEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmStaticMacConflictEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmStaticMacConflictEvent", context);
	update_member(update, "conflictedVm", "VmEventArgument", handle_obj_ptr(_obj.conflictedVm), context);
	update_member(update, "mac", "xsd:string", basic2str(_obj.mac), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmStaticMacConflictEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.conflictedVm)
			return new VmEventArgument_closure(*_obj.conflictedVm);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmStoppingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmStoppingEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmStoppingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmSuspendedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmSuspendedEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmSuspendedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmSuspendingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmSuspendingEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmSuspendingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmTimedoutStartingSecondaryEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmTimedoutStartingSecondaryEvent", context);
	update_member(update, "timeout", "xsd:long", basic2str(_obj.timeout), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmTimedoutStartingSecondaryEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmUnsupportedStartingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmUnsupportedStartingEvent", context);
	update_member(update, "guestId", "xsd:string", basic2str(_obj.guestId), context);
	update("Base", "VmStartingEvent", context);
	VmStartingEvent_closure(dynamic_cast<const vw1__VmStartingEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmUnsupportedStartingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmUpgradeCompleteEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmUpgradeCompleteEvent", context);
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmUpgradeCompleteEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmUpgradeFailedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmUpgradeFailedEvent", context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmUpgradeFailedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmUpgradingEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmUpgradingEvent", context);
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmUpgradingEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmUuidAssignedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmUuidAssignedEvent", context);
	update_member(update, "uuid", "xsd:string", basic2str(_obj.uuid), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmUuidAssignedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmUuidChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmUuidChangedEvent", context);
	update_member(update, "newUuid", "xsd:string", basic2str(_obj.newUuid), context);
	update_member(update, "oldUuid", "xsd:string", basic2str(_obj.oldUuid), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmUuidChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmUuidConflictEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmUuidConflictEvent", context);
	update_member(update, "conflictedVm", "VmEventArgument", handle_obj_ptr(_obj.conflictedVm), context);
	update_member(update, "uuid", "xsd:string", basic2str(_obj.uuid), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmUuidConflictEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.conflictedVm)
			return new VmEventArgument_closure(*_obj.conflictedVm);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmWwnAssignedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmWwnAssignedEvent", context);
	update_member(update, "nodeWwns", "xsd:long[]", a2s_basic(_obj.nodeWwns, _obj.__sizenodeWwns), context);
	update_member(update, "portWwns", "xsd:long[]", a2s_basic(_obj.portWwns, _obj.__sizeportWwns), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmWwnAssignedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmWwnChangedEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmWwnChangedEvent", context);
	update_member(update, "newNodeWwns", "xsd:long[]", a2s_basic(_obj.newNodeWwns, _obj.__sizenewNodeWwns), context);
	update_member(update, "newPortWwns", "xsd:long[]", a2s_basic(_obj.newPortWwns, _obj.__sizenewPortWwns), context);
	update_member(update, "oldNodeWwns", "xsd:long[]", a2s_basic(_obj.oldNodeWwns, _obj.__sizeoldNodeWwns), context);
	update_member(update, "oldPortWwns", "xsd:long[]", a2s_basic(_obj.oldPortWwns, _obj.__sizeoldPortWwns), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmWwnChangedEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmWwnConflictEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmWwnConflictEvent", context);
	update_member(update, "conflictedHosts", "HostEventArgument[]", a2s_object(_obj.conflictedHosts, _obj.__sizeconflictedHosts), context);
	update_member(update, "conflictedVms", "VmEventArgument[]", a2s_object(_obj.conflictedVms, _obj.__sizeconflictedVms), context);
	update_member(update, "wwn", "xsd:long", basic2str(_obj.wwn), context);
	update("Base", "VmEvent", context);
	VmEvent_closure(dynamic_cast<const vw1__VmEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmWwnConflictEvent_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeconflictedHosts)
				return new HostEventArgument_closure(*_obj.conflictedHosts[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeconflictedVms)
				return new VmEventArgument_closure(*_obj.conflictedVms[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VmEvent_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VmfsDatastoreAllExtentOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmfsDatastoreAllExtentOption", context);
	update("Base", "VmfsDatastoreSingleExtentOption", context);
	VmfsDatastoreSingleExtentOption_closure(dynamic_cast<const vw1__VmfsDatastoreSingleExtentOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmfsDatastoreAllExtentOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmfsDatastoreBaseOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmfsDatastoreBaseOption", context);
	update_member(update, "layout", "HostDiskPartitionLayout", handle_obj_ptr(_obj.layout), context);
	update_member_with_version(update, "partitionFormatChange", "xsd:boolean", basic2str(_obj.partitionFormatChange), context, "5.0");
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmfsDatastoreBaseOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.layout)
			return new HostDiskPartitionLayout_closure(*_obj.layout);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmfsDatastoreCreateSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmfsDatastoreCreateSpec", context);
	update_member(update, "extent", "HostScsiDiskPartition[]", a2s_object(_obj.extent, _obj.__sizeextent), context);
	update_member(update, "partition", "HostDiskPartitionSpec", handle_obj_ptr(_obj.partition), context);
	update_member(update, "vmfs", "HostVmfsSpec", handle_obj_ptr(_obj.vmfs), context);
	update("Base", "VmfsDatastoreSpec", context);
	VmfsDatastoreSpec_closure(dynamic_cast<const vw1__VmfsDatastoreSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmfsDatastoreCreateSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeextent)
				return new HostScsiDiskPartition_closure(*_obj.extent[i]);
			else
				return 0;
		}
	case 1:
		if (_obj.partition)
			return new HostDiskPartitionSpec_closure(*_obj.partition);
		else
			return 0;
	case 2:
		if (_obj.vmfs)
			return new HostVmfsSpec_closure(*_obj.vmfs);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmfsDatastoreSpec_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VmfsDatastoreExpandSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmfsDatastoreExpandSpec", context);
	update_member(update, "extent", "HostScsiDiskPartition", handle_obj_ptr(_obj.extent), context);
	update_member(update, "partition", "HostDiskPartitionSpec", handle_obj_ptr(_obj.partition), context);
	update("Base", "VmfsDatastoreSpec", context);
	VmfsDatastoreSpec_closure(dynamic_cast<const vw1__VmfsDatastoreSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmfsDatastoreExpandSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.extent)
			return new HostScsiDiskPartition_closure(*_obj.extent);
		else
			return 0;
	case 1:
		if (_obj.partition)
			return new HostDiskPartitionSpec_closure(*_obj.partition);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmfsDatastoreSpec_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmfsDatastoreExtendSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmfsDatastoreExtendSpec", context);
	update_member(update, "extent", "HostScsiDiskPartition[]", a2s_object(_obj.extent, _obj.__sizeextent), context);
	update_member(update, "partition", "HostDiskPartitionSpec", handle_obj_ptr(_obj.partition), context);
	update("Base", "VmfsDatastoreSpec", context);
	VmfsDatastoreSpec_closure(dynamic_cast<const vw1__VmfsDatastoreSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmfsDatastoreExtendSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeextent)
				return new HostScsiDiskPartition_closure(*_obj.extent[i]);
			else
				return 0;
		}
	case 1:
		if (_obj.partition)
			return new HostDiskPartitionSpec_closure(*_obj.partition);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmfsDatastoreSpec_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmfsDatastoreInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmfsDatastoreInfo", context);
	update_member(update, "vmfs", "HostVmfsVolume", handle_obj_ptr(_obj.vmfs), context);
	update("Base", "DatastoreInfo", context);
	DatastoreInfo_closure(dynamic_cast<const vw1__DatastoreInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmfsDatastoreInfo_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.vmfs)
			return new HostVmfsVolume_closure(*_obj.vmfs);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DatastoreInfo_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmfsDatastoreMultipleExtentOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmfsDatastoreMultipleExtentOption", context);
	update_member(update, "vmfsExtent", "HostDiskPartitionBlockRange[]", a2s_object(_obj.vmfsExtent, _obj.__sizevmfsExtent), context);
	update("Base", "VmfsDatastoreBaseOption", context);
	VmfsDatastoreBaseOption_closure(dynamic_cast<const vw1__VmfsDatastoreBaseOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmfsDatastoreMultipleExtentOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevmfsExtent)
				return new HostDiskPartitionBlockRange_closure(*_obj.vmfsExtent[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VmfsDatastoreBaseOption_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmfsDatastoreOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmfsDatastoreOption", context);
	update_member(update, "info", "VmfsDatastoreBaseOption", handle_obj_ptr(_obj.info), context);
	update_member(update, "spec", "VmfsDatastoreSpec", handle_obj_ptr(_obj.spec), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmfsDatastoreOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.info)
			return new VmfsDatastoreBaseOption_closure(*_obj.info);
		else
			return 0;
	case 1:
		if (_obj.spec)
			return new VmfsDatastoreSpec_closure(*_obj.spec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmfsDatastoreSingleExtentOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmfsDatastoreSingleExtentOption", context);
	update_member(update, "vmfsExtent", "HostDiskPartitionBlockRange", handle_obj_ptr(_obj.vmfsExtent), context);
	update("Base", "VmfsDatastoreBaseOption", context);
	VmfsDatastoreBaseOption_closure(dynamic_cast<const vw1__VmfsDatastoreBaseOption&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmfsDatastoreSingleExtentOption_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.vmfsExtent)
			return new HostDiskPartitionBlockRange_closure(*_obj.vmfsExtent);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmfsDatastoreBaseOption_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmfsDatastoreSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmfsDatastoreSpec", context);
	update_member(update, "diskUuid", "xsd:string", basic2str(_obj.diskUuid), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmfsDatastoreSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmwareDistributedVirtualSwitchPvlanSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmwareDistributedVirtualSwitchPvlanSpec", context);
	update_member(update, "pvlanId", "xsd:int", basic2str(_obj.pvlanId), context);
	update("Base", "VmwareDistributedVirtualSwitchVlanSpec", context);
	VmwareDistributedVirtualSwitchVlanSpec_closure(dynamic_cast<const vw1__VmwareDistributedVirtualSwitchVlanSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmwareDistributedVirtualSwitchPvlanSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmwareDistributedVirtualSwitchTrunkVlanSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmwareDistributedVirtualSwitchTrunkVlanSpec", context);
	update_member(update, "vlanId", "NumericRange[]", a2s_object(_obj.vlanId, _obj.__sizevlanId), context);
	update("Base", "VmwareDistributedVirtualSwitchVlanSpec", context);
	VmwareDistributedVirtualSwitchVlanSpec_closure(dynamic_cast<const vw1__VmwareDistributedVirtualSwitchVlanSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmwareDistributedVirtualSwitchTrunkVlanSpec_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevlanId)
				return new NumericRange_closure(*_obj.vlanId[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VmwareDistributedVirtualSwitchVlanSpec_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmwareDistributedVirtualSwitchVlanIdSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmwareDistributedVirtualSwitchVlanIdSpec", context);
	update_member(update, "vlanId", "xsd:int", basic2str(_obj.vlanId), context);
	update("Base", "VmwareDistributedVirtualSwitchVlanSpec", context);
	VmwareDistributedVirtualSwitchVlanSpec_closure(dynamic_cast<const vw1__VmwareDistributedVirtualSwitchVlanSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmwareDistributedVirtualSwitchVlanIdSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmwareDistributedVirtualSwitchVlanSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmwareDistributedVirtualSwitchVlanSpec", context);
	update("Base", "InheritablePolicy", context);
	InheritablePolicy_closure(dynamic_cast<const vw1__InheritablePolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmwareDistributedVirtualSwitchVlanSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmwareUplinkPortTeamingPolicy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmwareUplinkPortTeamingPolicy", context);
	update_member(update, "failureCriteria", "DVSFailureCriteria", handle_obj_ptr(_obj.failureCriteria), context);
	update_member(update, "notifySwitches", "BoolPolicy", handle_obj_ptr(_obj.notifySwitches), context);
	update_member(update, "policy", "StringPolicy", handle_obj_ptr(_obj.policy), context);
	update_member(update, "reversePolicy", "BoolPolicy", handle_obj_ptr(_obj.reversePolicy), context);
	update_member(update, "rollingOrder", "BoolPolicy", handle_obj_ptr(_obj.rollingOrder), context);
	update_member(update, "uplinkPortOrder", "VMwareUplinkPortOrderPolicy", handle_obj_ptr(_obj.uplinkPortOrder), context);
	update("Base", "InheritablePolicy", context);
	InheritablePolicy_closure(dynamic_cast<const vw1__InheritablePolicy&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmwareUplinkPortTeamingPolicy_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.failureCriteria)
			return new DVSFailureCriteria_closure(*_obj.failureCriteria);
		else
			return 0;
	case 1:
		if (_obj.notifySwitches)
			return new BoolPolicy_closure(*_obj.notifySwitches);
		else
			return 0;
	case 2:
		if (_obj.policy)
			return new StringPolicy_closure(*_obj.policy);
		else
			return 0;
	case 3:
		if (_obj.reversePolicy)
			return new BoolPolicy_closure(*_obj.reversePolicy);
		else
			return 0;
	case 4:
		if (_obj.rollingOrder)
			return new BoolPolicy_closure(*_obj.rollingOrder);
		else
			return 0;
	case 5:
		if (_obj.uplinkPortOrder)
			return new VMwareUplinkPortOrderPolicy_closure(*_obj.uplinkPortOrder);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return InheritablePolicy_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void VnicPortArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VnicPortArgument", context);
	update_member(update, "port", "DistributedVirtualSwitchPortConnection", handle_obj_ptr(_obj.port), context);
	update_member(update, "vnic", "xsd:string", basic2str(_obj.vnic), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VnicPortArgument_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.port)
			return new DistributedVirtualSwitchPortConnection_closure(*_obj.port);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return DynamicData_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void WaitOptions_closure::browse(pf_update update, void* context) const
{
	update("Begin", "WaitOptions", context);
	update_member(update, "maxObjectUpdates", "xsd:int", basic2str(_obj.maxObjectUpdates), context);
	update_member(update, "maxWaitSeconds", "xsd:int", basic2str(_obj.maxWaitSeconds), context);
	update("Base", "DynamicData", context);
	DynamicData_closure(dynamic_cast<const vw1__DynamicData&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* WaitOptions_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void WarningUpgradeEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "WarningUpgradeEvent", context);
	update("Base", "UpgradeEvent", context);
	UpgradeEvent_closure(dynamic_cast<const vw1__UpgradeEvent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* WarningUpgradeEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void WeeklyTaskScheduler_closure::browse(pf_update update, void* context) const
{
	update("Begin", "WeeklyTaskScheduler", context);
	update_member(update, "friday", "xsd:boolean", basic2str(_obj.friday), context);
	update_member(update, "monday", "xsd:boolean", basic2str(_obj.monday), context);
	update_member(update, "saturday", "xsd:boolean", basic2str(_obj.saturday), context);
	update_member(update, "sunday", "xsd:boolean", basic2str(_obj.sunday), context);
	update_member(update, "thursday", "xsd:boolean", basic2str(_obj.thursday), context);
	update_member(update, "tuesday", "xsd:boolean", basic2str(_obj.tuesday), context);
	update_member(update, "wednesday", "xsd:boolean", basic2str(_obj.wednesday), context);
	update("Base", "DailyTaskScheduler", context);
	DailyTaskScheduler_closure(dynamic_cast<const vw1__DailyTaskScheduler&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* WeeklyTaskScheduler_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void WinNetBIOSConfigInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "WinNetBIOSConfigInfo", context);
	update_member(update, "primaryWINS", "xsd:string", basic2str(_obj.primaryWINS), context);
	update_member(update, "secondaryWINS", "xsd:string", basic2str(_obj.secondaryWINS), context);
	update("Base", "NetBIOSConfigInfo", context);
	NetBIOSConfigInfo_closure(dynamic_cast<const vw1__NetBIOSConfigInfo&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* WinNetBIOSConfigInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ActiveDirectoryFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ActiveDirectoryFault", context);
	update_member(update, "errorCode", "xsd:int", basic2str(_obj.errorCode), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ActiveDirectoryFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AdminDisabled_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AdminDisabled", context);
	update("Base", "HostConfigFault", context);
	HostConfigFault_closure(dynamic_cast<const vw1__HostConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AdminDisabled_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AdminNotDisabled_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AdminNotDisabled", context);
	update("Base", "HostConfigFault", context);
	HostConfigFault_closure(dynamic_cast<const vw1__HostConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AdminNotDisabled_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AffinityConfigured_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AffinityConfigured", context);
	update_member(update, "configuredAffinity", "xsd:string[]", a2s_basic(*_obj.configuredAffinity, _obj.__sizeconfiguredAffinity), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AffinityConfigured_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AgentInstallFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AgentInstallFailed", context);
	update_member_with_version(update, "installerOutput", "xsd:string", basic2str(_obj.installerOutput), context, "4.0");
	update_member_with_version(update, "reason", "xsd:string", basic2str(_obj.reason), context, "4.0");
	update_member_with_version(update, "statusCode", "xsd:int", basic2str(_obj.statusCode), context, "4.0");
	update("Base", "HostConnectFault", context);
	HostConnectFault_closure(dynamic_cast<const vw1__HostConnectFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AgentInstallFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AlreadyBeingManaged_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlreadyBeingManaged", context);
	update_member(update, "ipAddress", "xsd:string", basic2str(_obj.ipAddress), context);
	update("Base", "HostConnectFault", context);
	HostConnectFault_closure(dynamic_cast<const vw1__HostConnectFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlreadyBeingManaged_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AlreadyConnected_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlreadyConnected", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "HostConnectFault", context);
	HostConnectFault_closure(dynamic_cast<const vw1__HostConnectFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlreadyConnected_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AlreadyExists_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlreadyExists", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlreadyExists_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AlreadyUpgraded_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlreadyUpgraded", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AlreadyUpgraded_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AnswerFileUpdateFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AnswerFileUpdateFailed", context);
	update_member(update, "failure", "AnswerFileUpdateFailure[]", a2s_object(_obj.failure, _obj.__sizefailure), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AnswerFileUpdateFailed_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefailure)
				return new AnswerFileUpdateFailure_closure(*_obj.failure[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VimFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ApplicationQuiesceFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ApplicationQuiesceFault", context);
	update("Base", "SnapshotFault", context);
	SnapshotFault_closure(dynamic_cast<const vw1__SnapshotFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ApplicationQuiesceFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void AuthMinimumAdminPermission_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AuthMinimumAdminPermission", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* AuthMinimumAdminPermission_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void BlockedByFirewall_closure::browse(pf_update update, void* context) const
{
	update("Begin", "BlockedByFirewall", context);
	update("Base", "HostConfigFault", context);
	HostConfigFault_closure(dynamic_cast<const vw1__HostConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* BlockedByFirewall_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CAMServerRefusedConnection_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CAMServerRefusedConnection", context);
	update("Base", "InvalidCAMServer", context);
	InvalidCAMServer_closure(dynamic_cast<const vw1__InvalidCAMServer&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CAMServerRefusedConnection_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotAccessFile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotAccessFile", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotAccessFile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotAccessLocalSource_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotAccessLocalSource", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotAccessLocalSource_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotAccessNetwork_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotAccessNetwork", context);
	update("Base", "CannotAccessVmDevice", context);
	CannotAccessVmDevice_closure(dynamic_cast<const vw1__CannotAccessVmDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotAccessNetwork_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotAccessVmComponent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotAccessVmComponent", context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotAccessVmComponent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotAccessVmConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotAccessVmConfig", context);
	update_member(update, "reason", "LocalizedMethodFault", handle_obj_ptr(_obj.reason), context);
	update("Base", "CannotAccessVmComponent", context);
	CannotAccessVmComponent_closure(dynamic_cast<const vw1__CannotAccessVmComponent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotAccessVmConfig_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.reason)
			return new LocalizedMethodFault_closure(*_obj.reason);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return CannotAccessVmComponent_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void CannotAccessVmDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotAccessVmDevice", context);
	update_member(update, "backing", "xsd:string", basic2str(_obj.backing), context);
	update_member(update, "connected", "xsd:boolean", basic2str(_obj.connected), context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update("Base", "CannotAccessVmComponent", context);
	CannotAccessVmComponent_closure(dynamic_cast<const vw1__CannotAccessVmComponent&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotAccessVmDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotAccessVmDisk_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotAccessVmDisk", context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update("Base", "CannotAccessVmDevice", context);
	CannotAccessVmDevice_closure(dynamic_cast<const vw1__CannotAccessVmDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotAccessVmDisk_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return CannotAccessVmDevice_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void CannotAddHostWithFTVmAsStandalone_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotAddHostWithFTVmAsStandalone", context);
	update("Base", "HostConnectFault", context);
	HostConnectFault_closure(dynamic_cast<const vw1__HostConnectFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotAddHostWithFTVmAsStandalone_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotAddHostWithFTVmToDifferentCluster_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotAddHostWithFTVmToDifferentCluster", context);
	update("Base", "HostConnectFault", context);
	HostConnectFault_closure(dynamic_cast<const vw1__HostConnectFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotAddHostWithFTVmToDifferentCluster_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotAddHostWithFTVmToNonHACluster_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotAddHostWithFTVmToNonHACluster", context);
	update("Base", "HostConnectFault", context);
	HostConnectFault_closure(dynamic_cast<const vw1__HostConnectFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotAddHostWithFTVmToNonHACluster_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotChangeDrsBehaviorForFtSecondary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotChangeDrsBehaviorForFtSecondary", context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotChangeDrsBehaviorForFtSecondary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmFaultToleranceIssue_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void CannotChangeHaSettingsForFtSecondary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotChangeHaSettingsForFtSecondary", context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotChangeHaSettingsForFtSecondary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmFaultToleranceIssue_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void CannotCreateFile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotCreateFile", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotCreateFile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotDecryptPasswords_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotDecryptPasswords", context);
	update("Base", "CustomizationFault", context);
	CustomizationFault_closure(dynamic_cast<const vw1__CustomizationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotDecryptPasswords_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotDeleteFile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotDeleteFile", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotDeleteFile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotDisableDrsOnClustersWithVApps_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotDisableDrsOnClustersWithVApps", context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotDisableDrsOnClustersWithVApps_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotDisableSnapshot_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotDisableSnapshot", context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotDisableSnapshot_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotDisconnectHostWithFaultToleranceVm_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotDisconnectHostWithFaultToleranceVm", context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotDisconnectHostWithFaultToleranceVm_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotModifyConfigCpuRequirements_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotModifyConfigCpuRequirements", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotModifyConfigCpuRequirements_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotMoveFaultToleranceVm_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotMoveFaultToleranceVm", context);
	update_member(update, "moveType", "xsd:string", basic2str(_obj.moveType), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotMoveFaultToleranceVm_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotMoveHostWithFaultToleranceVm_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotMoveHostWithFaultToleranceVm", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotMoveHostWithFaultToleranceVm_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotMoveVmWithDeltaDisk_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotMoveVmWithDeltaDisk", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotMoveVmWithDeltaDisk_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotMoveVmWithNativeDeltaDisk_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotMoveVmWithNativeDeltaDisk", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotMoveVmWithNativeDeltaDisk_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CannotPowerOffVmInCluster_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CannotPowerOffVmInCluster", context);
	update_member(update, "operation", "xsd:string", basic2str(_obj.operation), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "InvalidState", context);
	InvalidState_closure(dynamic_cast<const vw1__InvalidState&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CannotPowerOffVmInCluster_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return InvalidState_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ClockSkew_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClockSkew", context);
	update("Base", "HostConfigFault", context);
	HostConfigFault_closure(dynamic_cast<const vw1__HostConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClockSkew_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CloneFromSnapshotNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CloneFromSnapshotNotSupported", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CloneFromSnapshotNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ConcurrentAccess_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ConcurrentAccess", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ConcurrentAccess_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ConnectedIso_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ConnectedIso", context);
	update_member(update, "cdrom", "VirtualCdrom", handle_obj_ptr(_obj.cdrom), context);
	update_member(update, "filename", "xsd:string", basic2str(_obj.filename), context);
	update("Base", "OvfExport", context);
	OvfExport_closure(dynamic_cast<const vw1__OvfExport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ConnectedIso_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.cdrom)
			return new VirtualCdrom_closure(*_obj.cdrom);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return OvfExport_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void CpuCompatibilityUnknown_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CpuCompatibilityUnknown", context);
	update("Base", "CpuIncompatible", context);
	CpuIncompatible_closure(dynamic_cast<const vw1__CpuIncompatible&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CpuCompatibilityUnknown_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CpuHotPlugNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CpuHotPlugNotSupported", context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CpuHotPlugNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CpuIncompatible_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CpuIncompatible", context);
	update_member_with_version(update, "desiredBits", "xsd:string", basic2str(_obj.desiredBits), context, "2.5");
	update_member_with_version(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context, "2.5");
	update_member(update, "level", "xsd:int", basic2str(_obj.level), context);
	update_member_with_version(update, "registerBits", "xsd:string", basic2str(_obj.registerBits), context, "2.5");
	update_member(update, "registerName", "xsd:string", basic2str(_obj.registerName), context);
	update("Base", "VirtualHardwareCompatibilityIssue", context);
	VirtualHardwareCompatibilityIssue_closure(dynamic_cast<const vw1__VirtualHardwareCompatibilityIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CpuIncompatible_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualHardwareCompatibilityIssue_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void CpuIncompatible1ECX_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CpuIncompatible1ECX", context);
	update_member_with_version(update, "aes", "xsd:boolean", basic2str(_obj.aes), context, "5.0");
	update_member(update, "other", "xsd:boolean", basic2str(_obj.other), context);
	update_member(update, "otherOnly", "xsd:boolean", basic2str(_obj.otherOnly), context);
	update_member_with_version(update, "pclmulqdq", "xsd:boolean", basic2str(_obj.pclmulqdq), context, "5.0");
	update_member(update, "sse3", "xsd:boolean", basic2str(_obj.sse3), context);
	update_member(update, "sse41", "xsd:boolean", basic2str(_obj.sse41), context);
	update_member(update, "sse42", "xsd:boolean", basic2str(_obj.sse42), context);
	update_member(update, "ssse3", "xsd:boolean", basic2str(_obj.ssse3), context);
	update("Base", "CpuIncompatible", context);
	CpuIncompatible_closure(dynamic_cast<const vw1__CpuIncompatible&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CpuIncompatible1ECX_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CpuIncompatible81EDX_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CpuIncompatible81EDX", context);
	update_member(update, "ffxsr", "xsd:boolean", basic2str(_obj.ffxsr), context);
	update_member(update, "lm", "xsd:boolean", basic2str(_obj.lm), context);
	update_member(update, "nx", "xsd:boolean", basic2str(_obj.nx), context);
	update_member(update, "other", "xsd:boolean", basic2str(_obj.other), context);
	update_member(update, "otherOnly", "xsd:boolean", basic2str(_obj.otherOnly), context);
	update_member(update, "rdtscp", "xsd:boolean", basic2str(_obj.rdtscp), context);
	update("Base", "CpuIncompatible", context);
	CpuIncompatible_closure(dynamic_cast<const vw1__CpuIncompatible&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CpuIncompatible81EDX_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void CustomizationPending_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationPending", context);
	update("Base", "CustomizationFault", context);
	CustomizationFault_closure(dynamic_cast<const vw1__CustomizationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* CustomizationPending_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DVPortNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DVPortNotSupported", context);
	update("Base", "DeviceBackingNotSupported", context);
	DeviceBackingNotSupported_closure(dynamic_cast<const vw1__DeviceBackingNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DVPortNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DasConfigFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DasConfigFault", context);
	update_member_with_version(update, "event", "Event[]", a2s_object(_obj.event, _obj.__sizeevent), context, "4.0");
	update_member_with_version(update, "output", "xsd:string", basic2str(_obj.output), context, "4.0");
	update_member_with_version(update, "reason", "xsd:string", basic2str(_obj.reason), context, "4.0");
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DasConfigFault_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeevent)
				return new Event_closure(*_obj.event[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VimFault_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void DatabaseError_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatabaseError", context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatabaseError_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DatacenterMismatch_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatacenterMismatch", context);
	update_member(update, "expectedDatacenter", "Datacenter", handle_obj_ptr(_obj.expectedDatacenter), context);
	update_member(update, "invalidArgument", "DatacenterMismatchArgument[]", a2s_object(_obj.invalidArgument, _obj.__sizeinvalidArgument), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatacenterMismatch_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.expectedDatacenter? 
			get_closure_from_mor(Datacenter(_obj.expectedDatacenter)) : 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeinvalidArgument)
				return new DatacenterMismatchArgument_closure(*_obj.invalidArgument[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return MigrationFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DatastoreNotWritableOnHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DatastoreNotWritableOnHost", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update("Base", "InvalidDatastore", context);
	InvalidDatastore_closure(dynamic_cast<const vw1__InvalidDatastore&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DatastoreNotWritableOnHost_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return InvalidDatastore_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DeltaDiskFormatNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DeltaDiskFormatNotSupported", context);
	update_member(update, "datastore", "Datastore[]", a2s_object(_obj.datastore, _obj.__sizedatastore), context);
	update_member(update, "deltaDiskFormat", "xsd:string", basic2str(_obj.deltaDiskFormat), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DeltaDiskFormatNotSupported_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedatastore)
				return new Datastore_closure(_obj.datastore[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VmConfigFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DestinationSwitchFull_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DestinationSwitchFull", context);
	update("Base", "CannotAccessNetwork", context);
	CannotAccessNetwork_closure(dynamic_cast<const vw1__CannotAccessNetwork&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DestinationSwitchFull_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DeviceBackingNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DeviceBackingNotSupported", context);
	update_member(update, "backing", "xsd:string", basic2str(_obj.backing), context);
	update("Base", "DeviceNotSupported", context);
	DeviceNotSupported_closure(dynamic_cast<const vw1__DeviceNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DeviceBackingNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DeviceControllerNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DeviceControllerNotSupported", context);
	update_member(update, "controller", "xsd:string", basic2str(_obj.controller), context);
	update("Base", "DeviceNotSupported", context);
	DeviceNotSupported_closure(dynamic_cast<const vw1__DeviceNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DeviceControllerNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DeviceHotPlugNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DeviceHotPlugNotSupported", context);
	update("Base", "InvalidDeviceSpec", context);
	InvalidDeviceSpec_closure(dynamic_cast<const vw1__InvalidDeviceSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DeviceHotPlugNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DeviceNotFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DeviceNotFound", context);
	update("Base", "InvalidDeviceSpec", context);
	InvalidDeviceSpec_closure(dynamic_cast<const vw1__InvalidDeviceSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DeviceNotFound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DeviceNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DeviceNotSupported", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update_member_with_version(update, "reason", "xsd:string", basic2str(_obj.reason), context, "2.5");
	update("Base", "VirtualHardwareCompatibilityIssue", context);
	VirtualHardwareCompatibilityIssue_closure(dynamic_cast<const vw1__VirtualHardwareCompatibilityIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DeviceNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DeviceUnsupportedForVmPlatform_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DeviceUnsupportedForVmPlatform", context);
	update("Base", "InvalidDeviceSpec", context);
	InvalidDeviceSpec_closure(dynamic_cast<const vw1__InvalidDeviceSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DeviceUnsupportedForVmPlatform_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DeviceUnsupportedForVmVersion_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DeviceUnsupportedForVmVersion", context);
	update_member(update, "currentVersion", "xsd:string", basic2str(_obj.currentVersion), context);
	update_member(update, "expectedVersion", "xsd:string", basic2str(_obj.expectedVersion), context);
	update("Base", "InvalidDeviceSpec", context);
	InvalidDeviceSpec_closure(dynamic_cast<const vw1__InvalidDeviceSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DeviceUnsupportedForVmVersion_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DirectoryNotEmpty_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DirectoryNotEmpty", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DirectoryNotEmpty_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DisableAdminNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DisableAdminNotSupported", context);
	update("Base", "HostConfigFault", context);
	HostConfigFault_closure(dynamic_cast<const vw1__HostConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DisableAdminNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DisallowedChangeByService_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DisallowedChangeByService", context);
	update_member(update, "disallowedChange", "xsd:string", basic2str(_obj.disallowedChange), context);
	update_member(update, "serviceName", "xsd:string", basic2str(_obj.serviceName), context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DisallowedChangeByService_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DisallowedDiskModeChange_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DisallowedDiskModeChange", context);
	update("Base", "InvalidDeviceSpec", context);
	InvalidDeviceSpec_closure(dynamic_cast<const vw1__InvalidDeviceSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DisallowedDiskModeChange_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DisallowedMigrationDeviceAttached_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DisallowedMigrationDeviceAttached", context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DisallowedMigrationDeviceAttached_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return MigrationFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DisallowedOperationOnFailoverHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DisallowedOperationOnFailoverHost", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "hostname", "xsd:string", basic2str(_obj.hostname), context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DisallowedOperationOnFailoverHost_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return RuntimeFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DiskMoveTypeNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DiskMoveTypeNotSupported", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DiskMoveTypeNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DiskNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DiskNotSupported", context);
	update_member(update, "disk", "xsd:int", basic2str(_obj.disk), context);
	update("Base", "VirtualHardwareCompatibilityIssue", context);
	VirtualHardwareCompatibilityIssue_closure(dynamic_cast<const vw1__VirtualHardwareCompatibilityIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DiskNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DomainNotFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DomainNotFound", context);
	update_member(update, "domainName", "xsd:string", basic2str(_obj.domainName), context);
	update("Base", "ActiveDirectoryFault", context);
	ActiveDirectoryFault_closure(dynamic_cast<const vw1__ActiveDirectoryFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DomainNotFound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsDisabledOnVm_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsDisabledOnVm", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsDisabledOnVm_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DrsVmotionIncompatibleFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DrsVmotionIncompatibleFault", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update("Base", "VirtualHardwareCompatibilityIssue", context);
	VirtualHardwareCompatibilityIssue_closure(dynamic_cast<const vw1__VirtualHardwareCompatibilityIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DrsVmotionIncompatibleFault_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualHardwareCompatibilityIssue_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DuplicateName_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DuplicateName", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "object", "ManagedObjectReference", handle_obj_ptr(_obj.object), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DuplicateName_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.object)
			return new ManagedObjectReference_closure(*_obj.object);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VimFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void DvsFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsNotAuthorized_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsNotAuthorized", context);
	update_member(update, "dvsExtensionKey", "xsd:string", basic2str(_obj.dvsExtensionKey), context);
	update_member(update, "sessionExtensionKey", "xsd:string", basic2str(_obj.sessionExtensionKey), context);
	update("Base", "DvsFault", context);
	DvsFault_closure(dynamic_cast<const vw1__DvsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsNotAuthorized_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void DvsOperationBulkFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsOperationBulkFault", context);
	update_member(update, "hostFault", "DvsOperationBulkFaultFaultOnHost[]", a2s_object(_obj.hostFault, _obj.__sizehostFault), context);
	update("Base", "DvsFault", context);
	DvsFault_closure(dynamic_cast<const vw1__DvsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsOperationBulkFault_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehostFault)
				return new DvsOperationBulkFaultFaultOnHost_closure(*_obj.hostFault[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DvsFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void DvsScopeViolated_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DvsScopeViolated", context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "scope", "ManagedEntity[]", a2s_object(_obj.scope, _obj.__sizescope), context);
	update("Base", "DvsFault", context);
	DvsFault_closure(dynamic_cast<const vw1__DvsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DvsScopeViolated_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizescope)
				return new ManagedEntity_closure(_obj.scope[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return DvsFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void EVCAdmissionFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EVCAdmissionFailed", context);
	update("Base", "NotSupportedHostInCluster", context);
	NotSupportedHostInCluster_closure(dynamic_cast<const vw1__NotSupportedHostInCluster&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EVCAdmissionFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EVCAdmissionFailedCPUFeaturesForMode_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EVCAdmissionFailedCPUFeaturesForMode", context);
	update_member(update, "currentEVCModeKey", "xsd:string", basic2str(_obj.currentEVCModeKey), context);
	update("Base", "EVCAdmissionFailed", context);
	EVCAdmissionFailed_closure(dynamic_cast<const vw1__EVCAdmissionFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EVCAdmissionFailedCPUFeaturesForMode_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EVCAdmissionFailedCPUModel_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EVCAdmissionFailedCPUModel", context);
	update("Base", "EVCAdmissionFailed", context);
	EVCAdmissionFailed_closure(dynamic_cast<const vw1__EVCAdmissionFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EVCAdmissionFailedCPUModel_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EVCAdmissionFailedCPUModelForMode_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EVCAdmissionFailedCPUModelForMode", context);
	update_member(update, "currentEVCModeKey", "xsd:string", basic2str(_obj.currentEVCModeKey), context);
	update("Base", "EVCAdmissionFailed", context);
	EVCAdmissionFailed_closure(dynamic_cast<const vw1__EVCAdmissionFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EVCAdmissionFailedCPUModelForMode_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EVCAdmissionFailedCPUVendor_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EVCAdmissionFailedCPUVendor", context);
	update_member(update, "clusterCPUVendor", "xsd:string", basic2str(_obj.clusterCPUVendor), context);
	update_member(update, "hostCPUVendor", "xsd:string", basic2str(_obj.hostCPUVendor), context);
	update("Base", "EVCAdmissionFailed", context);
	EVCAdmissionFailed_closure(dynamic_cast<const vw1__EVCAdmissionFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EVCAdmissionFailedCPUVendor_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EVCAdmissionFailedCPUVendorUnknown_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EVCAdmissionFailedCPUVendorUnknown", context);
	update("Base", "EVCAdmissionFailed", context);
	EVCAdmissionFailed_closure(dynamic_cast<const vw1__EVCAdmissionFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EVCAdmissionFailedCPUVendorUnknown_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EVCAdmissionFailedHostDisconnected_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EVCAdmissionFailedHostDisconnected", context);
	update("Base", "EVCAdmissionFailed", context);
	EVCAdmissionFailed_closure(dynamic_cast<const vw1__EVCAdmissionFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EVCAdmissionFailedHostDisconnected_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EVCAdmissionFailedHostSoftware_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EVCAdmissionFailedHostSoftware", context);
	update("Base", "EVCAdmissionFailed", context);
	EVCAdmissionFailed_closure(dynamic_cast<const vw1__EVCAdmissionFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EVCAdmissionFailedHostSoftware_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EVCAdmissionFailedHostSoftwareForMode_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EVCAdmissionFailedHostSoftwareForMode", context);
	update("Base", "EVCAdmissionFailed", context);
	EVCAdmissionFailed_closure(dynamic_cast<const vw1__EVCAdmissionFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EVCAdmissionFailedHostSoftwareForMode_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EVCAdmissionFailedVmActive_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EVCAdmissionFailedVmActive", context);
	update("Base", "EVCAdmissionFailed", context);
	EVCAdmissionFailed_closure(dynamic_cast<const vw1__EVCAdmissionFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EVCAdmissionFailedVmActive_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void EightHostLimitViolated_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EightHostLimitViolated", context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EightHostLimitViolated_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExpiredAddonLicense_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExpiredAddonLicense", context);
	update("Base", "ExpiredFeatureLicense", context);
	ExpiredFeatureLicense_closure(dynamic_cast<const vw1__ExpiredFeatureLicense&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExpiredAddonLicense_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExpiredEditionLicense_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExpiredEditionLicense", context);
	update("Base", "ExpiredFeatureLicense", context);
	ExpiredFeatureLicense_closure(dynamic_cast<const vw1__ExpiredFeatureLicense&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExpiredEditionLicense_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExpiredFeatureLicense_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExpiredFeatureLicense", context);
	update_member(update, "count", "xsd:int", basic2str(_obj.count), context);
	update_member(update, "expirationDate", "xsd:dateTime", basic2str(_obj.expirationDate), context);
	update_member(update, "feature", "xsd:string", basic2str(_obj.feature), context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExpiredFeatureLicense_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ExtendedFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtendedFault", context);
	update_member(update, "data", "KeyValue[]", a2s_object(_obj.data, _obj.__sizedata), context);
	update_member(update, "faultTypeId", "xsd:string", basic2str(_obj.faultTypeId), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ExtendedFault_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedata)
				return new KeyValue_closure(*_obj.data[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VimFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void FailToEnableSPBM_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FailToEnableSPBM", context);
	update_member(update, "cs", "ComputeResource", handle_obj_ptr(_obj.cs), context);
	update_member(update, "csName", "xsd:string", basic2str(_obj.csName), context);
	update_member(update, "hostLicenseStates", "ComputeResourceHostSPBMLicenseInfo[]", a2s_object(_obj.hostLicenseStates, _obj.__sizehostLicenseStates), context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FailToEnableSPBM_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.cs? 
			get_closure_from_mor(ComputeResource(_obj.cs)) : 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehostLicenseStates)
				return new ComputeResourceHostSPBMLicenseInfo_closure(*_obj.hostLicenseStates[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return NotEnoughLicenses_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void FailToLockFaultToleranceVMs_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FailToLockFaultToleranceVMs", context);
	update_member(update, "alreadyLockedVm", "VirtualMachine", handle_obj_ptr(_obj.alreadyLockedVm), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FailToLockFaultToleranceVMs_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.alreadyLockedVm? 
			get_closure_from_mor(VirtualMachine(_obj.alreadyLockedVm)) : 0;
	case 1:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return RuntimeFault_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void FaultToleranceAntiAffinityViolated_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FaultToleranceAntiAffinityViolated", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FaultToleranceAntiAffinityViolated_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return MigrationFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void FaultToleranceCannotEditMem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FaultToleranceCannotEditMem", context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FaultToleranceCannotEditMem_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmConfigFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void FaultToleranceCpuIncompatible_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FaultToleranceCpuIncompatible", context);
	update_member(update, "family", "xsd:boolean", basic2str(_obj.family), context);
	update_member(update, "model", "xsd:boolean", basic2str(_obj.model), context);
	update_member(update, "stepping", "xsd:boolean", basic2str(_obj.stepping), context);
	update("Base", "CpuIncompatible", context);
	CpuIncompatible_closure(dynamic_cast<const vw1__CpuIncompatible&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FaultToleranceCpuIncompatible_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FaultToleranceNeedsThickDisk_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FaultToleranceNeedsThickDisk", context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FaultToleranceNeedsThickDisk_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FaultToleranceNotLicensed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FaultToleranceNotLicensed", context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FaultToleranceNotLicensed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FaultToleranceNotSameBuild_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FaultToleranceNotSameBuild", context);
	update_member(update, "build", "xsd:string", basic2str(_obj.build), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FaultToleranceNotSameBuild_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FaultTolerancePrimaryPowerOnNotAttempted_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FaultTolerancePrimaryPowerOnNotAttempted", context);
	update_member(update, "primaryVm", "VirtualMachine", handle_obj_ptr(_obj.primaryVm), context);
	update_member(update, "secondaryVm", "VirtualMachine", handle_obj_ptr(_obj.secondaryVm), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FaultTolerancePrimaryPowerOnNotAttempted_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.primaryVm? 
			get_closure_from_mor(VirtualMachine(_obj.primaryVm)) : 0;
	case 1:
		return _obj.secondaryVm? 
			get_closure_from_mor(VirtualMachine(_obj.secondaryVm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmFaultToleranceIssue_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void FaultToleranceVmNotDasProtected_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FaultToleranceVmNotDasProtected", context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FaultToleranceVmNotDasProtected_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VimFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void FcoeFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FcoeFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FcoeFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FcoeFaultPnicHasNoPortSet_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FcoeFaultPnicHasNoPortSet", context);
	update_member(update, "nicDevice", "xsd:string", basic2str(_obj.nicDevice), context);
	update("Base", "FcoeFault", context);
	FcoeFault_closure(dynamic_cast<const vw1__FcoeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FcoeFaultPnicHasNoPortSet_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FileAlreadyExists_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FileAlreadyExists", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FileAlreadyExists_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FileBackedPortNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FileBackedPortNotSupported", context);
	update("Base", "DeviceNotSupported", context);
	DeviceNotSupported_closure(dynamic_cast<const vw1__DeviceNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FileBackedPortNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FileFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FileFault", context);
	update_member(update, "file", "xsd:string", basic2str(_obj.file), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FileFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FileLocked_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FileLocked", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FileLocked_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FileNameTooLong_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FileNameTooLong", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FileNameTooLong_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FileNotFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FileNotFound", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FileNotFound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FileNotWritable_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FileNotWritable", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FileNotWritable_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FileTooLarge_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FileTooLarge", context);
	update_member(update, "datastore", "xsd:string", basic2str(_obj.datastore), context);
	update_member(update, "fileSize", "xsd:long", basic2str(_obj.fileSize), context);
	update_member(update, "maxFileSize", "xsd:long", basic2str(_obj.maxFileSize), context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FileTooLarge_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FilesystemQuiesceFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FilesystemQuiesceFault", context);
	update("Base", "SnapshotFault", context);
	SnapshotFault_closure(dynamic_cast<const vw1__SnapshotFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FilesystemQuiesceFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void FtIssuesOnHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FtIssuesOnHost", context);
	update_member(update, "errors", "LocalizedMethodFault[]", a2s_object(_obj.errors, _obj.__sizeerrors), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FtIssuesOnHost_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeerrors)
				return new LocalizedMethodFault_closure(*_obj.errors[i]);
			else
				return 0;
		}
	case 1:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmFaultToleranceIssue_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void FullStorageVMotionNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FullStorageVMotionNotSupported", context);
	update("Base", "MigrationFeatureNotSupported", context);
	MigrationFeatureNotSupported_closure(dynamic_cast<const vw1__MigrationFeatureNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* FullStorageVMotionNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GenericDrsFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GenericDrsFault", context);
	update_member(update, "hostFaults", "LocalizedMethodFault[]", a2s_object(_obj.hostFaults, _obj.__sizehostFaults), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GenericDrsFault_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehostFaults)
				return new LocalizedMethodFault_closure(*_obj.hostFaults[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VimFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void GenericVmConfigFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GenericVmConfigFault", context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GenericVmConfigFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GuestAuthenticationChallenge_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestAuthenticationChallenge", context);
	update_member(update, "serverChallenge", "GuestAuthentication", handle_obj_ptr(_obj.serverChallenge), context);
	update_member(update, "sessionID", "xsd:long", basic2str(_obj.sessionID), context);
	update("Base", "GuestOperationsFault", context);
	GuestOperationsFault_closure(dynamic_cast<const vw1__GuestOperationsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestAuthenticationChallenge_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.serverChallenge)
			return new GuestAuthentication_closure(*_obj.serverChallenge);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return GuestOperationsFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void GuestComponentsOutOfDate_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestComponentsOutOfDate", context);
	update("Base", "GuestOperationsFault", context);
	GuestOperationsFault_closure(dynamic_cast<const vw1__GuestOperationsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestComponentsOutOfDate_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GuestOperationsFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestOperationsFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestOperationsFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GuestOperationsUnavailable_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestOperationsUnavailable", context);
	update("Base", "GuestOperationsFault", context);
	GuestOperationsFault_closure(dynamic_cast<const vw1__GuestOperationsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestOperationsUnavailable_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GuestPermissionDenied_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestPermissionDenied", context);
	update("Base", "GuestOperationsFault", context);
	GuestOperationsFault_closure(dynamic_cast<const vw1__GuestOperationsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestPermissionDenied_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void GuestProcessNotFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestProcessNotFound", context);
	update_member(update, "pid", "xsd:long", basic2str(_obj.pid), context);
	update("Base", "GuestOperationsFault", context);
	GuestOperationsFault_closure(dynamic_cast<const vw1__GuestOperationsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* GuestProcessNotFound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HAErrorsAtDest_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HAErrorsAtDest", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HAErrorsAtDest_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostAccessRestrictedToManagementServer_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostAccessRestrictedToManagementServer", context);
	update_member(update, "managementServer", "xsd:string", basic2str(_obj.managementServer), context);
	update("Base", "NotSupported", context);
	NotSupported_closure(dynamic_cast<const vw1__NotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostAccessRestrictedToManagementServer_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostCommunication_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCommunication", context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCommunication_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostConfigFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostConfigFailed", context);
	update_member(update, "failure", "LocalizedMethodFault[]", a2s_object(_obj.failure, _obj.__sizefailure), context);
	update("Base", "HostConfigFault", context);
	HostConfigFault_closure(dynamic_cast<const vw1__HostConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostConfigFailed_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefailure)
				return new LocalizedMethodFault_closure(*_obj.failure[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return HostConfigFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostConfigFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostConfigFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostConfigFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostConnectFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostConnectFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostConnectFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInDomain_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInDomain", context);
	update("Base", "HostConfigFault", context);
	HostConfigFault_closure(dynamic_cast<const vw1__HostConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInDomain_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostIncompatibleForFaultTolerance_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIncompatibleForFaultTolerance", context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIncompatibleForFaultTolerance_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostIncompatibleForRecordReplay_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostIncompatibleForRecordReplay", context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostIncompatibleForRecordReplay_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostInventoryFull_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostInventoryFull", context);
	update_member(update, "capacity", "xsd:int", basic2str(_obj.capacity), context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostInventoryFull_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNotConnected_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNotConnected", context);
	update("Base", "HostCommunication", context);
	HostCommunication_closure(dynamic_cast<const vw1__HostCommunication&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNotConnected_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostNotReachable_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNotReachable", context);
	update("Base", "HostCommunication", context);
	HostCommunication_closure(dynamic_cast<const vw1__HostCommunication&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNotReachable_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HostPowerOpFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPowerOpFailed", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPowerOpFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void HotSnapshotMoveNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HotSnapshotMoveNotSupported", context);
	update("Base", "SnapshotCopyNotSupported", context);
	SnapshotCopyNotSupported_closure(dynamic_cast<const vw1__SnapshotCopyNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HotSnapshotMoveNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IDEDiskNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IDEDiskNotSupported", context);
	update("Base", "DiskNotSupported", context);
	DiskNotSupported_closure(dynamic_cast<const vw1__DiskNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IDEDiskNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IORMNotSupportedHostOnDatastore_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IORMNotSupportedHostOnDatastore", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "datastoreName", "xsd:string", basic2str(_obj.datastoreName), context);
	update_member(update, "host", "HostSystem[]", a2s_object(_obj.host, _obj.__sizehost), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IORMNotSupportedHostOnDatastore_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehost)
				return new HostSystem_closure(_obj.host[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VimFault_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void InUseFeatureManipulationDisallowed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InUseFeatureManipulationDisallowed", context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InUseFeatureManipulationDisallowed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InaccessibleDatastore_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InaccessibleDatastore", context);
	update_member_with_version(update, "detail", "xsd:string", basic2str(_obj.detail), context, "5.0");
	update("Base", "InvalidDatastore", context);
	InvalidDatastore_closure(dynamic_cast<const vw1__InvalidDatastore&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InaccessibleDatastore_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IncompatibleDefaultDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IncompatibleDefaultDevice", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IncompatibleDefaultDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IncompatibleHostForFtSecondary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IncompatibleHostForFtSecondary", context);
	update_member(update, "error", "LocalizedMethodFault[]", a2s_object(_obj.error, _obj.__sizeerror), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IncompatibleHostForFtSecondary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeerror)
				return new LocalizedMethodFault_closure(*_obj.error[i]);
			else
				return 0;
		}
	case 1:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmFaultToleranceIssue_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void IncompatibleSetting_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IncompatibleSetting", context);
	update_member(update, "conflictingProperty", "xsd:string", basic2str(_obj.conflictingProperty), context);
	update("Base", "InvalidArgument", context);
	InvalidArgument_closure(dynamic_cast<const vw1__InvalidArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IncompatibleSetting_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IncorrectFileType_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IncorrectFileType", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IncorrectFileType_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IncorrectHostInformation_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IncorrectHostInformation", context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IncorrectHostInformation_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IndependentDiskVMotionNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IndependentDiskVMotionNotSupported", context);
	update("Base", "MigrationFeatureNotSupported", context);
	MigrationFeatureNotSupported_closure(dynamic_cast<const vw1__MigrationFeatureNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IndependentDiskVMotionNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InsufficientAgentVmsDeployed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InsufficientAgentVmsDeployed", context);
	update_member(update, "currentNumAgentVms", "xsd:int", basic2str(_obj.currentNumAgentVms), context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update_member(update, "requiredNumAgentVms", "xsd:int", basic2str(_obj.requiredNumAgentVms), context);
	update("Base", "InsufficientResourcesFault", context);
	InsufficientResourcesFault_closure(dynamic_cast<const vw1__InsufficientResourcesFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InsufficientAgentVmsDeployed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InsufficientCpuResourcesFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InsufficientCpuResourcesFault", context);
	update_member(update, "requested", "xsd:long", basic2str(_obj.requested), context);
	update_member(update, "unreserved", "xsd:long", basic2str(_obj.unreserved), context);
	update("Base", "InsufficientResourcesFault", context);
	InsufficientResourcesFault_closure(dynamic_cast<const vw1__InsufficientResourcesFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InsufficientCpuResourcesFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InsufficientFailoverResourcesFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InsufficientFailoverResourcesFault", context);
	update("Base", "InsufficientResourcesFault", context);
	InsufficientResourcesFault_closure(dynamic_cast<const vw1__InsufficientResourcesFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InsufficientFailoverResourcesFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InsufficientHostCapacityFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InsufficientHostCapacityFault", context);
	update_member_with_version(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context, "2.5");
	update("Base", "InsufficientResourcesFault", context);
	InsufficientResourcesFault_closure(dynamic_cast<const vw1__InsufficientResourcesFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InsufficientHostCapacityFault_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return InsufficientResourcesFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void InsufficientHostCpuCapacityFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InsufficientHostCpuCapacityFault", context);
	update_member(update, "requested", "xsd:long", basic2str(_obj.requested), context);
	update_member(update, "unreserved", "xsd:long", basic2str(_obj.unreserved), context);
	update("Base", "InsufficientHostCapacityFault", context);
	InsufficientHostCapacityFault_closure(dynamic_cast<const vw1__InsufficientHostCapacityFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InsufficientHostCpuCapacityFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InsufficientHostMemoryCapacityFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InsufficientHostMemoryCapacityFault", context);
	update_member(update, "requested", "xsd:long", basic2str(_obj.requested), context);
	update_member(update, "unreserved", "xsd:long", basic2str(_obj.unreserved), context);
	update("Base", "InsufficientHostCapacityFault", context);
	InsufficientHostCapacityFault_closure(dynamic_cast<const vw1__InsufficientHostCapacityFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InsufficientHostMemoryCapacityFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InsufficientMemoryResourcesFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InsufficientMemoryResourcesFault", context);
	update_member(update, "requested", "xsd:long", basic2str(_obj.requested), context);
	update_member(update, "unreserved", "xsd:long", basic2str(_obj.unreserved), context);
	update("Base", "InsufficientResourcesFault", context);
	InsufficientResourcesFault_closure(dynamic_cast<const vw1__InsufficientResourcesFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InsufficientMemoryResourcesFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InsufficientPerCpuCapacity_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InsufficientPerCpuCapacity", context);
	update("Base", "InsufficientHostCapacityFault", context);
	InsufficientHostCapacityFault_closure(dynamic_cast<const vw1__InsufficientHostCapacityFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InsufficientPerCpuCapacity_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InsufficientResourcesFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InsufficientResourcesFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InsufficientResourcesFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InsufficientStandbyCpuResource_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InsufficientStandbyCpuResource", context);
	update_member(update, "available", "xsd:long", basic2str(_obj.available), context);
	update_member(update, "requested", "xsd:long", basic2str(_obj.requested), context);
	update("Base", "InsufficientStandbyResource", context);
	InsufficientStandbyResource_closure(dynamic_cast<const vw1__InsufficientStandbyResource&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InsufficientStandbyCpuResource_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InsufficientStandbyMemoryResource_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InsufficientStandbyMemoryResource", context);
	update_member(update, "available", "xsd:long", basic2str(_obj.available), context);
	update_member(update, "requested", "xsd:long", basic2str(_obj.requested), context);
	update("Base", "InsufficientStandbyResource", context);
	InsufficientStandbyResource_closure(dynamic_cast<const vw1__InsufficientStandbyResource&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InsufficientStandbyMemoryResource_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InsufficientStandbyResource_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InsufficientStandbyResource", context);
	update("Base", "InsufficientResourcesFault", context);
	InsufficientResourcesFault_closure(dynamic_cast<const vw1__InsufficientResourcesFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InsufficientStandbyResource_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InsufficientStorageSpace_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InsufficientStorageSpace", context);
	update("Base", "InsufficientResourcesFault", context);
	InsufficientResourcesFault_closure(dynamic_cast<const vw1__InsufficientResourcesFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InsufficientStorageSpace_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidAffinitySettingFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidAffinitySettingFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidAffinitySettingFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidArgument", context);
	update_member(update, "invalidProperty", "xsd:string", basic2str(_obj.invalidProperty), context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidArgument_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidBmcRole_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidBmcRole", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidBmcRole_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidBundle_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidBundle", context);
	update("Base", "PlatformConfigFault", context);
	PlatformConfigFault_closure(dynamic_cast<const vw1__PlatformConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidBundle_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidCAMCertificate_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidCAMCertificate", context);
	update("Base", "InvalidCAMServer", context);
	InvalidCAMServer_closure(dynamic_cast<const vw1__InvalidCAMServer&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidCAMCertificate_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidCAMServer_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidCAMServer", context);
	update_member(update, "camServer", "xsd:string", basic2str(_obj.camServer), context);
	update("Base", "ActiveDirectoryFault", context);
	ActiveDirectoryFault_closure(dynamic_cast<const vw1__ActiveDirectoryFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidCAMServer_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidClientCertificate_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidClientCertificate", context);
	update("Base", "InvalidLogin", context);
	InvalidLogin_closure(dynamic_cast<const vw1__InvalidLogin&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidClientCertificate_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidCollectorVersion_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidCollectorVersion", context);
	update("Base", "MethodFault", context);
	MethodFault_closure(dynamic_cast<const vw1__MethodFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidCollectorVersion_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidController_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidController", context);
	update_member(update, "controllerKey", "xsd:int", basic2str(_obj.controllerKey), context);
	update("Base", "InvalidDeviceSpec", context);
	InvalidDeviceSpec_closure(dynamic_cast<const vw1__InvalidDeviceSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidController_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidDasRestartPriorityForFtVm_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidDasRestartPriorityForFtVm", context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "InvalidArgument", context);
	InvalidArgument_closure(dynamic_cast<const vw1__InvalidArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidDasRestartPriorityForFtVm_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return InvalidArgument_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void InvalidDatastore_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidDatastore", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidDatastore_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VimFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void InvalidDatastorePath_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidDatastorePath", context);
	update_member(update, "datastorePath", "xsd:string", basic2str(_obj.datastorePath), context);
	update("Base", "InvalidDatastore", context);
	InvalidDatastore_closure(dynamic_cast<const vw1__InvalidDatastore&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidDatastorePath_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidDatastoreState_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidDatastoreState", context);
	update_member(update, "datastoreName", "xsd:string", basic2str(_obj.datastoreName), context);
	update("Base", "InvalidState", context);
	InvalidState_closure(dynamic_cast<const vw1__InvalidState&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidDatastoreState_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidDeviceBacking_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidDeviceBacking", context);
	update("Base", "InvalidDeviceSpec", context);
	InvalidDeviceSpec_closure(dynamic_cast<const vw1__InvalidDeviceSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidDeviceBacking_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidDeviceOperation_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidDeviceOperation", context);
	update_member(update, "badFileOp", "VirtualDeviceConfigSpecFileOperation", handle_obj_ptr(_obj.badFileOp), context);
	update_member(update, "badOp", "VirtualDeviceConfigSpecOperation", handle_obj_ptr(_obj.badOp), context);
	update("Base", "InvalidDeviceSpec", context);
	InvalidDeviceSpec_closure(dynamic_cast<const vw1__InvalidDeviceSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidDeviceOperation_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidDeviceSpec_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidDeviceSpec", context);
	update_member(update, "deviceIndex", "xsd:int", basic2str(_obj.deviceIndex), context);
	update("Base", "InvalidVmConfig", context);
	InvalidVmConfig_closure(dynamic_cast<const vw1__InvalidVmConfig&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidDeviceSpec_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidDiskFormat_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidDiskFormat", context);
	update("Base", "InvalidFormat", context);
	InvalidFormat_closure(dynamic_cast<const vw1__InvalidFormat&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidDiskFormat_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidDrsBehaviorForFtVm_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidDrsBehaviorForFtVm", context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "InvalidArgument", context);
	InvalidArgument_closure(dynamic_cast<const vw1__InvalidArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidDrsBehaviorForFtVm_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return InvalidArgument_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void InvalidEditionLicense_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidEditionLicense", context);
	update_member(update, "feature", "xsd:string", basic2str(_obj.feature), context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidEditionLicense_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidEvent_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidEvent", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidEvent_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidFolder_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidFolder", context);
	update_member(update, "target", "ManagedEntity", handle_obj_ptr(_obj.target), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidFolder_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.target? 
			get_closure_from_mor(ManagedEntity(_obj.target)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VimFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void InvalidFormat_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidFormat", context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidFormat_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidGuestLogin_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidGuestLogin", context);
	update("Base", "GuestOperationsFault", context);
	GuestOperationsFault_closure(dynamic_cast<const vw1__GuestOperationsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidGuestLogin_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidHostName_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidHostName", context);
	update("Base", "HostConfigFault", context);
	HostConfigFault_closure(dynamic_cast<const vw1__HostConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidHostName_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidHostState_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidHostState", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update("Base", "InvalidState", context);
	InvalidState_closure(dynamic_cast<const vw1__InvalidState&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidHostState_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return InvalidState_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void InvalidIndexArgument_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidIndexArgument", context);
	update_member(update, "key", "xsd:string", basic2str(_obj.key), context);
	update("Base", "InvalidArgument", context);
	InvalidArgument_closure(dynamic_cast<const vw1__InvalidArgument&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidIndexArgument_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidIpmiLoginInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidIpmiLoginInfo", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidIpmiLoginInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidIpmiMacAddress_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidIpmiMacAddress", context);
	update_member(update, "observedMacAddress", "xsd:string", basic2str(_obj.observedMacAddress), context);
	update_member(update, "userProvidedMacAddress", "xsd:string", basic2str(_obj.userProvidedMacAddress), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidIpmiMacAddress_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidLicense_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidLicense", context);
	update_member(update, "licenseContent", "xsd:string", basic2str(_obj.licenseContent), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidLicense_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidLocale_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidLocale", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidLocale_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidLogin_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidLogin", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidLogin_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidName_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidName", context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidName_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VimFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void InvalidNasCredentials_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidNasCredentials", context);
	update_member(update, "userName", "xsd:string", basic2str(_obj.userName), context);
	update("Base", "NasConfigFault", context);
	NasConfigFault_closure(dynamic_cast<const vw1__NasConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidNasCredentials_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidNetworkInType_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidNetworkInType", context);
	update("Base", "VAppPropertyFault", context);
	VAppPropertyFault_closure(dynamic_cast<const vw1__VAppPropertyFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidNetworkInType_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidNetworkResource_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidNetworkResource", context);
	update_member(update, "remoteHost", "xsd:string", basic2str(_obj.remoteHost), context);
	update_member(update, "remotePath", "xsd:string", basic2str(_obj.remotePath), context);
	update("Base", "NasConfigFault", context);
	NasConfigFault_closure(dynamic_cast<const vw1__NasConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidNetworkResource_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidOperationOnSecondaryVm_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidOperationOnSecondaryVm", context);
	update_member(update, "instanceUuid", "xsd:string", basic2str(_obj.instanceUuid), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidOperationOnSecondaryVm_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidPowerState_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidPowerState", context);
	update_member(update, "existingState", "VirtualMachinePowerState", handle_obj(_obj.existingState), context);
	update_member(update, "requestedState", "VirtualMachinePowerState", handle_obj_ptr(_obj.requestedState), context);
	update("Base", "InvalidState", context);
	InvalidState_closure(dynamic_cast<const vw1__InvalidState&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidPowerState_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidPrivilege_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidPrivilege", context);
	update_member(update, "privilege", "xsd:string", basic2str(_obj.privilege), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidPrivilege_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidProfileReferenceHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidProfileReferenceHost", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "profile", "Profile", handle_obj_ptr(_obj.profile), context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidProfileReferenceHost_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	case 1:
		return _obj.profile? 
			get_closure_from_mor(Profile(_obj.profile)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return RuntimeFault_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void InvalidProperty_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidProperty", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "MethodFault", context);
	MethodFault_closure(dynamic_cast<const vw1__MethodFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidProperty_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidPropertyType_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidPropertyType", context);
	update("Base", "VAppPropertyFault", context);
	VAppPropertyFault_closure(dynamic_cast<const vw1__VAppPropertyFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidPropertyType_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidPropertyValue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidPropertyValue", context);
	update("Base", "VAppPropertyFault", context);
	VAppPropertyFault_closure(dynamic_cast<const vw1__VAppPropertyFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidPropertyValue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidRequest_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidRequest", context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidRequest_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidResourcePoolStructureFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidResourcePoolStructureFault", context);
	update("Base", "InsufficientResourcesFault", context);
	InsufficientResourcesFault_closure(dynamic_cast<const vw1__InsufficientResourcesFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidResourcePoolStructureFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidSnapshotFormat_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidSnapshotFormat", context);
	update("Base", "InvalidFormat", context);
	InvalidFormat_closure(dynamic_cast<const vw1__InvalidFormat&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidSnapshotFormat_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidState_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidState", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidState_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidType_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidType", context);
	update_member(update, "argument", "xsd:string", basic2str(_obj.argument), context);
	update("Base", "InvalidRequest", context);
	InvalidRequest_closure(dynamic_cast<const vw1__InvalidRequest&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidType_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InvalidVmConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InvalidVmConfig", context);
	update_member(update, "property", "xsd:string", basic2str(_obj.property), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InvalidVmConfig_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void InventoryHasStandardAloneHosts_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InventoryHasStandardAloneHosts", context);
	update_member(update, "hosts", "xsd:string[]", a2s_basic(*_obj.hosts, _obj.__sizehosts), context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InventoryHasStandardAloneHosts_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IpHostnameGeneratorError_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IpHostnameGeneratorError", context);
	update("Base", "CustomizationFault", context);
	CustomizationFault_closure(dynamic_cast<const vw1__CustomizationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IpHostnameGeneratorError_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IscsiFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IscsiFaultInvalidVnic_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiFaultInvalidVnic", context);
	update_member(update, "vnicDevice", "xsd:string", basic2str(_obj.vnicDevice), context);
	update("Base", "IscsiFault", context);
	IscsiFault_closure(dynamic_cast<const vw1__IscsiFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiFaultInvalidVnic_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IscsiFaultPnicInUse_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiFaultPnicInUse", context);
	update_member(update, "pnicDevice", "xsd:string", basic2str(_obj.pnicDevice), context);
	update("Base", "IscsiFault", context);
	IscsiFault_closure(dynamic_cast<const vw1__IscsiFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiFaultPnicInUse_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IscsiFaultVnicAlreadyBound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiFaultVnicAlreadyBound", context);
	update_member(update, "vnicDevice", "xsd:string", basic2str(_obj.vnicDevice), context);
	update("Base", "IscsiFault", context);
	IscsiFault_closure(dynamic_cast<const vw1__IscsiFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiFaultVnicAlreadyBound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IscsiFaultVnicHasActivePaths_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiFaultVnicHasActivePaths", context);
	update_member(update, "vnicDevice", "xsd:string", basic2str(_obj.vnicDevice), context);
	update("Base", "IscsiFault", context);
	IscsiFault_closure(dynamic_cast<const vw1__IscsiFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiFaultVnicHasActivePaths_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IscsiFaultVnicHasMultipleUplinks_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiFaultVnicHasMultipleUplinks", context);
	update_member(update, "vnicDevice", "xsd:string", basic2str(_obj.vnicDevice), context);
	update("Base", "IscsiFault", context);
	IscsiFault_closure(dynamic_cast<const vw1__IscsiFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiFaultVnicHasMultipleUplinks_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IscsiFaultVnicHasNoUplinks_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiFaultVnicHasNoUplinks", context);
	update_member(update, "vnicDevice", "xsd:string", basic2str(_obj.vnicDevice), context);
	update("Base", "IscsiFault", context);
	IscsiFault_closure(dynamic_cast<const vw1__IscsiFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiFaultVnicHasNoUplinks_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IscsiFaultVnicHasWrongUplink_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiFaultVnicHasWrongUplink", context);
	update_member(update, "vnicDevice", "xsd:string", basic2str(_obj.vnicDevice), context);
	update("Base", "IscsiFault", context);
	IscsiFault_closure(dynamic_cast<const vw1__IscsiFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiFaultVnicHasWrongUplink_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IscsiFaultVnicInUse_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiFaultVnicInUse", context);
	update_member(update, "vnicDevice", "xsd:string", basic2str(_obj.vnicDevice), context);
	update("Base", "IscsiFault", context);
	IscsiFault_closure(dynamic_cast<const vw1__IscsiFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiFaultVnicInUse_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IscsiFaultVnicIsLastPath_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiFaultVnicIsLastPath", context);
	update_member(update, "vnicDevice", "xsd:string", basic2str(_obj.vnicDevice), context);
	update("Base", "IscsiFault", context);
	IscsiFault_closure(dynamic_cast<const vw1__IscsiFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiFaultVnicIsLastPath_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IscsiFaultVnicNotBound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiFaultVnicNotBound", context);
	update_member(update, "vnicDevice", "xsd:string", basic2str(_obj.vnicDevice), context);
	update("Base", "IscsiFault", context);
	IscsiFault_closure(dynamic_cast<const vw1__IscsiFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiFaultVnicNotBound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void IscsiFaultVnicNotFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiFaultVnicNotFound", context);
	update_member(update, "vnicDevice", "xsd:string", basic2str(_obj.vnicDevice), context);
	update("Base", "IscsiFault", context);
	IscsiFault_closure(dynamic_cast<const vw1__IscsiFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* IscsiFaultVnicNotFound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LargeRDMConversionNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LargeRDMConversionNotSupported", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LargeRDMConversionNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LargeRDMNotSupportedOnDatastore_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LargeRDMNotSupportedOnDatastore", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "datastoreName", "xsd:string", basic2str(_obj.datastoreName), context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LargeRDMNotSupportedOnDatastore_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmConfigFault_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void LegacyNetworkInterfaceInUse_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LegacyNetworkInterfaceInUse", context);
	update("Base", "CannotAccessNetwork", context);
	CannotAccessNetwork_closure(dynamic_cast<const vw1__CannotAccessNetwork&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LegacyNetworkInterfaceInUse_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseAssignmentFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseAssignmentFailed", context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseAssignmentFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseDowngradeDisallowed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseDowngradeDisallowed", context);
	update_member(update, "edition", "xsd:string", basic2str(_obj.edition), context);
	update_member(update, "entityId", "xsd:string", basic2str(_obj.entityId), context);
	update_member(update, "features", "KeyAnyValue[]", a2s_object(_obj.features, _obj.__sizefeatures), context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseDowngradeDisallowed_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefeatures)
				return new KeyAnyValue_closure(*_obj.features[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return NotEnoughLicenses_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void LicenseEntityNotFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseEntityNotFound", context);
	update_member(update, "entityId", "xsd:string", basic2str(_obj.entityId), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseEntityNotFound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseExpired_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseExpired", context);
	update_member(update, "licenseKey", "xsd:string", basic2str(_obj.licenseKey), context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseExpired_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseKeyEntityMismatch_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseKeyEntityMismatch", context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseKeyEntityMismatch_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseRestricted_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseRestricted", context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseRestricted_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseServerUnavailable_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseServerUnavailable", context);
	update_member(update, "licenseServer", "xsd:string", basic2str(_obj.licenseServer), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseServerUnavailable_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LicenseSourceUnavailable_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseSourceUnavailable", context);
	update_member(update, "licenseSource", "LicenseSource", handle_obj_ptr(_obj.licenseSource), context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LicenseSourceUnavailable_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.licenseSource)
			return new LicenseSource_closure(*_obj.licenseSource);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return NotEnoughLicenses_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void LimitExceeded_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LimitExceeded", context);
	update_member(update, "limit", "xsd:int", basic2str(_obj.limit), context);
	update_member(update, "property", "xsd:string", basic2str(_obj.property), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LimitExceeded_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LinuxVolumeNotClean_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LinuxVolumeNotClean", context);
	update("Base", "CustomizationFault", context);
	CustomizationFault_closure(dynamic_cast<const vw1__CustomizationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LinuxVolumeNotClean_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void LogBundlingFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LogBundlingFailed", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* LogBundlingFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MaintenanceModeFileMove_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MaintenanceModeFileMove", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MaintenanceModeFileMove_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ManagedObjectNotFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ManagedObjectNotFound", context);
	update_member(update, "obj", "ManagedObjectReference", handle_obj_ptr(_obj.obj), context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ManagedObjectNotFound_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.obj)
			return new ManagedObjectReference_closure(*_obj.obj);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return RuntimeFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void MemoryHotPlugNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MemoryHotPlugNotSupported", context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MemoryHotPlugNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MemorySizeNotRecommended_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MemorySizeNotRecommended", context);
	update_member(update, "maxMemorySizeMB", "xsd:int", basic2str(_obj.maxMemorySizeMB), context);
	update_member(update, "memorySizeMB", "xsd:int", basic2str(_obj.memorySizeMB), context);
	update_member(update, "minMemorySizeMB", "xsd:int", basic2str(_obj.minMemorySizeMB), context);
	update("Base", "VirtualHardwareCompatibilityIssue", context);
	VirtualHardwareCompatibilityIssue_closure(dynamic_cast<const vw1__VirtualHardwareCompatibilityIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MemorySizeNotRecommended_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MemorySizeNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MemorySizeNotSupported", context);
	update_member(update, "maxMemorySizeMB", "xsd:int", basic2str(_obj.maxMemorySizeMB), context);
	update_member(update, "memorySizeMB", "xsd:int", basic2str(_obj.memorySizeMB), context);
	update_member(update, "minMemorySizeMB", "xsd:int", basic2str(_obj.minMemorySizeMB), context);
	update("Base", "VirtualHardwareCompatibilityIssue", context);
	VirtualHardwareCompatibilityIssue_closure(dynamic_cast<const vw1__VirtualHardwareCompatibilityIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MemorySizeNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MemorySizeNotSupportedByDatastore_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MemorySizeNotSupportedByDatastore", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "maxMemorySizeMB", "xsd:int", basic2str(_obj.maxMemorySizeMB), context);
	update_member(update, "memorySizeMB", "xsd:int", basic2str(_obj.memorySizeMB), context);
	update("Base", "VirtualHardwareCompatibilityIssue", context);
	VirtualHardwareCompatibilityIssue_closure(dynamic_cast<const vw1__VirtualHardwareCompatibilityIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MemorySizeNotSupportedByDatastore_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualHardwareCompatibilityIssue_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void MemorySnapshotOnIndependentDisk_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MemorySnapshotOnIndependentDisk", context);
	update("Base", "SnapshotFault", context);
	SnapshotFault_closure(dynamic_cast<const vw1__SnapshotFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MemorySnapshotOnIndependentDisk_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MethodAlreadyDisabledFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MethodAlreadyDisabledFault", context);
	update_member(update, "sourceId", "xsd:string", basic2str(_obj.sourceId), context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MethodAlreadyDisabledFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MethodDisabled_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MethodDisabled", context);
	update_member_with_version(update, "source", "xsd:string", basic2str(_obj.source), context, "4.1");
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MethodDisabled_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MethodFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MethodFault", context);
	update_member(update, "dynamicProperty", "DynamicProperty[]", a2s_object(_obj.dynamicProperty, _obj.__sizedynamicProperty), context);
	update_member(update, "dynamicType", "xsd:string", basic2str(_obj.dynamicType), context);
	update_member_with_version(update, "faultCause", "LocalizedMethodFault", handle_obj_ptr(_obj.faultCause), context, "4.0");
	update_member_with_version(update, "faultMessage", "LocalizableMessage[]", a2s_object(_obj.faultMessage, _obj.__sizefaultMessage), context, "4.0");
	update("End", std::string(), context);
}

closure* MethodFault_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizedynamicProperty)
				return new DynamicProperty_closure(*_obj.dynamicProperty[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.faultCause)
			return new LocalizedMethodFault_closure(*_obj.faultCause);
		else
			return 0;
	case 3:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefaultMessage)
				return new LocalizableMessage_closure(*_obj.faultMessage[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void MethodNotFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MethodNotFound", context);
	update_member(update, "method", "xsd:string", basic2str(_obj.method), context);
	update_member(update, "receiver", "ManagedObjectReference", handle_obj_ptr(_obj.receiver), context);
	update("Base", "InvalidRequest", context);
	InvalidRequest_closure(dynamic_cast<const vw1__InvalidRequest&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MethodNotFound_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		if (_obj.receiver)
			return new ManagedObjectReference_closure(*_obj.receiver);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return InvalidRequest_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void MigrationDisabled_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MigrationDisabled", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MigrationDisabled_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MigrationFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MigrationFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MigrationFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MigrationFeatureNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MigrationFeatureNotSupported", context);
	update_member(update, "atSourceHost", "xsd:boolean", basic2str(_obj.atSourceHost), context);
	update_member(update, "failedHost", "HostSystem", handle_obj_ptr(_obj.failedHost), context);
	update_member(update, "failedHostName", "xsd:string", basic2str(_obj.failedHostName), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MigrationFeatureNotSupported_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.failedHost? 
			get_closure_from_mor(HostSystem(_obj.failedHost)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return MigrationFault_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void MigrationNotReady_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MigrationNotReady", context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MigrationNotReady_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MismatchedBundle_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MismatchedBundle", context);
	update_member(update, "bundleBuildNumber", "xsd:int", basic2str(_obj.bundleBuildNumber), context);
	update_member(update, "bundleUuid", "xsd:string", basic2str(_obj.bundleUuid), context);
	update_member(update, "hostBuildNumber", "xsd:int", basic2str(_obj.hostBuildNumber), context);
	update_member(update, "hostUuid", "xsd:string", basic2str(_obj.hostUuid), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MismatchedBundle_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MismatchedNetworkPolicies_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MismatchedNetworkPolicies", context);
	update_member(update, "backing", "xsd:string", basic2str(_obj.backing), context);
	update_member(update, "connected", "xsd:boolean", basic2str(_obj.connected), context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MismatchedNetworkPolicies_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MismatchedVMotionNetworkNames_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MismatchedVMotionNetworkNames", context);
	update_member(update, "destNetwork", "xsd:string", basic2str(_obj.destNetwork), context);
	update_member(update, "sourceNetwork", "xsd:string", basic2str(_obj.sourceNetwork), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MismatchedVMotionNetworkNames_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MissingBmcSupport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MissingBmcSupport", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MissingBmcSupport_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MissingController_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MissingController", context);
	update("Base", "InvalidDeviceSpec", context);
	InvalidDeviceSpec_closure(dynamic_cast<const vw1__InvalidDeviceSpec&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MissingController_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MissingIpPool_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MissingIpPool", context);
	update("Base", "VAppPropertyFault", context);
	VAppPropertyFault_closure(dynamic_cast<const vw1__VAppPropertyFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MissingIpPool_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MissingLinuxCustResources_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MissingLinuxCustResources", context);
	update("Base", "CustomizationFault", context);
	CustomizationFault_closure(dynamic_cast<const vw1__CustomizationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MissingLinuxCustResources_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MissingNetworkIpConfig_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MissingNetworkIpConfig", context);
	update("Base", "VAppPropertyFault", context);
	VAppPropertyFault_closure(dynamic_cast<const vw1__VAppPropertyFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MissingNetworkIpConfig_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MissingPowerOffConfiguration_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MissingPowerOffConfiguration", context);
	update("Base", "VAppConfigFault", context);
	VAppConfigFault_closure(dynamic_cast<const vw1__VAppConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MissingPowerOffConfiguration_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MissingPowerOnConfiguration_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MissingPowerOnConfiguration", context);
	update("Base", "VAppConfigFault", context);
	VAppConfigFault_closure(dynamic_cast<const vw1__VAppConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MissingPowerOnConfiguration_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MissingWindowsCustResources_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MissingWindowsCustResources", context);
	update("Base", "CustomizationFault", context);
	CustomizationFault_closure(dynamic_cast<const vw1__CustomizationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MissingWindowsCustResources_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MksConnectionLimitReached_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MksConnectionLimitReached", context);
	update_member(update, "connectionLimit", "xsd:int", basic2str(_obj.connectionLimit), context);
	update("Base", "InvalidState", context);
	InvalidState_closure(dynamic_cast<const vw1__InvalidState&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MksConnectionLimitReached_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void MountError_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MountError", context);
	update_member(update, "diskIndex", "xsd:int", basic2str(_obj.diskIndex), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "CustomizationFault", context);
	CustomizationFault_closure(dynamic_cast<const vw1__CustomizationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MountError_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return CustomizationFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void MultipleCertificatesVerifyFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MultipleCertificatesVerifyFault", context);
	update_member(update, "thumbprintData", "MultipleCertificatesVerifyFaultThumbprintData[]", a2s_object(_obj.thumbprintData, _obj.__sizethumbprintData), context);
	update("Base", "HostConnectFault", context);
	HostConnectFault_closure(dynamic_cast<const vw1__HostConnectFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MultipleCertificatesVerifyFault_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizethumbprintData)
				return new MultipleCertificatesVerifyFaultThumbprintData_closure(*_obj.thumbprintData[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return HostConnectFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void MultipleSnapshotsNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "MultipleSnapshotsNotSupported", context);
	update("Base", "SnapshotFault", context);
	SnapshotFault_closure(dynamic_cast<const vw1__SnapshotFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* MultipleSnapshotsNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NasConfigFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NasConfigFault", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "HostConfigFault", context);
	HostConfigFault_closure(dynamic_cast<const vw1__HostConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NasConfigFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NasConnectionLimitReached_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NasConnectionLimitReached", context);
	update_member(update, "remoteHost", "xsd:string", basic2str(_obj.remoteHost), context);
	update_member(update, "remotePath", "xsd:string", basic2str(_obj.remotePath), context);
	update("Base", "NasConfigFault", context);
	NasConfigFault_closure(dynamic_cast<const vw1__NasConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NasConnectionLimitReached_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NasSessionCredentialConflict_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NasSessionCredentialConflict", context);
	update_member(update, "remoteHost", "xsd:string", basic2str(_obj.remoteHost), context);
	update_member(update, "remotePath", "xsd:string", basic2str(_obj.remotePath), context);
	update_member(update, "userName", "xsd:string", basic2str(_obj.userName), context);
	update("Base", "NasConfigFault", context);
	NasConfigFault_closure(dynamic_cast<const vw1__NasConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NasSessionCredentialConflict_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NasVolumeNotMounted_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NasVolumeNotMounted", context);
	update_member(update, "remoteHost", "xsd:string", basic2str(_obj.remoteHost), context);
	update_member(update, "remotePath", "xsd:string", basic2str(_obj.remotePath), context);
	update("Base", "NasConfigFault", context);
	NasConfigFault_closure(dynamic_cast<const vw1__NasConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NasVolumeNotMounted_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetworkCopyFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetworkCopyFault", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetworkCopyFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetworkInaccessible_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetworkInaccessible", context);
	update("Base", "NasConfigFault", context);
	NasConfigFault_closure(dynamic_cast<const vw1__NasConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetworkInaccessible_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NetworksMayNotBeTheSame_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NetworksMayNotBeTheSame", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NetworksMayNotBeTheSame_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NicSettingMismatch_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NicSettingMismatch", context);
	update_member(update, "numberOfNicsInSpec", "xsd:int", basic2str(_obj.numberOfNicsInSpec), context);
	update_member(update, "numberOfNicsInVM", "xsd:int", basic2str(_obj.numberOfNicsInVM), context);
	update("Base", "CustomizationFault", context);
	CustomizationFault_closure(dynamic_cast<const vw1__CustomizationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NicSettingMismatch_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoActiveHostInCluster_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoActiveHostInCluster", context);
	update_member(update, "computeResource", "ComputeResource", handle_obj_ptr(_obj.computeResource), context);
	update("Base", "InvalidState", context);
	InvalidState_closure(dynamic_cast<const vw1__InvalidState&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoActiveHostInCluster_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.computeResource? 
			get_closure_from_mor(ComputeResource(_obj.computeResource)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return InvalidState_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void NoAvailableIp_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoAvailableIp", context);
	update_member(update, "network", "Network", handle_obj_ptr(_obj.network), context);
	update("Base", "VAppPropertyFault", context);
	VAppPropertyFault_closure(dynamic_cast<const vw1__VAppPropertyFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoAvailableIp_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.network? 
			get_closure_from_mor(Network(_obj.network)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VAppPropertyFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void NoClientCertificate_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoClientCertificate", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoClientCertificate_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoCompatibleDatastore_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoCompatibleDatastore", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoCompatibleDatastore_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoCompatibleHardAffinityHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoCompatibleHardAffinityHost", context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoCompatibleHardAffinityHost_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoCompatibleHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoCompatibleHost", context);
	update_member(update, "error", "LocalizedMethodFault[]", a2s_object(_obj.error, _obj.__sizeerror), context);
	update_member(update, "host", "HostSystem[]", a2s_object(_obj.host, _obj.__sizehost), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoCompatibleHost_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeerror)
				return new LocalizedMethodFault_closure(*_obj.error[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehost)
				return new HostSystem_closure(_obj.host[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VimFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void NoCompatibleHostWithAccessToDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoCompatibleHostWithAccessToDevice", context);
	update("Base", "NoCompatibleHost", context);
	NoCompatibleHost_closure(dynamic_cast<const vw1__NoCompatibleHost&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoCompatibleHostWithAccessToDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoCompatibleSoftAffinityHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoCompatibleSoftAffinityHost", context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoCompatibleSoftAffinityHost_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoConnectedDatastore_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoConnectedDatastore", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoConnectedDatastore_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoDiskFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoDiskFound", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoDiskFound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoDiskSpace_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoDiskSpace", context);
	update_member(update, "datastore", "xsd:string", basic2str(_obj.datastore), context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoDiskSpace_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoDisksToCustomize_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoDisksToCustomize", context);
	update("Base", "CustomizationFault", context);
	CustomizationFault_closure(dynamic_cast<const vw1__CustomizationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoDisksToCustomize_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoGateway_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoGateway", context);
	update("Base", "HostConfigFault", context);
	HostConfigFault_closure(dynamic_cast<const vw1__HostConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoGateway_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoGuestHeartbeat_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoGuestHeartbeat", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoGuestHeartbeat_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoHost", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "HostConnectFault", context);
	HostConnectFault_closure(dynamic_cast<const vw1__HostConnectFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoHost_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoHostSuitableForFtSecondary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoHostSuitableForFtSecondary", context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoHostSuitableForFtSecondary_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmFaultToleranceIssue_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void NoLicenseServerConfigured_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoLicenseServerConfigured", context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoLicenseServerConfigured_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoPeerHostFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoPeerHostFound", context);
	update("Base", "HostPowerOpFailed", context);
	HostPowerOpFailed_closure(dynamic_cast<const vw1__HostPowerOpFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoPeerHostFound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoPermission_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoPermission", context);
	update_member(update, "object", "ManagedObjectReference", handle_obj_ptr(_obj.object), context);
	update_member(update, "privilegeId", "xsd:string", basic2str(_obj.privilegeId), context);
	update("Base", "SecurityError", context);
	SecurityError_closure(dynamic_cast<const vw1__SecurityError&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoPermission_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.object)
			return new ManagedObjectReference_closure(*_obj.object);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return SecurityError_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void NoPermissionOnAD_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoPermissionOnAD", context);
	update("Base", "ActiveDirectoryFault", context);
	ActiveDirectoryFault_closure(dynamic_cast<const vw1__ActiveDirectoryFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoPermissionOnAD_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoPermissionOnHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoPermissionOnHost", context);
	update("Base", "HostConnectFault", context);
	HostConnectFault_closure(dynamic_cast<const vw1__HostConnectFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoPermissionOnHost_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoPermissionOnNasVolume_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoPermissionOnNasVolume", context);
	update_member(update, "userName", "xsd:string", basic2str(_obj.userName), context);
	update("Base", "NasConfigFault", context);
	NasConfigFault_closure(dynamic_cast<const vw1__NasConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoPermissionOnNasVolume_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoSubjectName_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoSubjectName", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoSubjectName_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoVcManagedIpConfigured_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoVcManagedIpConfigured", context);
	update("Base", "VAppPropertyFault", context);
	VAppPropertyFault_closure(dynamic_cast<const vw1__VAppPropertyFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoVcManagedIpConfigured_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoVirtualNic_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoVirtualNic", context);
	update("Base", "HostConfigFault", context);
	HostConfigFault_closure(dynamic_cast<const vw1__HostConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoVirtualNic_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NoVmInVApp_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NoVmInVApp", context);
	update("Base", "VAppConfigFault", context);
	VAppConfigFault_closure(dynamic_cast<const vw1__VAppConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NoVmInVApp_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NonADUserRequired_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NonADUserRequired", context);
	update("Base", "ActiveDirectoryFault", context);
	ActiveDirectoryFault_closure(dynamic_cast<const vw1__ActiveDirectoryFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NonADUserRequired_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NonHomeRDMVMotionNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NonHomeRDMVMotionNotSupported", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update("Base", "MigrationFeatureNotSupported", context);
	MigrationFeatureNotSupported_closure(dynamic_cast<const vw1__MigrationFeatureNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NonHomeRDMVMotionNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NonPersistentDisksNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NonPersistentDisksNotSupported", context);
	update("Base", "DeviceNotSupported", context);
	DeviceNotSupported_closure(dynamic_cast<const vw1__DeviceNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NonPersistentDisksNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NotADirectory_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotADirectory", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotADirectory_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NotAFile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotAFile", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotAFile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NotAuthenticated_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotAuthenticated", context);
	update("Base", "NoPermission", context);
	NoPermission_closure(dynamic_cast<const vw1__NoPermission&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotAuthenticated_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NotEnoughCpus_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotEnoughCpus", context);
	update_member(update, "numCpuDest", "xsd:int", basic2str(_obj.numCpuDest), context);
	update_member(update, "numCpuVm", "xsd:int", basic2str(_obj.numCpuVm), context);
	update("Base", "VirtualHardwareCompatibilityIssue", context);
	VirtualHardwareCompatibilityIssue_closure(dynamic_cast<const vw1__VirtualHardwareCompatibilityIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotEnoughCpus_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NotEnoughLicenses_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotEnoughLicenses", context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotEnoughLicenses_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NotEnoughLogicalCpus_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotEnoughLogicalCpus", context);
	update_member_with_version(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context, "2.5");
	update("Base", "NotEnoughCpus", context);
	NotEnoughCpus_closure(dynamic_cast<const vw1__NotEnoughCpus&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotEnoughLogicalCpus_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return NotEnoughCpus_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void NotFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotFound", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotFound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NotImplemented_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotImplemented", context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotImplemented_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotSupported", context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NotSupportedDeviceForFT_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotSupportedDeviceForFT", context);
	update_member(update, "deviceLabel", "xsd:string", basic2str(_obj.deviceLabel), context);
	update_member(update, "deviceType", "xsd:string", basic2str(_obj.deviceType), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotSupportedDeviceForFT_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	case 4:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmFaultToleranceIssue_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void NotSupportedHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotSupportedHost", context);
	update_member(update, "productName", "xsd:string", basic2str(_obj.productName), context);
	update_member(update, "productVersion", "xsd:string", basic2str(_obj.productVersion), context);
	update("Base", "HostConnectFault", context);
	HostConnectFault_closure(dynamic_cast<const vw1__HostConnectFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotSupportedHost_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NotSupportedHostInCluster_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotSupportedHostInCluster", context);
	update("Base", "NotSupportedHost", context);
	NotSupportedHost_closure(dynamic_cast<const vw1__NotSupportedHost&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotSupportedHostInCluster_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NotSupportedHostInDvs_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotSupportedHostInDvs", context);
	update_member(update, "switchProductSpec", "DistributedVirtualSwitchProductSpec", handle_obj_ptr(_obj.switchProductSpec), context);
	update("Base", "NotSupportedHost", context);
	NotSupportedHost_closure(dynamic_cast<const vw1__NotSupportedHost&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotSupportedHostInDvs_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.switchProductSpec)
			return new DistributedVirtualSwitchProductSpec_closure(*_obj.switchProductSpec);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return NotSupportedHost_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void NotSupportedHostInHACluster_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotSupportedHostInHACluster", context);
	update_member(update, "build", "xsd:string", basic2str(_obj.build), context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update("Base", "NotSupportedHost", context);
	NotSupportedHost_closure(dynamic_cast<const vw1__NotSupportedHost&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotSupportedHostInHACluster_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NotUserConfigurableProperty_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NotUserConfigurableProperty", context);
	update("Base", "VAppPropertyFault", context);
	VAppPropertyFault_closure(dynamic_cast<const vw1__VAppPropertyFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NotUserConfigurableProperty_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NumVirtualCoresPerSocketNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NumVirtualCoresPerSocketNotSupported", context);
	update_member(update, "maxSupportedCoresPerSocketDest", "xsd:int", basic2str(_obj.maxSupportedCoresPerSocketDest), context);
	update_member(update, "numCoresPerSocketVm", "xsd:int", basic2str(_obj.numCoresPerSocketVm), context);
	update("Base", "VirtualHardwareCompatibilityIssue", context);
	VirtualHardwareCompatibilityIssue_closure(dynamic_cast<const vw1__VirtualHardwareCompatibilityIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NumVirtualCoresPerSocketNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NumVirtualCpusExceedsLimit_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NumVirtualCpusExceedsLimit", context);
	update_member(update, "maxSupportedVcpus", "xsd:int", basic2str(_obj.maxSupportedVcpus), context);
	update("Base", "InsufficientResourcesFault", context);
	InsufficientResourcesFault_closure(dynamic_cast<const vw1__InsufficientResourcesFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NumVirtualCpusExceedsLimit_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NumVirtualCpusIncompatible_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NumVirtualCpusIncompatible", context);
	update_member(update, "numCpu", "xsd:int", basic2str(_obj.numCpu), context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NumVirtualCpusIncompatible_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void NumVirtualCpusNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "NumVirtualCpusNotSupported", context);
	update_member(update, "maxSupportedVcpusDest", "xsd:int", basic2str(_obj.maxSupportedVcpusDest), context);
	update_member(update, "numCpuVm", "xsd:int", basic2str(_obj.numCpuVm), context);
	update("Base", "VirtualHardwareCompatibilityIssue", context);
	VirtualHardwareCompatibilityIssue_closure(dynamic_cast<const vw1__VirtualHardwareCompatibilityIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* NumVirtualCpusNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OperationDisabledByGuest_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OperationDisabledByGuest", context);
	update("Base", "GuestOperationsFault", context);
	GuestOperationsFault_closure(dynamic_cast<const vw1__GuestOperationsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OperationDisabledByGuest_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OperationDisallowedOnHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OperationDisallowedOnHost", context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OperationDisallowedOnHost_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OperationNotSupportedByGuest_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OperationNotSupportedByGuest", context);
	update("Base", "GuestOperationsFault", context);
	GuestOperationsFault_closure(dynamic_cast<const vw1__GuestOperationsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OperationNotSupportedByGuest_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OutOfBounds_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OutOfBounds", context);
	update_member(update, "argumentName", "xsd:string", basic2str(_obj.argumentName), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OutOfBounds_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfAttribute_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfAttribute", context);
	update_member(update, "attributeName", "xsd:string", basic2str(_obj.attributeName), context);
	update_member(update, "elementName", "xsd:string", basic2str(_obj.elementName), context);
	update("Base", "OvfInvalidPackage", context);
	OvfInvalidPackage_closure(dynamic_cast<const vw1__OvfInvalidPackage&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfAttribute_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfConnectedDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfConnectedDevice", context);
	update("Base", "OvfHardwareExport", context);
	OvfHardwareExport_closure(dynamic_cast<const vw1__OvfHardwareExport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfConnectedDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfConnectedDeviceFloppy_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfConnectedDeviceFloppy", context);
	update_member(update, "filename", "xsd:string", basic2str(_obj.filename), context);
	update("Base", "OvfConnectedDevice", context);
	OvfConnectedDevice_closure(dynamic_cast<const vw1__OvfConnectedDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfConnectedDeviceFloppy_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfConnectedDeviceIso_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfConnectedDeviceIso", context);
	update_member(update, "filename", "xsd:string", basic2str(_obj.filename), context);
	update("Base", "OvfConnectedDevice", context);
	OvfConnectedDevice_closure(dynamic_cast<const vw1__OvfConnectedDevice&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfConnectedDeviceIso_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfConstraint_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfConstraint", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "OvfInvalidPackage", context);
	OvfInvalidPackage_closure(dynamic_cast<const vw1__OvfInvalidPackage&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfConstraint_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfConsumerCallbackFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfConsumerCallbackFault", context);
	update_member(update, "extensionKey", "xsd:string", basic2str(_obj.extensionKey), context);
	update_member(update, "extensionName", "xsd:string", basic2str(_obj.extensionName), context);
	update("Base", "OvfFault", context);
	OvfFault_closure(dynamic_cast<const vw1__OvfFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfConsumerCallbackFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfConsumerCommunicationError_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfConsumerCommunicationError", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update("Base", "OvfConsumerCallbackFault", context);
	OvfConsumerCallbackFault_closure(dynamic_cast<const vw1__OvfConsumerCallbackFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfConsumerCommunicationError_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfConsumerFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfConsumerFault", context);
	update_member(update, "errorKey", "xsd:string", basic2str(_obj.errorKey), context);
	update_member(update, "message", "xsd:string", basic2str(_obj.message), context);
	update_member(update, "params", "KeyValue[]", a2s_object(_obj.params, _obj.__sizeparams), context);
	update("Base", "OvfConsumerCallbackFault", context);
	OvfConsumerCallbackFault_closure(dynamic_cast<const vw1__OvfConsumerCallbackFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfConsumerFault_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeparams)
				return new KeyValue_closure(*_obj.params[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return OvfConsumerCallbackFault_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void OvfConsumerInvalidSection_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfConsumerInvalidSection", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "lineNumber", "xsd:int", basic2str(_obj.lineNumber), context);
	update("Base", "OvfConsumerCallbackFault", context);
	OvfConsumerCallbackFault_closure(dynamic_cast<const vw1__OvfConsumerCallbackFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfConsumerInvalidSection_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfConsumerPowerOnFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfConsumerPowerOnFault", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update_member(update, "extensionKey", "xsd:string", basic2str(_obj.extensionKey), context);
	update_member(update, "extensionName", "xsd:string", basic2str(_obj.extensionName), context);
	update("Base", "InvalidState", context);
	InvalidState_closure(dynamic_cast<const vw1__InvalidState&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfConsumerPowerOnFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfConsumerUndeclaredSection_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfConsumerUndeclaredSection", context);
	update_member(update, "qualifiedSectionType", "xsd:string", basic2str(_obj.qualifiedSectionType), context);
	update("Base", "OvfConsumerCallbackFault", context);
	OvfConsumerCallbackFault_closure(dynamic_cast<const vw1__OvfConsumerCallbackFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfConsumerUndeclaredSection_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfConsumerUndefinedPrefix_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfConsumerUndefinedPrefix", context);
	update_member(update, "prefix", "xsd:string", basic2str(_obj.prefix), context);
	update("Base", "OvfConsumerCallbackFault", context);
	OvfConsumerCallbackFault_closure(dynamic_cast<const vw1__OvfConsumerCallbackFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfConsumerUndefinedPrefix_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfConsumerValidationFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfConsumerValidationFault", context);
	update_member(update, "extensionKey", "xsd:string", basic2str(_obj.extensionKey), context);
	update_member(update, "extensionName", "xsd:string", basic2str(_obj.extensionName), context);
	update_member(update, "message", "xsd:string", basic2str(_obj.message), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfConsumerValidationFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfCpuCompatibility_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfCpuCompatibility", context);
	update_member(update, "desiredRegisterValue", "xsd:string", basic2str(_obj.desiredRegisterValue), context);
	update_member(update, "level", "xsd:int", basic2str(_obj.level), context);
	update_member(update, "registerName", "xsd:string", basic2str(_obj.registerName), context);
	update_member(update, "registerValue", "xsd:string", basic2str(_obj.registerValue), context);
	update("Base", "OvfImport", context);
	OvfImport_closure(dynamic_cast<const vw1__OvfImport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfCpuCompatibility_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfCpuCompatibilityCheckNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfCpuCompatibilityCheckNotSupported", context);
	update("Base", "OvfImport", context);
	OvfImport_closure(dynamic_cast<const vw1__OvfImport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfCpuCompatibilityCheckNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfDiskMappingNotFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfDiskMappingNotFound", context);
	update_member(update, "diskName", "xsd:string", basic2str(_obj.diskName), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "OvfSystemFault", context);
	OvfSystemFault_closure(dynamic_cast<const vw1__OvfSystemFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfDiskMappingNotFound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfDiskOrderConstraint_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfDiskOrderConstraint", context);
	update("Base", "OvfConstraint", context);
	OvfConstraint_closure(dynamic_cast<const vw1__OvfConstraint&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfDiskOrderConstraint_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfDuplicateElement_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfDuplicateElement", context);
	update("Base", "OvfElement", context);
	OvfElement_closure(dynamic_cast<const vw1__OvfElement&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfDuplicateElement_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfDuplicatedElementBoundary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfDuplicatedElementBoundary", context);
	update_member(update, "boundary", "xsd:string", basic2str(_obj.boundary), context);
	update("Base", "OvfElement", context);
	OvfElement_closure(dynamic_cast<const vw1__OvfElement&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfDuplicatedElementBoundary_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfDuplicatedPropertyIdExport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfDuplicatedPropertyIdExport", context);
	update_member(update, "fqid", "xsd:string", basic2str(_obj.fqid), context);
	update("Base", "OvfExport", context);
	OvfExport_closure(dynamic_cast<const vw1__OvfExport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfDuplicatedPropertyIdExport_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfDuplicatedPropertyIdImport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfDuplicatedPropertyIdImport", context);
	update("Base", "OvfExport", context);
	OvfExport_closure(dynamic_cast<const vw1__OvfExport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfDuplicatedPropertyIdImport_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfElement_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfElement", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "OvfInvalidPackage", context);
	OvfInvalidPackage_closure(dynamic_cast<const vw1__OvfInvalidPackage&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfElement_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfElementInvalidValue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfElementInvalidValue", context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "OvfElement", context);
	OvfElement_closure(dynamic_cast<const vw1__OvfElement&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfElementInvalidValue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfExport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfExport", context);
	update("Base", "OvfFault", context);
	OvfFault_closure(dynamic_cast<const vw1__OvfFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfExport_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfExportFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfExportFailed", context);
	update("Base", "OvfExport", context);
	OvfExport_closure(dynamic_cast<const vw1__OvfExport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfExportFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfHardwareCheck_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfHardwareCheck", context);
	update("Base", "OvfImport", context);
	OvfImport_closure(dynamic_cast<const vw1__OvfImport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfHardwareCheck_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfHardwareExport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfHardwareExport", context);
	update_member(update, "device", "VirtualDevice", handle_obj_ptr(_obj.device), context);
	update_member(update, "vmPath", "xsd:string", basic2str(_obj.vmPath), context);
	update("Base", "OvfExport", context);
	OvfExport_closure(dynamic_cast<const vw1__OvfExport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfHardwareExport_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.device)
			return new VirtualDevice_closure(*_obj.device);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return OvfExport_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void OvfHostResourceConstraint_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfHostResourceConstraint", context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "OvfConstraint", context);
	OvfConstraint_closure(dynamic_cast<const vw1__OvfConstraint&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfHostResourceConstraint_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfHostValueNotParsed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfHostValueNotParsed", context);
	update_member(update, "property", "xsd:string", basic2str(_obj.property), context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "OvfSystemFault", context);
	OvfSystemFault_closure(dynamic_cast<const vw1__OvfSystemFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfHostValueNotParsed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfImport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfImport", context);
	update("Base", "OvfFault", context);
	OvfFault_closure(dynamic_cast<const vw1__OvfFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfImport_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfImportFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfImportFailed", context);
	update("Base", "OvfImport", context);
	OvfImport_closure(dynamic_cast<const vw1__OvfImport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfImportFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfInternalError_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfInternalError", context);
	update("Base", "OvfSystemFault", context);
	OvfSystemFault_closure(dynamic_cast<const vw1__OvfSystemFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfInternalError_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfInvalidPackage_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfInvalidPackage", context);
	update_member(update, "lineNumber", "xsd:int", basic2str(_obj.lineNumber), context);
	update("Base", "OvfFault", context);
	OvfFault_closure(dynamic_cast<const vw1__OvfFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfInvalidPackage_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfInvalidValue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfInvalidValue", context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "OvfAttribute", context);
	OvfAttribute_closure(dynamic_cast<const vw1__OvfAttribute&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfInvalidValue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfInvalidValueConfiguration_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfInvalidValueConfiguration", context);
	update("Base", "OvfInvalidValue", context);
	OvfInvalidValue_closure(dynamic_cast<const vw1__OvfInvalidValue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfInvalidValueConfiguration_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfInvalidValueEmpty_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfInvalidValueEmpty", context);
	update("Base", "OvfInvalidValue", context);
	OvfInvalidValue_closure(dynamic_cast<const vw1__OvfInvalidValue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfInvalidValueEmpty_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfInvalidValueFormatMalformed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfInvalidValueFormatMalformed", context);
	update("Base", "OvfInvalidValue", context);
	OvfInvalidValue_closure(dynamic_cast<const vw1__OvfInvalidValue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfInvalidValueFormatMalformed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfInvalidValueReference_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfInvalidValueReference", context);
	update("Base", "OvfInvalidValue", context);
	OvfInvalidValue_closure(dynamic_cast<const vw1__OvfInvalidValue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfInvalidValueReference_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfInvalidVmName_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfInvalidVmName", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "OvfUnsupportedPackage", context);
	OvfUnsupportedPackage_closure(dynamic_cast<const vw1__OvfUnsupportedPackage&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfInvalidVmName_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfMappedOsId_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfMappedOsId", context);
	update_member(update, "ovfDescription", "xsd:string", basic2str(_obj.ovfDescription), context);
	update_member(update, "ovfId", "xsd:int", basic2str(_obj.ovfId), context);
	update_member(update, "targetDescription", "xsd:string", basic2str(_obj.targetDescription), context);
	update("Base", "OvfImport", context);
	OvfImport_closure(dynamic_cast<const vw1__OvfImport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfMappedOsId_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfMissingAttribute_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfMissingAttribute", context);
	update("Base", "OvfAttribute", context);
	OvfAttribute_closure(dynamic_cast<const vw1__OvfAttribute&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfMissingAttribute_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfMissingElement_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfMissingElement", context);
	update("Base", "OvfElement", context);
	OvfElement_closure(dynamic_cast<const vw1__OvfElement&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfMissingElement_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfMissingElementNormalBoundary_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfMissingElementNormalBoundary", context);
	update_member(update, "boundary", "xsd:string", basic2str(_obj.boundary), context);
	update("Base", "OvfMissingElement", context);
	OvfMissingElement_closure(dynamic_cast<const vw1__OvfMissingElement&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfMissingElementNormalBoundary_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfMissingHardware_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfMissingHardware", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "resourceType", "xsd:int", basic2str(_obj.resourceType), context);
	update("Base", "OvfImport", context);
	OvfImport_closure(dynamic_cast<const vw1__OvfImport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfMissingHardware_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfNoHostNic_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfNoHostNic", context);
	update("Base", "OvfUnsupportedPackage", context);
	OvfUnsupportedPackage_closure(dynamic_cast<const vw1__OvfUnsupportedPackage&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfNoHostNic_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfNoSpaceOnController_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfNoSpaceOnController", context);
	update_member(update, "parent", "xsd:string", basic2str(_obj.parent), context);
	update("Base", "OvfUnsupportedElement", context);
	OvfUnsupportedElement_closure(dynamic_cast<const vw1__OvfUnsupportedElement&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfNoSpaceOnController_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfNoSupportedHardwareFamily_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfNoSupportedHardwareFamily", context);
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update("Base", "OvfUnsupportedPackage", context);
	OvfUnsupportedPackage_closure(dynamic_cast<const vw1__OvfUnsupportedPackage&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfNoSupportedHardwareFamily_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfProperty_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfProperty", context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "OvfInvalidPackage", context);
	OvfInvalidPackage_closure(dynamic_cast<const vw1__OvfInvalidPackage&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfProperty_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfPropertyExport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfPropertyExport", context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "OvfExport", context);
	OvfExport_closure(dynamic_cast<const vw1__OvfExport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfPropertyExport_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfPropertyNetwork_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfPropertyNetwork", context);
	update("Base", "OvfProperty", context);
	OvfProperty_closure(dynamic_cast<const vw1__OvfProperty&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfPropertyNetwork_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfPropertyNetworkExport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfPropertyNetworkExport", context);
	update_member(update, "network", "xsd:string", basic2str(_obj.network), context);
	update("Base", "OvfExport", context);
	OvfExport_closure(dynamic_cast<const vw1__OvfExport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfPropertyNetworkExport_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfPropertyQualifier_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfPropertyQualifier", context);
	update_member(update, "qualifier", "xsd:string", basic2str(_obj.qualifier), context);
	update("Base", "OvfProperty", context);
	OvfProperty_closure(dynamic_cast<const vw1__OvfProperty&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfPropertyQualifier_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfPropertyQualifierDuplicate_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfPropertyQualifierDuplicate", context);
	update_member(update, "qualifier", "xsd:string", basic2str(_obj.qualifier), context);
	update("Base", "OvfProperty", context);
	OvfProperty_closure(dynamic_cast<const vw1__OvfProperty&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfPropertyQualifierDuplicate_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfPropertyQualifierIgnored_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfPropertyQualifierIgnored", context);
	update_member(update, "qualifier", "xsd:string", basic2str(_obj.qualifier), context);
	update("Base", "OvfProperty", context);
	OvfProperty_closure(dynamic_cast<const vw1__OvfProperty&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfPropertyQualifierIgnored_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfPropertyType_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfPropertyType", context);
	update("Base", "OvfProperty", context);
	OvfProperty_closure(dynamic_cast<const vw1__OvfProperty&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfPropertyType_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfPropertyValue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfPropertyValue", context);
	update("Base", "OvfProperty", context);
	OvfProperty_closure(dynamic_cast<const vw1__OvfProperty&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfPropertyValue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfSystemFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfSystemFault", context);
	update("Base", "OvfFault", context);
	OvfFault_closure(dynamic_cast<const vw1__OvfFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfSystemFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfToXmlUnsupportedElement_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfToXmlUnsupportedElement", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "OvfSystemFault", context);
	OvfSystemFault_closure(dynamic_cast<const vw1__OvfSystemFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfToXmlUnsupportedElement_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnableToExportDisk_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnableToExportDisk", context);
	update_member(update, "diskName", "xsd:string", basic2str(_obj.diskName), context);
	update("Base", "OvfHardwareExport", context);
	OvfHardwareExport_closure(dynamic_cast<const vw1__OvfHardwareExport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnableToExportDisk_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnexpectedElement_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnexpectedElement", context);
	update("Base", "OvfElement", context);
	OvfElement_closure(dynamic_cast<const vw1__OvfElement&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnexpectedElement_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnknownDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnknownDevice", context);
	update_member(update, "device", "VirtualDevice", handle_obj_ptr(_obj.device), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "OvfSystemFault", context);
	OvfSystemFault_closure(dynamic_cast<const vw1__OvfSystemFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnknownDevice_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.device)
			return new VirtualDevice_closure(*_obj.device);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return OvfSystemFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void OvfUnknownDeviceBacking_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnknownDeviceBacking", context);
	update_member(update, "backing", "VirtualDeviceBackingInfo", handle_obj_ptr(_obj.backing), context);
	update("Base", "OvfHardwareExport", context);
	OvfHardwareExport_closure(dynamic_cast<const vw1__OvfHardwareExport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnknownDeviceBacking_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.backing)
			return new VirtualDeviceBackingInfo_closure(*_obj.backing);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return OvfHardwareExport_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void OvfUnknownEntity_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnknownEntity", context);
	update_member(update, "lineNumber", "xsd:int", basic2str(_obj.lineNumber), context);
	update("Base", "OvfSystemFault", context);
	OvfSystemFault_closure(dynamic_cast<const vw1__OvfSystemFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnknownEntity_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnsupportedAttribute_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnsupportedAttribute", context);
	update_member(update, "attributeName", "xsd:string", basic2str(_obj.attributeName), context);
	update_member(update, "elementName", "xsd:string", basic2str(_obj.elementName), context);
	update("Base", "OvfUnsupportedPackage", context);
	OvfUnsupportedPackage_closure(dynamic_cast<const vw1__OvfUnsupportedPackage&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnsupportedAttribute_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnsupportedAttributeValue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnsupportedAttributeValue", context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "OvfUnsupportedAttribute", context);
	OvfUnsupportedAttribute_closure(dynamic_cast<const vw1__OvfUnsupportedAttribute&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnsupportedAttributeValue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnsupportedDeviceBackingInfo_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnsupportedDeviceBackingInfo", context);
	update_member(update, "backingName", "xsd:string", basic2str(_obj.backingName), context);
	update_member(update, "deviceName", "xsd:string", basic2str(_obj.deviceName), context);
	update_member(update, "elementName", "xsd:string", basic2str(_obj.elementName), context);
	update_member(update, "instanceId", "xsd:string", basic2str(_obj.instanceId), context);
	update("Base", "OvfSystemFault", context);
	OvfSystemFault_closure(dynamic_cast<const vw1__OvfSystemFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnsupportedDeviceBackingInfo_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnsupportedDeviceBackingOption_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnsupportedDeviceBackingOption", context);
	update_member(update, "backingName", "xsd:string", basic2str(_obj.backingName), context);
	update_member(update, "deviceName", "xsd:string", basic2str(_obj.deviceName), context);
	update_member(update, "elementName", "xsd:string", basic2str(_obj.elementName), context);
	update_member(update, "instanceId", "xsd:string", basic2str(_obj.instanceId), context);
	update("Base", "OvfSystemFault", context);
	OvfSystemFault_closure(dynamic_cast<const vw1__OvfSystemFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnsupportedDeviceBackingOption_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnsupportedDeviceExport_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnsupportedDeviceExport", context);
	update("Base", "OvfHardwareExport", context);
	OvfHardwareExport_closure(dynamic_cast<const vw1__OvfHardwareExport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnsupportedDeviceExport_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnsupportedDiskProvisioning_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnsupportedDiskProvisioning", context);
	update_member(update, "diskProvisioning", "xsd:string", basic2str(_obj.diskProvisioning), context);
	update_member(update, "supportedDiskProvisioning", "xsd:string", basic2str(_obj.supportedDiskProvisioning), context);
	update("Base", "OvfImport", context);
	OvfImport_closure(dynamic_cast<const vw1__OvfImport&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnsupportedDiskProvisioning_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnsupportedElement_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnsupportedElement", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "OvfUnsupportedPackage", context);
	OvfUnsupportedPackage_closure(dynamic_cast<const vw1__OvfUnsupportedPackage&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnsupportedElement_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnsupportedElementValue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnsupportedElementValue", context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "OvfUnsupportedElement", context);
	OvfUnsupportedElement_closure(dynamic_cast<const vw1__OvfUnsupportedElement&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnsupportedElementValue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnsupportedPackage_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnsupportedPackage", context);
	update_member(update, "lineNumber", "xsd:int", basic2str(_obj.lineNumber), context);
	update("Base", "OvfFault", context);
	OvfFault_closure(dynamic_cast<const vw1__OvfFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnsupportedPackage_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnsupportedSection_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnsupportedSection", context);
	update_member(update, "info", "xsd:string", basic2str(_obj.info), context);
	update("Base", "OvfUnsupportedElement", context);
	OvfUnsupportedElement_closure(dynamic_cast<const vw1__OvfUnsupportedElement&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnsupportedSection_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnsupportedSubType_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnsupportedSubType", context);
	update_member(update, "deviceSubType", "xsd:string", basic2str(_obj.deviceSubType), context);
	update_member(update, "deviceType", "xsd:int", basic2str(_obj.deviceType), context);
	update_member(update, "elementName", "xsd:string", basic2str(_obj.elementName), context);
	update_member(update, "instanceId", "xsd:string", basic2str(_obj.instanceId), context);
	update("Base", "OvfUnsupportedPackage", context);
	OvfUnsupportedPackage_closure(dynamic_cast<const vw1__OvfUnsupportedPackage&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnsupportedSubType_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfUnsupportedType_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfUnsupportedType", context);
	update_member(update, "deviceType", "xsd:int", basic2str(_obj.deviceType), context);
	update_member(update, "instanceId", "xsd:string", basic2str(_obj.instanceId), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update("Base", "OvfUnsupportedPackage", context);
	OvfUnsupportedPackage_closure(dynamic_cast<const vw1__OvfUnsupportedPackage&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfUnsupportedType_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfWrongElement_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfWrongElement", context);
	update("Base", "OvfElement", context);
	OvfElement_closure(dynamic_cast<const vw1__OvfElement&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfWrongElement_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfWrongNamespace_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfWrongNamespace", context);
	update_member(update, "namespaceName", "xsd:string", basic2str(_obj.namespaceName), context);
	update("Base", "OvfInvalidPackage", context);
	OvfInvalidPackage_closure(dynamic_cast<const vw1__OvfInvalidPackage&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfWrongNamespace_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void OvfXmlFormat_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfXmlFormat", context);
	update_member(update, "description", "xsd:string", basic2str(_obj.description), context);
	update("Base", "OvfInvalidPackage", context);
	OvfInvalidPackage_closure(dynamic_cast<const vw1__OvfInvalidPackage&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* OvfXmlFormat_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PatchAlreadyInstalled_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PatchAlreadyInstalled", context);
	update("Base", "PatchNotApplicable", context);
	PatchNotApplicable_closure(dynamic_cast<const vw1__PatchNotApplicable&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PatchAlreadyInstalled_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PatchBinariesNotFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PatchBinariesNotFound", context);
	update_member(update, "binary", "xsd:string[]", a2s_basic(*_obj.binary, _obj.__sizebinary), context);
	update_member(update, "patchID", "xsd:string", basic2str(_obj.patchID), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PatchBinariesNotFound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PatchInstallFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PatchInstallFailed", context);
	update_member(update, "rolledBack", "xsd:boolean", basic2str(_obj.rolledBack), context);
	update("Base", "PlatformConfigFault", context);
	PlatformConfigFault_closure(dynamic_cast<const vw1__PlatformConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PatchInstallFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PatchIntegrityError_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PatchIntegrityError", context);
	update("Base", "PlatformConfigFault", context);
	PlatformConfigFault_closure(dynamic_cast<const vw1__PlatformConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PatchIntegrityError_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PatchMetadataCorrupted_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PatchMetadataCorrupted", context);
	update("Base", "PatchMetadataInvalid", context);
	PatchMetadataInvalid_closure(dynamic_cast<const vw1__PatchMetadataInvalid&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PatchMetadataCorrupted_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PatchMetadataInvalid_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PatchMetadataInvalid", context);
	update_member(update, "metaData", "xsd:string[]", a2s_basic(*_obj.metaData, _obj.__sizemetaData), context);
	update_member(update, "patchID", "xsd:string", basic2str(_obj.patchID), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PatchMetadataInvalid_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PatchMetadataNotFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PatchMetadataNotFound", context);
	update("Base", "PatchMetadataInvalid", context);
	PatchMetadataInvalid_closure(dynamic_cast<const vw1__PatchMetadataInvalid&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PatchMetadataNotFound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PatchMissingDependencies_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PatchMissingDependencies", context);
	update_member(update, "prerequisiteLib", "xsd:string[]", a2s_basic(*_obj.prerequisiteLib, _obj.__sizeprerequisiteLib), context);
	update_member(update, "prerequisitePatch", "xsd:string[]", a2s_basic(*_obj.prerequisitePatch, _obj.__sizeprerequisitePatch), context);
	update("Base", "PatchNotApplicable", context);
	PatchNotApplicable_closure(dynamic_cast<const vw1__PatchNotApplicable&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PatchMissingDependencies_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PatchNotApplicable_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PatchNotApplicable", context);
	update_member(update, "patchID", "xsd:string", basic2str(_obj.patchID), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PatchNotApplicable_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PatchSuperseded_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PatchSuperseded", context);
	update_member(update, "supersede", "xsd:string[]", a2s_basic(*_obj.supersede, _obj.__sizesupersede), context);
	update("Base", "PatchNotApplicable", context);
	PatchNotApplicable_closure(dynamic_cast<const vw1__PatchNotApplicable&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PatchSuperseded_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PhysCompatRDMNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PhysCompatRDMNotSupported", context);
	update("Base", "RDMNotSupported", context);
	RDMNotSupported_closure(dynamic_cast<const vw1__RDMNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PhysCompatRDMNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PlatformConfigFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PlatformConfigFault", context);
	update_member(update, "text", "xsd:string", basic2str(_obj.text), context);
	update("Base", "HostConfigFault", context);
	HostConfigFault_closure(dynamic_cast<const vw1__HostConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PlatformConfigFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void PowerOnFtSecondaryFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PowerOnFtSecondaryFailed", context);
	update_member(update, "hostErrors", "LocalizedMethodFault[]", a2s_object(_obj.hostErrors, _obj.__sizehostErrors), context);
	update_member(update, "hostSelectionBy", "FtIssuesOnHostHostSelectionType", handle_obj(_obj.hostSelectionBy), context);
	update_member(update, "rootCause", "LocalizedMethodFault", handle_obj_ptr(_obj.rootCause), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PowerOnFtSecondaryFailed_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizehostErrors)
				return new LocalizedMethodFault_closure(*_obj.hostErrors[i]);
			else
				return 0;
		}
	case 2:
		if (_obj.rootCause)
			return new LocalizedMethodFault_closure(*_obj.rootCause);
		else
			return 0;
	case 3:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmFaultToleranceIssue_closure(_obj).get_sub_closure(((prop_index - 5) << 16) + arr_index);
	}
	return 0;
}

void PowerOnFtSecondaryTimedout_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PowerOnFtSecondaryTimedout", context);
	update_member(update, "timeout", "xsd:int", basic2str(_obj.timeout), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "Timedout", context);
	Timedout_closure(dynamic_cast<const vw1__Timedout&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* PowerOnFtSecondaryTimedout_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return Timedout_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ProfileUpdateFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileUpdateFailed", context);
	update_member(update, "failure", "ProfileUpdateFailedUpdateFailure[]", a2s_object(_obj.failure, _obj.__sizefailure), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ProfileUpdateFailed_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizefailure)
				return new ProfileUpdateFailedUpdateFailure_closure(*_obj.failure[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VimFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void QuestionPending_closure::browse(pf_update update, void* context) const
{
	update("Begin", "QuestionPending", context);
	update_member(update, "text", "xsd:string", basic2str(_obj.text), context);
	update("Base", "InvalidState", context);
	InvalidState_closure(dynamic_cast<const vw1__InvalidState&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* QuestionPending_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void QuiesceDatastoreIOForHAFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "QuiesceDatastoreIOForHAFailed", context);
	update_member(update, "ds", "Datastore", handle_obj_ptr(_obj.ds), context);
	update_member(update, "dsName", "xsd:string", basic2str(_obj.dsName), context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update("Base", "ResourceInUse", context);
	ResourceInUse_closure(dynamic_cast<const vw1__ResourceInUse&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* QuiesceDatastoreIOForHAFailed_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.ds? 
			get_closure_from_mor(Datastore(_obj.ds)) : 0;
	case 2:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return ResourceInUse_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void RDMConversionNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RDMConversionNotSupported", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RDMConversionNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RDMNotPreserved_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RDMNotPreserved", context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RDMNotPreserved_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RDMNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RDMNotSupported", context);
	update("Base", "DeviceNotSupported", context);
	DeviceNotSupported_closure(dynamic_cast<const vw1__DeviceNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RDMNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RDMNotSupportedOnDatastore_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RDMNotSupportedOnDatastore", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update_member(update, "datastoreName", "xsd:string", basic2str(_obj.datastoreName), context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RDMNotSupportedOnDatastore_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmConfigFault_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void RDMPointsToInaccessibleDisk_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RDMPointsToInaccessibleDisk", context);
	update("Base", "CannotAccessVmDisk", context);
	CannotAccessVmDisk_closure(dynamic_cast<const vw1__CannotAccessVmDisk&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RDMPointsToInaccessibleDisk_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RawDiskNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RawDiskNotSupported", context);
	update("Base", "DeviceNotSupported", context);
	DeviceNotSupported_closure(dynamic_cast<const vw1__DeviceNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RawDiskNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ReadHostResourcePoolTreeFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ReadHostResourcePoolTreeFailed", context);
	update("Base", "HostConnectFault", context);
	HostConnectFault_closure(dynamic_cast<const vw1__HostConnectFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ReadHostResourcePoolTreeFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ReadOnlyDisksWithLegacyDestination_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ReadOnlyDisksWithLegacyDestination", context);
	update_member(update, "roDiskCount", "xsd:int", basic2str(_obj.roDiskCount), context);
	update_member(update, "timeoutDanger", "xsd:boolean", basic2str(_obj.timeoutDanger), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ReadOnlyDisksWithLegacyDestination_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RebootRequired_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RebootRequired", context);
	update_member(update, "patch", "xsd:string", basic2str(_obj.patch), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RebootRequired_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RecordReplayDisabled_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RecordReplayDisabled", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RecordReplayDisabled_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RemoteDeviceNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RemoteDeviceNotSupported", context);
	update("Base", "DeviceNotSupported", context);
	DeviceNotSupported_closure(dynamic_cast<const vw1__DeviceNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RemoteDeviceNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RemoveFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RemoveFailed", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RemoveFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ReplicationConfigFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ReplicationConfigFault", context);
	update("Base", "ReplicationFault", context);
	ReplicationFault_closure(dynamic_cast<const vw1__ReplicationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ReplicationConfigFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ReplicationDiskConfigFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ReplicationDiskConfigFault", context);
	update_member(update, "key", "xsd:int", basic2str(_obj.key), context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update_member(update, "vmRef", "VirtualMachine", handle_obj_ptr(_obj.vmRef), context);
	update("Base", "ReplicationConfigFault", context);
	ReplicationConfigFault_closure(dynamic_cast<const vw1__ReplicationConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ReplicationDiskConfigFault_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		return _obj.vmRef? 
			get_closure_from_mor(VirtualMachine(_obj.vmRef)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return ReplicationConfigFault_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void ReplicationFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ReplicationFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ReplicationFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ReplicationIncompatibleWithFT_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ReplicationIncompatibleWithFT", context);
	update("Base", "ReplicationFault", context);
	ReplicationFault_closure(dynamic_cast<const vw1__ReplicationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ReplicationIncompatibleWithFT_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ReplicationInvalidOptions_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ReplicationInvalidOptions", context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "options", "xsd:string", basic2str(_obj.options), context);
	update("Base", "ReplicationFault", context);
	ReplicationFault_closure(dynamic_cast<const vw1__ReplicationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ReplicationInvalidOptions_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return ReplicationFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ReplicationNotSupportedOnHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ReplicationNotSupportedOnHost", context);
	update("Base", "ReplicationFault", context);
	ReplicationFault_closure(dynamic_cast<const vw1__ReplicationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ReplicationNotSupportedOnHost_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ReplicationVmConfigFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ReplicationVmConfigFault", context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update_member(update, "vmRef", "VirtualMachine", handle_obj_ptr(_obj.vmRef), context);
	update("Base", "ReplicationConfigFault", context);
	ReplicationConfigFault_closure(dynamic_cast<const vw1__ReplicationConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ReplicationVmConfigFault_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return _obj.vmRef? 
			get_closure_from_mor(VirtualMachine(_obj.vmRef)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return ReplicationConfigFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void ReplicationVmFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ReplicationVmFault", context);
	update_member(update, "instanceId", "xsd:string", basic2str(_obj.instanceId), context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update_member(update, "state", "xsd:string", basic2str(_obj.state), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update("Base", "ReplicationFault", context);
	ReplicationFault_closure(dynamic_cast<const vw1__ReplicationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ReplicationVmFault_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 3:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return ReplicationFault_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void RequestCanceled_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RequestCanceled", context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RequestCanceled_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ResourceInUse_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourceInUse", context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourceInUse_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ResourceNotAvailable_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourceNotAvailable", context);
	update_member(update, "containerName", "xsd:string", basic2str(_obj.containerName), context);
	update_member(update, "containerType", "xsd:string", basic2str(_obj.containerType), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourceNotAvailable_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RestrictedVersion_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RestrictedVersion", context);
	update("Base", "SecurityError", context);
	SecurityError_closure(dynamic_cast<const vw1__SecurityError&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RestrictedVersion_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void RuleViolation_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RuleViolation", context);
	update_member_with_version(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context, "2.5");
	update_member_with_version(update, "rule", "ClusterRuleInfo", handle_obj_ptr(_obj.rule), context, "4.0");
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RuleViolation_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	case 1:
		if (_obj.rule)
			return new ClusterRuleInfo_closure(*_obj.rule);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmConfigFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void RuntimeFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "RuntimeFault", context);
	update("Base", "MethodFault", context);
	MethodFault_closure(dynamic_cast<const vw1__MethodFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* RuntimeFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SSLDisabledFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SSLDisabledFault", context);
	update("Base", "HostConnectFault", context);
	HostConnectFault_closure(dynamic_cast<const vw1__HostConnectFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SSLDisabledFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SSLVerifyFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SSLVerifyFault", context);
	update_member(update, "selfSigned", "xsd:boolean", basic2str(_obj.selfSigned), context);
	update_member(update, "thumbprint", "xsd:string", basic2str(_obj.thumbprint), context);
	update("Base", "HostConnectFault", context);
	HostConnectFault_closure(dynamic_cast<const vw1__HostConnectFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SSLVerifyFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SSPIChallenge_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SSPIChallenge", context);
	update_member(update, "base64Token", "xsd:string", basic2str(_obj.base64Token), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SSPIChallenge_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SecondaryVmAlreadyDisabled_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SecondaryVmAlreadyDisabled", context);
	update_member(update, "instanceUuid", "xsd:string", basic2str(_obj.instanceUuid), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SecondaryVmAlreadyDisabled_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SecondaryVmAlreadyEnabled_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SecondaryVmAlreadyEnabled", context);
	update_member(update, "instanceUuid", "xsd:string", basic2str(_obj.instanceUuid), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SecondaryVmAlreadyEnabled_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SecondaryVmAlreadyRegistered_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SecondaryVmAlreadyRegistered", context);
	update_member(update, "instanceUuid", "xsd:string", basic2str(_obj.instanceUuid), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SecondaryVmAlreadyRegistered_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SecondaryVmNotRegistered_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SecondaryVmNotRegistered", context);
	update_member(update, "instanceUuid", "xsd:string", basic2str(_obj.instanceUuid), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SecondaryVmNotRegistered_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SecurityError_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SecurityError", context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SecurityError_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SharedBusControllerNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SharedBusControllerNotSupported", context);
	update("Base", "DeviceNotSupported", context);
	DeviceNotSupported_closure(dynamic_cast<const vw1__DeviceNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SharedBusControllerNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SnapshotCloneNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SnapshotCloneNotSupported", context);
	update("Base", "SnapshotCopyNotSupported", context);
	SnapshotCopyNotSupported_closure(dynamic_cast<const vw1__SnapshotCopyNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SnapshotCloneNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SnapshotCopyNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SnapshotCopyNotSupported", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SnapshotCopyNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SnapshotDisabled_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SnapshotDisabled", context);
	update("Base", "SnapshotFault", context);
	SnapshotFault_closure(dynamic_cast<const vw1__SnapshotFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SnapshotDisabled_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SnapshotFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SnapshotFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SnapshotFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SnapshotIncompatibleDeviceInVm_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SnapshotIncompatibleDeviceInVm", context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update("Base", "SnapshotFault", context);
	SnapshotFault_closure(dynamic_cast<const vw1__SnapshotFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SnapshotIncompatibleDeviceInVm_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return SnapshotFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void SnapshotLocked_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SnapshotLocked", context);
	update("Base", "SnapshotFault", context);
	SnapshotFault_closure(dynamic_cast<const vw1__SnapshotFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SnapshotLocked_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SnapshotMoveFromNonHomeNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SnapshotMoveFromNonHomeNotSupported", context);
	update("Base", "SnapshotCopyNotSupported", context);
	SnapshotCopyNotSupported_closure(dynamic_cast<const vw1__SnapshotCopyNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SnapshotMoveFromNonHomeNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SnapshotMoveNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SnapshotMoveNotSupported", context);
	update("Base", "SnapshotCopyNotSupported", context);
	SnapshotCopyNotSupported_closure(dynamic_cast<const vw1__SnapshotCopyNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SnapshotMoveNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SnapshotMoveToNonHomeNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SnapshotMoveToNonHomeNotSupported", context);
	update("Base", "SnapshotCopyNotSupported", context);
	SnapshotCopyNotSupported_closure(dynamic_cast<const vw1__SnapshotCopyNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SnapshotMoveToNonHomeNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SnapshotNoChange_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SnapshotNoChange", context);
	update("Base", "SnapshotFault", context);
	SnapshotFault_closure(dynamic_cast<const vw1__SnapshotFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SnapshotNoChange_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SnapshotRevertIssue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SnapshotRevertIssue", context);
	update_member(update, "errors", "xsd:boolean", basic2str(_obj.errors), context);
	update_member(update, "event", "Event[]", a2s_object(_obj.event, _obj.__sizeevent), context);
	update_member(update, "snapshotName", "xsd:string", basic2str(_obj.snapshotName), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SnapshotRevertIssue_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeevent)
				return new Event_closure(*_obj.event[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return MigrationFault_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void SoftRuleVioCorrectionDisallowed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SoftRuleVioCorrectionDisallowed", context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SoftRuleVioCorrectionDisallowed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SoftRuleVioCorrectionImpact_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SoftRuleVioCorrectionImpact", context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SoftRuleVioCorrectionImpact_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void StorageDrsDisabledOnVm_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageDrsDisabledOnVm", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageDrsDisabledOnVm_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void StorageDrsIolbDisabledInternally_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageDrsIolbDisabledInternally", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageDrsIolbDisabledInternally_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void StorageVMotionNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageVMotionNotSupported", context);
	update("Base", "MigrationFeatureNotSupported", context);
	MigrationFeatureNotSupported_closure(dynamic_cast<const vw1__MigrationFeatureNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageVMotionNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void StorageVmotionIncompatible_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageVmotionIncompatible", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update("Base", "VirtualHardwareCompatibilityIssue", context);
	VirtualHardwareCompatibilityIssue_closure(dynamic_cast<const vw1__VirtualHardwareCompatibilityIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StorageVmotionIncompatible_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualHardwareCompatibilityIssue_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void SuspendedRelocateNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SuspendedRelocateNotSupported", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SuspendedRelocateNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SwapDatastoreNotWritableOnHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SwapDatastoreNotWritableOnHost", context);
	update("Base", "DatastoreNotWritableOnHost", context);
	DatastoreNotWritableOnHost_closure(dynamic_cast<const vw1__DatastoreNotWritableOnHost&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SwapDatastoreNotWritableOnHost_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SwapDatastoreUnset_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SwapDatastoreUnset", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SwapDatastoreUnset_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SwapPlacementOverrideNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SwapPlacementOverrideNotSupported", context);
	update("Base", "InvalidVmConfig", context);
	InvalidVmConfig_closure(dynamic_cast<const vw1__InvalidVmConfig&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SwapPlacementOverrideNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SwitchNotInUpgradeMode_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SwitchNotInUpgradeMode", context);
	update("Base", "DvsFault", context);
	DvsFault_closure(dynamic_cast<const vw1__DvsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SwitchNotInUpgradeMode_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void SystemError_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SystemError", context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* SystemError_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TaskInProgress_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskInProgress", context);
	update_member(update, "task", "Task", handle_obj_ptr(_obj.task), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskInProgress_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.task? 
			get_closure_from_mor(Task(_obj.task)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VimFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ThirdPartyLicenseAssignmentFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ThirdPartyLicenseAssignmentFailed", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "module", "xsd:string", basic2str(_obj.module), context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ThirdPartyLicenseAssignmentFailed_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return RuntimeFault_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void Timedout_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Timedout", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* Timedout_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TooManyConcurrentNativeClones_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TooManyConcurrentNativeClones", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TooManyConcurrentNativeClones_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TooManyConsecutiveOverrides_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TooManyConsecutiveOverrides", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TooManyConsecutiveOverrides_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TooManyDevices_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TooManyDevices", context);
	update("Base", "InvalidVmConfig", context);
	InvalidVmConfig_closure(dynamic_cast<const vw1__InvalidVmConfig&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TooManyDevices_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TooManyDisksOnLegacyHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TooManyDisksOnLegacyHost", context);
	update_member(update, "diskCount", "xsd:int", basic2str(_obj.diskCount), context);
	update_member(update, "timeoutDanger", "xsd:boolean", basic2str(_obj.timeoutDanger), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TooManyDisksOnLegacyHost_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TooManyGuestLogons_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TooManyGuestLogons", context);
	update("Base", "GuestOperationsFault", context);
	GuestOperationsFault_closure(dynamic_cast<const vw1__GuestOperationsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TooManyGuestLogons_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TooManyHosts_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TooManyHosts", context);
	update("Base", "HostConnectFault", context);
	HostConnectFault_closure(dynamic_cast<const vw1__HostConnectFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TooManyHosts_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TooManyNativeCloneLevels_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TooManyNativeCloneLevels", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TooManyNativeCloneLevels_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TooManyNativeClonesOnFile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TooManyNativeClonesOnFile", context);
	update("Base", "FileFault", context);
	FileFault_closure(dynamic_cast<const vw1__FileFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TooManyNativeClonesOnFile_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void TooManySnapshotLevels_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TooManySnapshotLevels", context);
	update("Base", "SnapshotFault", context);
	SnapshotFault_closure(dynamic_cast<const vw1__SnapshotFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TooManySnapshotLevels_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ToolsAlreadyUpgraded_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ToolsAlreadyUpgraded", context);
	update("Base", "VmToolsUpgradeFault", context);
	VmToolsUpgradeFault_closure(dynamic_cast<const vw1__VmToolsUpgradeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ToolsAlreadyUpgraded_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ToolsAutoUpgradeNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ToolsAutoUpgradeNotSupported", context);
	update("Base", "VmToolsUpgradeFault", context);
	VmToolsUpgradeFault_closure(dynamic_cast<const vw1__VmToolsUpgradeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ToolsAutoUpgradeNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ToolsImageNotAvailable_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ToolsImageNotAvailable", context);
	update("Base", "VmToolsUpgradeFault", context);
	VmToolsUpgradeFault_closure(dynamic_cast<const vw1__VmToolsUpgradeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ToolsImageNotAvailable_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ToolsImageSignatureCheckFailed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ToolsImageSignatureCheckFailed", context);
	update("Base", "VmToolsUpgradeFault", context);
	VmToolsUpgradeFault_closure(dynamic_cast<const vw1__VmToolsUpgradeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ToolsImageSignatureCheckFailed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ToolsInstallationInProgress_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ToolsInstallationInProgress", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ToolsInstallationInProgress_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ToolsUnavailable_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ToolsUnavailable", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ToolsUnavailable_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void ToolsUpgradeCancelled_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ToolsUpgradeCancelled", context);
	update("Base", "VmToolsUpgradeFault", context);
	VmToolsUpgradeFault_closure(dynamic_cast<const vw1__VmToolsUpgradeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ToolsUpgradeCancelled_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UncommittedUndoableDisk_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UncommittedUndoableDisk", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UncommittedUndoableDisk_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UnconfiguredPropertyValue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UnconfiguredPropertyValue", context);
	update("Base", "InvalidPropertyValue", context);
	InvalidPropertyValue_closure(dynamic_cast<const vw1__InvalidPropertyValue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UnconfiguredPropertyValue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UncustomizableGuest_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UncustomizableGuest", context);
	update_member(update, "uncustomizableGuestOS", "xsd:string", basic2str(_obj.uncustomizableGuestOS), context);
	update("Base", "CustomizationFault", context);
	CustomizationFault_closure(dynamic_cast<const vw1__CustomizationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UncustomizableGuest_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UnexpectedCustomizationFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UnexpectedCustomizationFault", context);
	update("Base", "CustomizationFault", context);
	CustomizationFault_closure(dynamic_cast<const vw1__CustomizationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UnexpectedCustomizationFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UnexpectedFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UnexpectedFault", context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update_member(update, "faultName", "xsd:string", basic2str(_obj.faultName), context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UnexpectedFault_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return RuntimeFault_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void UnrecognizedHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UnrecognizedHost", context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UnrecognizedHost_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UnsharedSwapVMotionNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UnsharedSwapVMotionNotSupported", context);
	update("Base", "MigrationFeatureNotSupported", context);
	MigrationFeatureNotSupported_closure(dynamic_cast<const vw1__MigrationFeatureNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UnsharedSwapVMotionNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UnsupportedDatastore_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UnsupportedDatastore", context);
	update_member(update, "datastore", "Datastore", handle_obj_ptr(_obj.datastore), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UnsupportedDatastore_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.datastore? 
			get_closure_from_mor(Datastore(_obj.datastore)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmConfigFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void UnsupportedGuest_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UnsupportedGuest", context);
	update_member(update, "unsupportedGuestOS", "xsd:string", basic2str(_obj.unsupportedGuestOS), context);
	update("Base", "InvalidVmConfig", context);
	InvalidVmConfig_closure(dynamic_cast<const vw1__InvalidVmConfig&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UnsupportedGuest_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UnsupportedVimApiVersion_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UnsupportedVimApiVersion", context);
	update_member(update, "version", "xsd:string", basic2str(_obj.version), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UnsupportedVimApiVersion_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UnsupportedVmxLocation_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UnsupportedVmxLocation", context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UnsupportedVmxLocation_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UnusedVirtualDiskBlocksNotScrubbed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UnusedVirtualDiskBlocksNotScrubbed", context);
	update("Base", "DeviceBackingNotSupported", context);
	DeviceBackingNotSupported_closure(dynamic_cast<const vw1__DeviceBackingNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UnusedVirtualDiskBlocksNotScrubbed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void UserNotFound_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UserNotFound", context);
	update_member(update, "principal", "xsd:string", basic2str(_obj.principal), context);
	update_member(update, "unresolved", "xsd:boolean", basic2str(_obj.unresolved), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* UserNotFound_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VAppConfigFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppConfigFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppConfigFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VAppNotRunning_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppNotRunning", context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppNotRunning_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VAppOperationInProgress_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppOperationInProgress", context);
	update("Base", "RuntimeFault", context);
	RuntimeFault_closure(dynamic_cast<const vw1__RuntimeFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppOperationInProgress_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VAppPropertyFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppPropertyFault", context);
	update_member(update, "category", "xsd:string", basic2str(_obj.category), context);
	update_member(update, "id", "xsd:string", basic2str(_obj.id), context);
	update_member(update, "label", "xsd:string", basic2str(_obj.label), context);
	update_member(update, "type", "xsd:string", basic2str(_obj.type), context);
	update_member(update, "value", "xsd:string", basic2str(_obj.value), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppPropertyFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VAppTaskInProgress_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VAppTaskInProgress", context);
	update("Base", "TaskInProgress", context);
	TaskInProgress_closure(dynamic_cast<const vw1__TaskInProgress&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VAppTaskInProgress_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMINotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMINotSupported", context);
	update("Base", "DeviceNotSupported", context);
	DeviceNotSupported_closure(dynamic_cast<const vw1__DeviceNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMINotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMOnConflictDVPort_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMOnConflictDVPort", context);
	update("Base", "CannotAccessNetwork", context);
	CannotAccessNetwork_closure(dynamic_cast<const vw1__CannotAccessNetwork&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMOnConflictDVPort_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMOnVirtualIntranet_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMOnVirtualIntranet", context);
	update("Base", "CannotAccessNetwork", context);
	CannotAccessNetwork_closure(dynamic_cast<const vw1__CannotAccessNetwork&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMOnVirtualIntranet_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMotionInterfaceIssue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMotionInterfaceIssue", context);
	update_member(update, "atSourceHost", "xsd:boolean", basic2str(_obj.atSourceHost), context);
	update_member(update, "failedHost", "xsd:string", basic2str(_obj.failedHost), context);
	update_member_with_version(update, "failedHostEntity", "HostSystem", handle_obj_ptr(_obj.failedHostEntity), context, "2.5");
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMotionInterfaceIssue_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 2:
		return _obj.failedHostEntity? 
			get_closure_from_mor(HostSystem(_obj.failedHostEntity)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return MigrationFault_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VMotionLinkCapacityLow_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMotionLinkCapacityLow", context);
	update_member(update, "network", "xsd:string", basic2str(_obj.network), context);
	update("Base", "VMotionInterfaceIssue", context);
	VMotionInterfaceIssue_closure(dynamic_cast<const vw1__VMotionInterfaceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMotionLinkCapacityLow_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMotionLinkDown_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMotionLinkDown", context);
	update_member(update, "network", "xsd:string", basic2str(_obj.network), context);
	update("Base", "VMotionInterfaceIssue", context);
	VMotionInterfaceIssue_closure(dynamic_cast<const vw1__VMotionInterfaceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMotionLinkDown_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMotionNotConfigured_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMotionNotConfigured", context);
	update("Base", "VMotionInterfaceIssue", context);
	VMotionInterfaceIssue_closure(dynamic_cast<const vw1__VMotionInterfaceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMotionNotConfigured_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMotionNotLicensed_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMotionNotLicensed", context);
	update("Base", "VMotionInterfaceIssue", context);
	VMotionInterfaceIssue_closure(dynamic_cast<const vw1__VMotionInterfaceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMotionNotLicensed_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMotionNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMotionNotSupported", context);
	update("Base", "VMotionInterfaceIssue", context);
	VMotionInterfaceIssue_closure(dynamic_cast<const vw1__VMotionInterfaceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMotionNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VMotionProtocolIncompatible_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VMotionProtocolIncompatible", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VMotionProtocolIncompatible_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VimFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VimFault", context);
	update("Base", "MethodFault", context);
	MethodFault_closure(dynamic_cast<const vw1__MethodFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VimFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualDiskBlocksNotFullyProvisioned_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskBlocksNotFullyProvisioned", context);
	update("Base", "DeviceBackingNotSupported", context);
	DeviceBackingNotSupported_closure(dynamic_cast<const vw1__DeviceBackingNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskBlocksNotFullyProvisioned_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualDiskModeNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskModeNotSupported", context);
	update_member(update, "mode", "xsd:string", basic2str(_obj.mode), context);
	update("Base", "DeviceNotSupported", context);
	DeviceNotSupported_closure(dynamic_cast<const vw1__DeviceNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualDiskModeNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualEthernetCardNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualEthernetCardNotSupported", context);
	update("Base", "DeviceNotSupported", context);
	DeviceNotSupported_closure(dynamic_cast<const vw1__DeviceNotSupported&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualEthernetCardNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualHardwareCompatibilityIssue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualHardwareCompatibilityIssue", context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualHardwareCompatibilityIssue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VirtualHardwareVersionNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualHardwareVersionNotSupported", context);
	update_member_with_version(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context, "2.5");
	update_member_with_version(update, "hostName", "xsd:string", basic2str(_obj.hostName), context, "2.5");
	update("Base", "VirtualHardwareCompatibilityIssue", context);
	VirtualHardwareCompatibilityIssue_closure(dynamic_cast<const vw1__VirtualHardwareCompatibilityIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualHardwareVersionNotSupported_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VirtualHardwareCompatibilityIssue_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmAlreadyExistsInDatacenter_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmAlreadyExistsInDatacenter", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "hostname", "xsd:string", basic2str(_obj.hostname), context);
	update_member(update, "vm", "VirtualMachine[]", a2s_object(_obj.vm, _obj.__sizevm), context);
	update("Base", "InvalidFolder", context);
	InvalidFolder_closure(dynamic_cast<const vw1__InvalidFolder&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmAlreadyExistsInDatacenter_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	case 2:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizevm)
				return new VirtualMachine_closure(_obj.vm[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return InvalidFolder_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VmConfigFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmConfigFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmConfigFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmConfigIncompatibleForFaultTolerance_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmConfigIncompatibleForFaultTolerance", context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmConfigIncompatibleForFaultTolerance_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmConfigFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmConfigIncompatibleForRecordReplay_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmConfigIncompatibleForRecordReplay", context);
	update_member(update, "fault", "LocalizedMethodFault", handle_obj_ptr(_obj.fault), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmConfigIncompatibleForRecordReplay_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		if (_obj.fault)
			return new LocalizedMethodFault_closure(*_obj.fault);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmConfigFault_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void VmFaultToleranceConfigIssue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFaultToleranceConfigIssue", context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "entityName", "xsd:string", basic2str(_obj.entityName), context);
	update_member(update, "reason", "xsd:string", basic2str(_obj.reason), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFaultToleranceConfigIssue_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmFaultToleranceIssue_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VmFaultToleranceConfigIssueWrapper_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFaultToleranceConfigIssueWrapper", context);
	update_member(update, "entity", "ManagedEntity", handle_obj_ptr(_obj.entity), context);
	update_member(update, "entityName", "xsd:string", basic2str(_obj.entityName), context);
	update_member(update, "error", "LocalizedMethodFault", handle_obj_ptr(_obj.error), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFaultToleranceConfigIssueWrapper_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.entity? 
			get_closure_from_mor(ManagedEntity(_obj.entity)) : 0;
	case 2:
		if (_obj.error)
			return new LocalizedMethodFault_closure(*_obj.error);
		else
			return 0;
	default:
		int arr_index = index & 0xFFFF;
		return VmFaultToleranceIssue_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void VmFaultToleranceInvalidFileBacking_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFaultToleranceInvalidFileBacking", context);
	update_member(update, "backingFilename", "xsd:string", basic2str(_obj.backingFilename), context);
	update_member(update, "backingType", "xsd:string", basic2str(_obj.backingType), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFaultToleranceInvalidFileBacking_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmFaultToleranceIssue_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFaultToleranceIssue", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFaultToleranceIssue_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmFaultToleranceOpIssuesList_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFaultToleranceOpIssuesList", context);
	update_member(update, "errors", "LocalizedMethodFault[]", a2s_object(_obj.errors, _obj.__sizeerrors), context);
	update_member(update, "warnings", "LocalizedMethodFault[]", a2s_object(_obj.warnings, _obj.__sizewarnings), context);
	update("Base", "VmFaultToleranceIssue", context);
	VmFaultToleranceIssue_closure(dynamic_cast<const vw1__VmFaultToleranceIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFaultToleranceOpIssuesList_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizeerrors)
				return new LocalizedMethodFault_closure(*_obj.errors[i]);
			else
				return 0;
		}
	case 1:
		{
			int i = ((index&0xFFFF)>>16);
			if (i < _obj.__sizewarnings)
				return new LocalizedMethodFault_closure(*_obj.warnings[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return VmFaultToleranceIssue_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VmFaultToleranceTooManyVMsOnHost_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmFaultToleranceTooManyVMsOnHost", context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update_member(update, "maxNumFtVms", "xsd:int", basic2str(_obj.maxNumFtVms), context);
	update("Base", "InsufficientResourcesFault", context);
	InsufficientResourcesFault_closure(dynamic_cast<const vw1__InsufficientResourcesFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmFaultToleranceTooManyVMsOnHost_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmHostAffinityRuleViolation_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmHostAffinityRuleViolation", context);
	update_member(update, "hostName", "xsd:string", basic2str(_obj.hostName), context);
	update_member(update, "vmName", "xsd:string", basic2str(_obj.vmName), context);
	update("Base", "VmConfigFault", context);
	VmConfigFault_closure(dynamic_cast<const vw1__VmConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmHostAffinityRuleViolation_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmLimitLicense_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmLimitLicense", context);
	update_member(update, "limit", "xsd:int", basic2str(_obj.limit), context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmLimitLicense_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmMonitorIncompatibleForFaultTolerance_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmMonitorIncompatibleForFaultTolerance", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmMonitorIncompatibleForFaultTolerance_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmPowerOnDisabled_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmPowerOnDisabled", context);
	update("Base", "InvalidState", context);
	InvalidState_closure(dynamic_cast<const vw1__InvalidState&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmPowerOnDisabled_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmToolsUpgradeFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmToolsUpgradeFault", context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmToolsUpgradeFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmValidateMaxDevice_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmValidateMaxDevice", context);
	update_member(update, "count", "xsd:int", basic2str(_obj.count), context);
	update_member(update, "device", "xsd:string", basic2str(_obj.device), context);
	update_member(update, "max_", "xsd:int", basic2str(_obj.max_), context);
	update("Base", "VimFault", context);
	VimFault_closure(dynamic_cast<const vw1__VimFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmValidateMaxDevice_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmWwnConflict_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmWwnConflict", context);
	update_member(update, "host", "HostSystem", handle_obj_ptr(_obj.host), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.name), context);
	update_member(update, "vm", "VirtualMachine", handle_obj_ptr(_obj.vm), context);
	update_member(update, "wwn", "xsd:long", basic2str(_obj.wwn), context);
	update("Base", "InvalidVmConfig", context);
	InvalidVmConfig_closure(dynamic_cast<const vw1__InvalidVmConfig&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmWwnConflict_closure::get_sub_closure(size_t index) const
{
	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return _obj.host? 
			get_closure_from_mor(HostSystem(_obj.host)) : 0;
	case 2:
		return _obj.vm? 
			get_closure_from_mor(VirtualMachine(_obj.vm)) : 0;
	default:
		int arr_index = index & 0xFFFF;
		return InvalidVmConfig_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void VmfsAlreadyMounted_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmfsAlreadyMounted", context);
	update("Base", "VmfsMountFault", context);
	VmfsMountFault_closure(dynamic_cast<const vw1__VmfsMountFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmfsAlreadyMounted_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmfsAmbiguousMount_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmfsAmbiguousMount", context);
	update("Base", "VmfsMountFault", context);
	VmfsMountFault_closure(dynamic_cast<const vw1__VmfsMountFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmfsAmbiguousMount_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmfsMountFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmfsMountFault", context);
	update_member(update, "uuid", "xsd:string", basic2str(_obj.uuid), context);
	update("Base", "HostConfigFault", context);
	HostConfigFault_closure(dynamic_cast<const vw1__HostConfigFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmfsMountFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VmotionInterfaceNotEnabled_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmotionInterfaceNotEnabled", context);
	update("Base", "HostPowerOpFailed", context);
	HostPowerOpFailed_closure(dynamic_cast<const vw1__HostPowerOpFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmotionInterfaceNotEnabled_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VolumeEditorError_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VolumeEditorError", context);
	update("Base", "CustomizationFault", context);
	CustomizationFault_closure(dynamic_cast<const vw1__CustomizationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VolumeEditorError_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VramLimitLicense_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VramLimitLicense", context);
	update_member(update, "limit", "xsd:int", basic2str(_obj.limit), context);
	update("Base", "NotEnoughLicenses", context);
	NotEnoughLicenses_closure(dynamic_cast<const vw1__NotEnoughLicenses&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VramLimitLicense_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VspanDestPortConflict_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VspanDestPortConflict", context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update_member(update, "vspanSessionKey1", "xsd:string", basic2str(_obj.vspanSessionKey1), context);
	update_member(update, "vspanSessionKey2", "xsd:string", basic2str(_obj.vspanSessionKey2), context);
	update("Base", "DvsFault", context);
	DvsFault_closure(dynamic_cast<const vw1__DvsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VspanDestPortConflict_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VspanPortConflict_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VspanPortConflict", context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update_member(update, "vspanSessionKey1", "xsd:string", basic2str(_obj.vspanSessionKey1), context);
	update_member(update, "vspanSessionKey2", "xsd:string", basic2str(_obj.vspanSessionKey2), context);
	update("Base", "DvsFault", context);
	DvsFault_closure(dynamic_cast<const vw1__DvsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VspanPortConflict_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VspanPortMoveFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VspanPortMoveFault", context);
	update_member(update, "destPortgroupName", "xsd:string", basic2str(_obj.destPortgroupName), context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update_member(update, "srcPortgroupName", "xsd:string", basic2str(_obj.srcPortgroupName), context);
	update("Base", "DvsFault", context);
	DvsFault_closure(dynamic_cast<const vw1__DvsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VspanPortMoveFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VspanPortPromiscChangeFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VspanPortPromiscChangeFault", context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update("Base", "DvsFault", context);
	DvsFault_closure(dynamic_cast<const vw1__DvsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VspanPortPromiscChangeFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VspanPortgroupPromiscChangeFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VspanPortgroupPromiscChangeFault", context);
	update_member(update, "portgroupName", "xsd:string", basic2str(_obj.portgroupName), context);
	update("Base", "DvsFault", context);
	DvsFault_closure(dynamic_cast<const vw1__DvsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VspanPortgroupPromiscChangeFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VspanPortgroupTypeChangeFault_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VspanPortgroupTypeChangeFault", context);
	update_member(update, "portgroupName", "xsd:string", basic2str(_obj.portgroupName), context);
	update("Base", "DvsFault", context);
	DvsFault_closure(dynamic_cast<const vw1__DvsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VspanPortgroupTypeChangeFault_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VspanPromiscuousPortNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VspanPromiscuousPortNotSupported", context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update_member(update, "vspanSessionKey", "xsd:string", basic2str(_obj.vspanSessionKey), context);
	update("Base", "DvsFault", context);
	DvsFault_closure(dynamic_cast<const vw1__DvsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VspanPromiscuousPortNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void VspanSameSessionPortConflict_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VspanSameSessionPortConflict", context);
	update_member(update, "portKey", "xsd:string", basic2str(_obj.portKey), context);
	update_member(update, "vspanSessionKey", "xsd:string", basic2str(_obj.vspanSessionKey), context);
	update("Base", "DvsFault", context);
	DvsFault_closure(dynamic_cast<const vw1__DvsFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VspanSameSessionPortConflict_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void WakeOnLanNotSupported_closure::browse(pf_update update, void* context) const
{
	update("Begin", "WakeOnLanNotSupported", context);
	update("Base", "VirtualHardwareCompatibilityIssue", context);
	VirtualHardwareCompatibilityIssue_closure(dynamic_cast<const vw1__VirtualHardwareCompatibilityIssue&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* WakeOnLanNotSupported_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void WakeOnLanNotSupportedByVmotionNIC_closure::browse(pf_update update, void* context) const
{
	update("Begin", "WakeOnLanNotSupportedByVmotionNIC", context);
	update("Base", "HostPowerOpFailed", context);
	HostPowerOpFailed_closure(dynamic_cast<const vw1__HostPowerOpFailed&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* WakeOnLanNotSupportedByVmotionNIC_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void WillLoseHAProtection_closure::browse(pf_update update, void* context) const
{
	update("Begin", "WillLoseHAProtection", context);
	update_member(update, "resolution", "xsd:string", basic2str(_obj.resolution), context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* WillLoseHAProtection_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void WillModifyConfigCpuRequirements_closure::browse(pf_update update, void* context) const
{
	update("Begin", "WillModifyConfigCpuRequirements", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* WillModifyConfigCpuRequirements_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void WillResetSnapshotDirectory_closure::browse(pf_update update, void* context) const
{
	update("Begin", "WillResetSnapshotDirectory", context);
	update("Base", "MigrationFault", context);
	MigrationFault_closure(dynamic_cast<const vw1__MigrationFault&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* WillResetSnapshotDirectory_closure::get_sub_closure(size_t index) const
{
	return 0;
}

void Alarm_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Alarm", context);
	update_member(update, "info", "AlarmInfo", handle_obj(_obj.get_info()), context);
	update("Base", "ExtensibleManagedObject", context);
	ExtensibleManagedObject_closure(dynamic_cast<const ExtensibleManagedObject&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* Alarm_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new AlarmInfo_closure(_obj.get_info());
	default:
		int arr_index = index & 0xFFFF;
		return ExtensibleManagedObject_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void AlarmManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AlarmManager", context);
	update_member(update, "defaultExpression", "AlarmExpression[]", a2s_object(_obj.get_defaultExpression()), context);
	update_member(update, "description", "AlarmDescription", handle_obj(_obj.get_description()), context);
	update("End", std::string(), context);
}

closure* AlarmManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__AlarmExpression> v = _obj.get_defaultExpression();
			if (i < v.size())
				return new AlarmExpression_closure(v[i]);
			else
				return 0;
		}
	case 1:
		return new AlarmDescription_closure(_obj.get_description());
	default:
		return 0;
	}
	return 0;
}

void AuthorizationManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "AuthorizationManager", context);
	update_member(update, "description", "AuthorizationDescription", handle_obj(_obj.get_description()), context);
	update_member(update, "privilegeList", "AuthorizationPrivilege[]", a2s_object(_obj.get_privilegeList()), context);
	update_member(update, "roleList", "AuthorizationRole[]", a2s_object(_obj.get_roleList()), context);
	update("End", std::string(), context);
}

closure* AuthorizationManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new AuthorizationDescription_closure(_obj.get_description());
	case 1:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__AuthorizationPrivilege> v = _obj.get_privilegeList();
			if (i < v.size())
				return new AuthorizationPrivilege_closure(v[i]);
			else
				return 0;
		}
	case 2:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__AuthorizationRole> v = _obj.get_roleList();
			if (i < v.size())
				return new AuthorizationRole_closure(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void ClusterComputeResource_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterComputeResource", context);
	update_member_with_version(update, "actionHistory", "ClusterActionHistory[]", a2s_object(_obj.get_actionHistory()), context, "2.5");
	update_member(update, "configuration", "ClusterConfigInfo", handle_obj(_obj.get_configuration()), context);
	update_member_with_version(update, "drsFault", "ClusterDrsFaults[]", a2s_object(_obj.get_drsFault()), context, "4.0");
	update_member(update, "drsRecommendation", "ClusterDrsRecommendation[]", a2s_object(_obj.get_drsRecommendation()), context);
	update_member(update, "migrationHistory", "ClusterDrsMigration[]", a2s_object(_obj.get_migrationHistory()), context);
	update_member_with_version(update, "recommendation", "ClusterRecommendation[]", a2s_object(_obj.get_recommendation()), context, "2.5");
	update("Base", "ComputeResource", context);
	ComputeResource_closure(dynamic_cast<const ComputeResource&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterComputeResource_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__ClusterActionHistory> v = _obj.get_actionHistory();
			if (i < v.size())
				return new ClusterActionHistory_closure(v[i]);
			else
				return 0;
		}
	case 1:
		return new ClusterConfigInfo_closure(_obj.get_configuration());
	case 2:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__ClusterDrsFaults> v = _obj.get_drsFault();
			if (i < v.size())
				return new ClusterDrsFaults_closure(v[i]);
			else
				return 0;
		}
	case 3:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__ClusterDrsRecommendation> v = _obj.get_drsRecommendation();
			if (i < v.size())
				return new ClusterDrsRecommendation_closure(v[i]);
			else
				return 0;
		}
	case 4:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__ClusterDrsMigration> v = _obj.get_migrationHistory();
			if (i < v.size())
				return new ClusterDrsMigration_closure(v[i]);
			else
				return 0;
		}
	case 5:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__ClusterRecommendation> v = _obj.get_recommendation();
			if (i < v.size())
				return new ClusterRecommendation_closure(v[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ComputeResource_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void ClusterProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterProfile", context);
	update("Base", "Profile", context);
	Profile_closure(dynamic_cast<const Profile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterProfile_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void ClusterProfileManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ClusterProfileManager", context);
	update("Base", "ProfileManager", context);
	ProfileManager_closure(dynamic_cast<const ProfileManager&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ClusterProfileManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void ComputeResource_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ComputeResource", context);
	update_member_with_version(update, "configurationEx", "ComputeResourceConfigInfo", handle_obj(_obj.get_configurationEx()), context, "2.5");
	update_member(update, "datastore", "Datastore[]", a2s_object(_obj.get_datastore()), context);
	update_member(update, "environmentBrowser", "EnvironmentBrowser", handle_obj(_obj.get_environmentBrowser()), context);
	update_member(update, "host", "HostSystem[]", a2s_object(_obj.get_host()), context);
	update_member(update, "network", "Network[]", a2s_object(_obj.get_network()), context);
	update_member(update, "resourcePool", "ResourcePool", handle_obj(_obj.get_resourcePool()), context);
	update_member(update, "summary", "ComputeResourceSummary", handle_obj(_obj.get_summary()), context);
	update("Base", "ManagedEntity", context);
	ManagedEntity_closure(dynamic_cast<const ManagedEntity&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ComputeResource_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new ComputeResourceConfigInfo_closure(_obj.get_configurationEx());
	case 1:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Datastore> v = _obj.get_datastore();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 2:
		return new EnvironmentBrowser_closure(_obj.get_environmentBrowser());
	case 3:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<HostSystem> v = _obj.get_host();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 4:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Network> v = _obj.get_network();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 5:
		return new ResourcePool_closure(_obj.get_resourcePool());
	case 6:
		return new ComputeResourceSummary_closure(_obj.get_summary());
	default:
		int arr_index = index & 0xFFFF;
		return ManagedEntity_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void ContainerView_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ContainerView", context);
	update_member(update, "container", "ManagedEntity", handle_obj(_obj.get_container()), context);
	update_member(update, "recursive", "xsd:boolean", basic2str(_obj.get_recursive()), context);
	update_member(update, "type", "xsd:string[]", a2s_basic(_obj.get_type()), context);
	update("Base", "ManagedObjectView", context);
	ManagedObjectView_closure(dynamic_cast<const ManagedObjectView&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ContainerView_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new ManagedEntity_closure(_obj.get_container());
	default:
		int arr_index = index & 0xFFFF;
		return ManagedObjectView_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void CustomFieldsManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomFieldsManager", context);
	update_member(update, "field", "CustomFieldDef[]", a2s_object(_obj.get_field()), context);
	update("End", std::string(), context);
}

closure* CustomFieldsManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__CustomFieldDef> v = _obj.get_field();
			if (i < v.size())
				return new CustomFieldDef_closure(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void CustomizationSpecManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "CustomizationSpecManager", context);
	update_member(update, "encryptionKey", "xsd:byte[]", a2s_basic(_obj.get_encryptionKey()), context);
	update_member(update, "info", "CustomizationSpecInfo[]", a2s_object(_obj.get_info()), context);
	update("End", std::string(), context);
}

closure* CustomizationSpecManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__CustomizationSpecInfo> v = _obj.get_info();
			if (i < v.size())
				return new CustomizationSpecInfo_closure(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void Datacenter_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Datacenter", context);
	update_member(update, "datastore", "Datastore[]", a2s_object(_obj.get_datastore()), context);
	update_member_with_version(update, "datastoreFolder", "Folder", handle_obj(_obj.get_datastoreFolder()), context, "4.0");
	update_member(update, "hostFolder", "Folder", handle_obj(_obj.get_hostFolder()), context);
	update_member(update, "network", "Network[]", a2s_object(_obj.get_network()), context);
	update_member_with_version(update, "networkFolder", "Folder", handle_obj(_obj.get_networkFolder()), context, "4.0");
	update_member(update, "vmFolder", "Folder", handle_obj(_obj.get_vmFolder()), context);
	update("Base", "ManagedEntity", context);
	ManagedEntity_closure(dynamic_cast<const ManagedEntity&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* Datacenter_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Datastore> v = _obj.get_datastore();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 1:
		return new Folder_closure(_obj.get_datastoreFolder());
	case 2:
		return new Folder_closure(_obj.get_hostFolder());
	case 3:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Network> v = _obj.get_network();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 4:
		return new Folder_closure(_obj.get_networkFolder());
	case 5:
		return new Folder_closure(_obj.get_vmFolder());
	default:
		int arr_index = index & 0xFFFF;
		return ManagedEntity_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void Datastore_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Datastore", context);
	update_member(update, "browser", "HostDatastoreBrowser", handle_obj(_obj.get_browser()), context);
	update_member(update, "capability", "DatastoreCapability", handle_obj(_obj.get_capability()), context);
	update_member(update, "host", "DatastoreHostMount[]", a2s_object(_obj.get_host()), context);
	update_member(update, "info", "DatastoreInfo", handle_obj(_obj.get_info()), context);
	update_member_with_version(update, "iormConfiguration", "StorageIORMInfo", handle_obj(_obj.get_iormConfiguration()), context, "4.1");
	update_member(update, "summary", "DatastoreSummary", handle_obj(_obj.get_summary()), context);
	update_member(update, "vm", "VirtualMachine[]", a2s_object(_obj.get_vm()), context);
	update("Base", "ManagedEntity", context);
	ManagedEntity_closure(dynamic_cast<const ManagedEntity&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* Datastore_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostDatastoreBrowser_closure(_obj.get_browser());
	case 1:
		return new DatastoreCapability_closure(_obj.get_capability());
	case 2:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__DatastoreHostMount> v = _obj.get_host();
			if (i < v.size())
				return new DatastoreHostMount_closure(v[i]);
			else
				return 0;
		}
	case 3:
		return new DatastoreInfo_closure(_obj.get_info());
	case 4:
		return new StorageIORMInfo_closure(_obj.get_iormConfiguration());
	case 5:
		return new DatastoreSummary_closure(_obj.get_summary());
	case 6:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<VirtualMachine> v = _obj.get_vm();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ManagedEntity_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void DiagnosticManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DiagnosticManager", context);
	update("End", std::string(), context);
}

closure* DiagnosticManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void DistributedVirtualPortgroup_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualPortgroup", context);
	update_member(update, "config", "DVPortgroupConfigInfo", handle_obj(_obj.get_config()), context);
	update_member(update, "key", "xsd:string", basic2str(_obj.get_key()), context);
	update_member(update, "portKeys", "xsd:string[]", a2s_basic(_obj.get_portKeys()), context);
	update("Base", "Network", context);
	Network_closure(dynamic_cast<const Network&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualPortgroup_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new DVPortgroupConfigInfo_closure(_obj.get_config());
	default:
		int arr_index = index & 0xFFFF;
		return Network_closure(_obj).get_sub_closure(((prop_index - 3) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitch_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitch", context);
	update_member(update, "capability", "DVSCapability", handle_obj(_obj.get_capability()), context);
	update_member(update, "config", "DVSConfigInfo", handle_obj(_obj.get_config()), context);
	update_member_with_version(update, "networkResourcePool", "DVSNetworkResourcePool[]", a2s_object(_obj.get_networkResourcePool()), context, "4.1");
	update_member(update, "portgroup", "DistributedVirtualPortgroup[]", a2s_object(_obj.get_portgroup()), context);
	update_member(update, "summary", "DVSSummary", handle_obj(_obj.get_summary()), context);
	update_member(update, "uuid", "xsd:string", basic2str(_obj.get_uuid()), context);
	update("Base", "ManagedEntity", context);
	ManagedEntity_closure(dynamic_cast<const ManagedEntity&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitch_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new DVSCapability_closure(_obj.get_capability());
	case 1:
		return new DVSConfigInfo_closure(_obj.get_config());
	case 2:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__DVSNetworkResourcePool> v = _obj.get_networkResourcePool();
			if (i < v.size())
				return new DVSNetworkResourcePool_closure(v[i]);
			else
				return 0;
		}
	case 3:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<DistributedVirtualPortgroup> v = _obj.get_portgroup();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 4:
		return new DVSSummary_closure(_obj.get_summary());
	default:
		int arr_index = index & 0xFFFF;
		return ManagedEntity_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void DistributedVirtualSwitchManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "DistributedVirtualSwitchManager", context);
	update("End", std::string(), context);
}

closure* DistributedVirtualSwitchManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void EnvironmentBrowser_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EnvironmentBrowser", context);
	update_member(update, "datastoreBrowser", "HostDatastoreBrowser", handle_obj(_obj.get_datastoreBrowser()), context);
	update("End", std::string(), context);
}

closure* EnvironmentBrowser_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostDatastoreBrowser_closure(_obj.get_datastoreBrowser());
	default:
		return 0;
	}
	return 0;
}

void EventHistoryCollector_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EventHistoryCollector", context);
	update_member(update, "latestPage", "Event[]", a2s_object(_obj.get_latestPage()), context);
	update("Base", "HistoryCollector", context);
	HistoryCollector_closure(dynamic_cast<const HistoryCollector&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* EventHistoryCollector_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__Event> v = _obj.get_latestPage();
			if (i < v.size())
				return new Event_closure(v[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return HistoryCollector_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void EventManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "EventManager", context);
	update_member(update, "description", "EventDescription", handle_obj(_obj.get_description()), context);
	update_member(update, "latestEvent", "Event", handle_obj(_obj.get_latestEvent()), context);
	update_member(update, "maxCollector", "xsd:int", basic2str(_obj.get_maxCollector()), context);
	update("End", std::string(), context);
}

closure* EventManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new EventDescription_closure(_obj.get_description());
	case 1:
		return new Event_closure(_obj.get_latestEvent());
	default:
		return 0;
	}
	return 0;
}

void ExtensibleManagedObject_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtensibleManagedObject", context);
	update_member_with_version(update, "availableField", "CustomFieldDef[]", a2s_object(_obj.get_availableField()), context, "2.5");
	update_member_with_version(update, "value", "CustomFieldValue[]", a2s_object(_obj.get_value()), context, "2.5");
	update("End", std::string(), context);
}

closure* ExtensibleManagedObject_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__CustomFieldDef> v = _obj.get_availableField();
			if (i < v.size())
				return new CustomFieldDef_closure(v[i]);
			else
				return 0;
		}
	case 1:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__CustomFieldValue> v = _obj.get_value();
			if (i < v.size())
				return new CustomFieldValue_closure(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void ExtensionManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ExtensionManager", context);
	update_member(update, "extensionList", "Extension[]", a2s_object(_obj.get_extensionList()), context);
	update("End", std::string(), context);
}

closure* ExtensionManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__Extension> v = _obj.get_extensionList();
			if (i < v.size())
				return new Extension_closure(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void FileManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "FileManager", context);
	update("End", std::string(), context);
}

closure* FileManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void Folder_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Folder", context);
	update_member(update, "childEntity", "ManagedEntity[]", a2s_object(_obj.get_childEntity()), context);
	update_member(update, "childType", "xsd:string[]", a2s_basic(_obj.get_childType()), context);
	update("Base", "ManagedEntity", context);
	ManagedEntity_closure(dynamic_cast<const ManagedEntity&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* Folder_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<ManagedEntity> v = _obj.get_childEntity();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ManagedEntity_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void GuestAuthManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestAuthManager", context);
	update("End", std::string(), context);
}

closure* GuestAuthManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void GuestFileManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestFileManager", context);
	update("End", std::string(), context);
}

closure* GuestFileManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void GuestOperationsManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestOperationsManager", context);
	update_member(update, "authManager", "GuestAuthManager", handle_obj(_obj.get_authManager()), context);
	update_member(update, "fileManager", "GuestFileManager", handle_obj(_obj.get_fileManager()), context);
	update_member(update, "processManager", "GuestProcessManager", handle_obj(_obj.get_processManager()), context);
	update("End", std::string(), context);
}

closure* GuestOperationsManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new GuestAuthManager_closure(_obj.get_authManager());
	case 1:
		return new GuestFileManager_closure(_obj.get_fileManager());
	case 2:
		return new GuestProcessManager_closure(_obj.get_processManager());
	default:
		return 0;
	}
	return 0;
}

void GuestProcessManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "GuestProcessManager", context);
	update("End", std::string(), context);
}

closure* GuestProcessManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void HistoryCollector_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HistoryCollector", context);
	update_member(update, "filter", "xsd:anyType", basic2str(_obj.get_filter().__item), context);
	update("End", std::string(), context);
}

closure* HistoryCollector_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void HostActiveDirectoryAuthentication_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostActiveDirectoryAuthentication", context);
	update("Base", "HostDirectoryStore", context);
	HostDirectoryStore_closure(dynamic_cast<const HostDirectoryStore&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostActiveDirectoryAuthentication_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void HostAuthenticationManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostAuthenticationManager", context);
	update_member(update, "info", "HostAuthenticationManagerInfo", handle_obj(_obj.get_info()), context);
	update_member(update, "supportedStore", "HostAuthenticationStore[]", a2s_object(_obj.get_supportedStore()), context);
	update("End", std::string(), context);
}

closure* HostAuthenticationManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostAuthenticationManagerInfo_closure(_obj.get_info());
	case 1:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<HostAuthenticationStore> v = _obj.get_supportedStore();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void HostAuthenticationStore_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostAuthenticationStore", context);
	update_member(update, "info", "HostAuthenticationStoreInfo", handle_obj(_obj.get_info()), context);
	update("End", std::string(), context);
}

closure* HostAuthenticationStore_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostAuthenticationStoreInfo_closure(_obj.get_info());
	default:
		return 0;
	}
	return 0;
}

void HostAutoStartManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostAutoStartManager", context);
	update_member(update, "config", "HostAutoStartManagerConfig", handle_obj(_obj.get_config()), context);
	update("End", std::string(), context);
}

closure* HostAutoStartManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostAutoStartManagerConfig_closure(_obj.get_config());
	default:
		return 0;
	}
	return 0;
}

void HostBootDeviceSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostBootDeviceSystem", context);
	update("End", std::string(), context);
}

closure* HostBootDeviceSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void HostCacheConfigurationManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCacheConfigurationManager", context);
	update_member(update, "cacheConfigurationInfo", "HostCacheConfigurationInfo[]", a2s_object(_obj.get_cacheConfigurationInfo()), context);
	update("End", std::string(), context);
}

closure* HostCacheConfigurationManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__HostCacheConfigurationInfo> v = _obj.get_cacheConfigurationInfo();
			if (i < v.size())
				return new HostCacheConfigurationInfo_closure(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void HostCpuSchedulerSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostCpuSchedulerSystem", context);
	update_member(update, "hyperthreadInfo", "HostHyperThreadScheduleInfo", handle_obj(_obj.get_hyperthreadInfo()), context);
	update("Base", "ExtensibleManagedObject", context);
	ExtensibleManagedObject_closure(dynamic_cast<const ExtensibleManagedObject&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostCpuSchedulerSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostHyperThreadScheduleInfo_closure(_obj.get_hyperthreadInfo());
	default:
		int arr_index = index & 0xFFFF;
		return ExtensibleManagedObject_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostDatastoreBrowser_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDatastoreBrowser", context);
	update_member(update, "datastore", "Datastore[]", a2s_object(_obj.get_datastore()), context);
	update_member(update, "supportedType", "FileQuery[]", a2s_object(_obj.get_supportedType()), context);
	update("End", std::string(), context);
}

closure* HostDatastoreBrowser_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Datastore> v = _obj.get_datastore();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 1:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__FileQuery> v = _obj.get_supportedType();
			if (i < v.size())
				return new FileQuery_closure(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void HostDatastoreSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDatastoreSystem", context);
	update_member_with_version(update, "capabilities", "HostDatastoreSystemCapabilities", handle_obj(_obj.get_capabilities()), context, "2.5");
	update_member(update, "datastore", "Datastore[]", a2s_object(_obj.get_datastore()), context);
	update("End", std::string(), context);
}

closure* HostDatastoreSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostDatastoreSystemCapabilities_closure(_obj.get_capabilities());
	case 1:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Datastore> v = _obj.get_datastore();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void HostDateTimeSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDateTimeSystem", context);
	update_member(update, "dateTimeInfo", "HostDateTimeInfo", handle_obj(_obj.get_dateTimeInfo()), context);
	update("End", std::string(), context);
}

closure* HostDateTimeSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostDateTimeInfo_closure(_obj.get_dateTimeInfo());
	default:
		return 0;
	}
	return 0;
}

void HostDiagnosticSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDiagnosticSystem", context);
	update_member(update, "activePartition", "HostDiagnosticPartition", handle_obj(_obj.get_activePartition()), context);
	update("End", std::string(), context);
}

closure* HostDiagnosticSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostDiagnosticPartition_closure(_obj.get_activePartition());
	default:
		return 0;
	}
	return 0;
}

void HostDirectoryStore_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostDirectoryStore", context);
	update("Base", "HostAuthenticationStore", context);
	HostAuthenticationStore_closure(dynamic_cast<const HostAuthenticationStore&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostDirectoryStore_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void HostEsxAgentHostManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostEsxAgentHostManager", context);
	update_member(update, "configInfo", "HostEsxAgentHostManagerConfigInfo", handle_obj(_obj.get_configInfo()), context);
	update("End", std::string(), context);
}

closure* HostEsxAgentHostManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostEsxAgentHostManagerConfigInfo_closure(_obj.get_configInfo());
	default:
		return 0;
	}
	return 0;
}

void HostFirewallSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFirewallSystem", context);
	update_member(update, "firewallInfo", "HostFirewallInfo", handle_obj(_obj.get_firewallInfo()), context);
	update("Base", "ExtensibleManagedObject", context);
	ExtensibleManagedObject_closure(dynamic_cast<const ExtensibleManagedObject&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostFirewallSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostFirewallInfo_closure(_obj.get_firewallInfo());
	default:
		int arr_index = index & 0xFFFF;
		return ExtensibleManagedObject_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostFirmwareSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostFirmwareSystem", context);
	update("End", std::string(), context);
}

closure* HostFirmwareSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void HostHealthStatusSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostHealthStatusSystem", context);
	update_member(update, "runtime", "HealthSystemRuntime", handle_obj(_obj.get_runtime()), context);
	update("End", std::string(), context);
}

closure* HostHealthStatusSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HealthSystemRuntime_closure(_obj.get_runtime());
	default:
		return 0;
	}
	return 0;
}

void HostImageConfigManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostImageConfigManager", context);
	update("End", std::string(), context);
}

closure* HostImageConfigManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void HostKernelModuleSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostKernelModuleSystem", context);
	update("End", std::string(), context);
}

closure* HostKernelModuleSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void HostLocalAccountManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostLocalAccountManager", context);
	update("End", std::string(), context);
}

closure* HostLocalAccountManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void HostLocalAuthentication_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostLocalAuthentication", context);
	update("Base", "HostAuthenticationStore", context);
	HostAuthenticationStore_closure(dynamic_cast<const HostAuthenticationStore&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostLocalAuthentication_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void HostMemorySystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostMemorySystem", context);
	update_member(update, "consoleReservationInfo", "ServiceConsoleReservationInfo", handle_obj(_obj.get_consoleReservationInfo()), context);
	update_member_with_version(update, "virtualMachineReservationInfo", "VirtualMachineMemoryReservationInfo", handle_obj(_obj.get_virtualMachineReservationInfo()), context, "2.5");
	update("Base", "ExtensibleManagedObject", context);
	ExtensibleManagedObject_closure(dynamic_cast<const ExtensibleManagedObject&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostMemorySystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new ServiceConsoleReservationInfo_closure(_obj.get_consoleReservationInfo());
	case 1:
		return new VirtualMachineMemoryReservationInfo_closure(_obj.get_virtualMachineReservationInfo());
	default:
		int arr_index = index & 0xFFFF;
		return ExtensibleManagedObject_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostNetworkSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostNetworkSystem", context);
	update_member(update, "capabilities", "HostNetCapabilities", handle_obj(_obj.get_capabilities()), context);
	update_member(update, "consoleIpRouteConfig", "HostIpRouteConfig", handle_obj(_obj.get_consoleIpRouteConfig()), context);
	update_member(update, "dnsConfig", "HostDnsConfig", handle_obj(_obj.get_dnsConfig()), context);
	update_member(update, "ipRouteConfig", "HostIpRouteConfig", handle_obj(_obj.get_ipRouteConfig()), context);
	update_member(update, "networkConfig", "HostNetworkConfig", handle_obj(_obj.get_networkConfig()), context);
	update_member(update, "networkInfo", "HostNetworkInfo", handle_obj(_obj.get_networkInfo()), context);
	update_member(update, "offloadCapabilities", "HostNetOffloadCapabilities", handle_obj(_obj.get_offloadCapabilities()), context);
	update("Base", "ExtensibleManagedObject", context);
	ExtensibleManagedObject_closure(dynamic_cast<const ExtensibleManagedObject&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostNetworkSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostNetCapabilities_closure(_obj.get_capabilities());
	case 1:
		return new HostIpRouteConfig_closure(_obj.get_consoleIpRouteConfig());
	case 2:
		return new HostDnsConfig_closure(_obj.get_dnsConfig());
	case 3:
		return new HostIpRouteConfig_closure(_obj.get_ipRouteConfig());
	case 4:
		return new HostNetworkConfig_closure(_obj.get_networkConfig());
	case 5:
		return new HostNetworkInfo_closure(_obj.get_networkInfo());
	case 6:
		return new HostNetOffloadCapabilities_closure(_obj.get_offloadCapabilities());
	default:
		int arr_index = index & 0xFFFF;
		return ExtensibleManagedObject_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void HostPatchManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPatchManager", context);
	update("End", std::string(), context);
}

closure* HostPatchManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void HostPciPassthruSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPciPassthruSystem", context);
	update_member(update, "pciPassthruInfo", "HostPciPassthruInfo[]", a2s_object(_obj.get_pciPassthruInfo()), context);
	update("Base", "ExtensibleManagedObject", context);
	ExtensibleManagedObject_closure(dynamic_cast<const ExtensibleManagedObject&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostPciPassthruSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__HostPciPassthruInfo> v = _obj.get_pciPassthruInfo();
			if (i < v.size())
				return new HostPciPassthruInfo_closure(v[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ExtensibleManagedObject_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostPowerSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostPowerSystem", context);
	update_member(update, "capability", "PowerSystemCapability", handle_obj(_obj.get_capability()), context);
	update_member(update, "info", "PowerSystemInfo", handle_obj(_obj.get_info()), context);
	update("End", std::string(), context);
}

closure* HostPowerSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new PowerSystemCapability_closure(_obj.get_capability());
	case 1:
		return new PowerSystemInfo_closure(_obj.get_info());
	default:
		return 0;
	}
	return 0;
}

void HostProfile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostProfile", context);
	update_member(update, "referenceHost", "HostSystem", handle_obj(_obj.get_referenceHost()), context);
	update("Base", "Profile", context);
	Profile_closure(dynamic_cast<const Profile&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostProfile_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostSystem_closure(_obj.get_referenceHost());
	default:
		int arr_index = index & 0xFFFF;
		return Profile_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostProfileManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostProfileManager", context);
	update("Base", "ProfileManager", context);
	ProfileManager_closure(dynamic_cast<const ProfileManager&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostProfileManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void HostServiceSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostServiceSystem", context);
	update_member(update, "serviceInfo", "HostServiceInfo", handle_obj(_obj.get_serviceInfo()), context);
	update("Base", "ExtensibleManagedObject", context);
	ExtensibleManagedObject_closure(dynamic_cast<const ExtensibleManagedObject&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostServiceSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostServiceInfo_closure(_obj.get_serviceInfo());
	default:
		int arr_index = index & 0xFFFF;
		return ExtensibleManagedObject_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HostSnmpSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostSnmpSystem", context);
	update_member_with_version(update, "configuration", "HostSnmpConfigSpec", handle_obj(_obj.get_configuration()), context, "2.5");
	update_member_with_version(update, "limits", "HostSnmpSystemAgentLimits", handle_obj(_obj.get_limits()), context, "2.5");
	update("End", std::string(), context);
}

closure* HostSnmpSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostSnmpConfigSpec_closure(_obj.get_configuration());
	case 1:
		return new HostSnmpSystemAgentLimits_closure(_obj.get_limits());
	default:
		return 0;
	}
	return 0;
}

void HostStorageSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostStorageSystem", context);
	update_member(update, "fileSystemVolumeInfo", "HostFileSystemVolumeInfo", handle_obj(_obj.get_fileSystemVolumeInfo()), context);
	update_member_with_version(update, "multipathStateInfo", "HostMultipathStateInfo", handle_obj(_obj.get_multipathStateInfo()), context, "4.0");
	update_member(update, "storageDeviceInfo", "HostStorageDeviceInfo", handle_obj(_obj.get_storageDeviceInfo()), context);
	update_member_with_version(update, "systemFile", "xsd:string[]", a2s_basic(_obj.get_systemFile()), context, "4.1");
	update("Base", "ExtensibleManagedObject", context);
	ExtensibleManagedObject_closure(dynamic_cast<const ExtensibleManagedObject&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostStorageSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostFileSystemVolumeInfo_closure(_obj.get_fileSystemVolumeInfo());
	case 1:
		return new HostMultipathStateInfo_closure(_obj.get_multipathStateInfo());
	case 2:
		return new HostStorageDeviceInfo_closure(_obj.get_storageDeviceInfo());
	default:
		int arr_index = index & 0xFFFF;
		return ExtensibleManagedObject_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void HostSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostSystem", context);
	update_member(update, "capability", "HostCapability", handle_obj(_obj.get_capability()), context);
	update_member(update, "config", "HostConfigInfo", handle_obj(_obj.get_config()), context);
	update_member(update, "configManager", "HostConfigManager", handle_obj(_obj.get_configManager()), context);
	update_member(update, "datastore", "Datastore[]", a2s_object(_obj.get_datastore()), context);
	update_member(update, "datastoreBrowser", "HostDatastoreBrowser", handle_obj(_obj.get_datastoreBrowser()), context);
	update_member(update, "hardware", "HostHardwareInfo", handle_obj(_obj.get_hardware()), context);
	update_member_with_version(update, "licensableResource", "HostLicensableResourceInfo", handle_obj(_obj.get_licensableResource()), context, "5.0");
	update_member(update, "network", "Network[]", a2s_object(_obj.get_network()), context);
	update_member(update, "runtime", "HostRuntimeInfo", handle_obj(_obj.get_runtime()), context);
	update_member(update, "summary", "HostListSummary", handle_obj(_obj.get_summary()), context);
	update_member(update, "systemResources", "HostSystemResourceInfo", handle_obj(_obj.get_systemResources()), context);
	update_member(update, "vm", "VirtualMachine[]", a2s_object(_obj.get_vm()), context);
	update("Base", "ManagedEntity", context);
	ManagedEntity_closure(dynamic_cast<const ManagedEntity&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostCapability_closure(_obj.get_capability());
	case 1:
		return new HostConfigInfo_closure(_obj.get_config());
	case 2:
		return new HostConfigManager_closure(_obj.get_configManager());
	case 3:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Datastore> v = _obj.get_datastore();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 4:
		return new HostDatastoreBrowser_closure(_obj.get_datastoreBrowser());
	case 5:
		return new HostHardwareInfo_closure(_obj.get_hardware());
	case 6:
		return new HostLicensableResourceInfo_closure(_obj.get_licensableResource());
	case 7:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Network> v = _obj.get_network();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 8:
		return new HostRuntimeInfo_closure(_obj.get_runtime());
	case 9:
		return new HostListSummary_closure(_obj.get_summary());
	case 10:
		return new HostSystemResourceInfo_closure(_obj.get_systemResources());
	case 11:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<VirtualMachine> v = _obj.get_vm();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ManagedEntity_closure(_obj).get_sub_closure(((prop_index - 12) << 16) + arr_index);
	}
	return 0;
}

void HostVMotionSystem_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVMotionSystem", context);
	update_member(update, "ipConfig", "HostIpConfig", handle_obj(_obj.get_ipConfig()), context);
	update_member(update, "netConfig", "HostVMotionNetConfig", handle_obj(_obj.get_netConfig()), context);
	update("Base", "ExtensibleManagedObject", context);
	ExtensibleManagedObject_closure(dynamic_cast<const ExtensibleManagedObject&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVMotionSystem_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostIpConfig_closure(_obj.get_ipConfig());
	case 1:
		return new HostVMotionNetConfig_closure(_obj.get_netConfig());
	default:
		int arr_index = index & 0xFFFF;
		return ExtensibleManagedObject_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void HostVirtualNicManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HostVirtualNicManager", context);
	update_member(update, "info", "HostVirtualNicManagerInfo", handle_obj(_obj.get_info()), context);
	update("Base", "ExtensibleManagedObject", context);
	ExtensibleManagedObject_closure(dynamic_cast<const ExtensibleManagedObject&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* HostVirtualNicManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new HostVirtualNicManagerInfo_closure(_obj.get_info());
	default:
		int arr_index = index & 0xFFFF;
		return ExtensibleManagedObject_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void HttpNfcLease_closure::browse(pf_update update, void* context) const
{
	update("Begin", "HttpNfcLease", context);
	update_member(update, "error", "LocalizedMethodFault", handle_obj(_obj.get_error()), context);
	update_member(update, "info", "HttpNfcLeaseInfo", handle_obj(_obj.get_info()), context);
	update_member(update, "initializeProgress", "xsd:int", basic2str(_obj.get_initializeProgress()), context);
	update_member(update, "state", "HttpNfcLeaseState", handle_obj(_obj.get_state()), context);
	update("End", std::string(), context);
}

closure* HttpNfcLease_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new LocalizedMethodFault_closure(_obj.get_error());
	case 1:
		return new HttpNfcLeaseInfo_closure(_obj.get_info());
	default:
		return 0;
	}
	return 0;
}

void InventoryView_closure::browse(pf_update update, void* context) const
{
	update("Begin", "InventoryView", context);
	update("Base", "ManagedObjectView", context);
	ManagedObjectView_closure(dynamic_cast<const ManagedObjectView&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* InventoryView_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void IpPoolManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IpPoolManager", context);
	update("End", std::string(), context);
}

closure* IpPoolManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void IscsiManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "IscsiManager", context);
	update("End", std::string(), context);
}

closure* IscsiManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void LicenseAssignmentManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseAssignmentManager", context);
	update("End", std::string(), context);
}

closure* LicenseAssignmentManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void LicenseManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LicenseManager", context);
	update_member_with_version(update, "diagnostics", "LicenseDiagnostics", handle_obj(_obj.get_diagnostics()), context, "2.5");
	update_member_with_version(update, "evaluation", "LicenseManagerEvaluationInfo", handle_obj(_obj.get_evaluation()), context, "4.0");
	update_member(update, "featureInfo", "LicenseFeatureInfo[]", a2s_object(_obj.get_featureInfo()), context);
	update_member_with_version(update, "licenseAssignmentManager", "LicenseAssignmentManager", handle_obj(_obj.get_licenseAssignmentManager()), context, "4.0");
	update_member_with_version(update, "licensedEdition", "xsd:string", basic2str(_obj.get_licensedEdition()), context, "2.5");
	update_member_with_version(update, "licenses", "LicenseManagerLicenseInfo[]", a2s_object(_obj.get_licenses()), context, "4.0");
	update_member(update, "source", "LicenseSource", handle_obj(_obj.get_source()), context);
	update_member(update, "sourceAvailable", "xsd:boolean", basic2str(_obj.get_sourceAvailable()), context);
	update("End", std::string(), context);
}

closure* LicenseManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new LicenseDiagnostics_closure(_obj.get_diagnostics());
	case 1:
		return new LicenseManagerEvaluationInfo_closure(_obj.get_evaluation());
	case 2:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__LicenseFeatureInfo> v = _obj.get_featureInfo();
			if (i < v.size())
				return new LicenseFeatureInfo_closure(v[i]);
			else
				return 0;
		}
	case 3:
		return new LicenseAssignmentManager_closure(_obj.get_licenseAssignmentManager());
	case 5:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__LicenseManagerLicenseInfo> v = _obj.get_licenses();
			if (i < v.size())
				return new LicenseManagerLicenseInfo_closure(v[i]);
			else
				return 0;
		}
	case 6:
		return new LicenseSource_closure(_obj.get_source());
	default:
		return 0;
	}
	return 0;
}

void ListView_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ListView", context);
	update("Base", "ManagedObjectView", context);
	ManagedObjectView_closure(dynamic_cast<const ManagedObjectView&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ListView_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void LocalizationManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "LocalizationManager", context);
	update_member(update, "catalog", "LocalizationManagerMessageCatalog[]", a2s_object(_obj.get_catalog()), context);
	update("End", std::string(), context);
}

closure* LocalizationManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__LocalizationManagerMessageCatalog> v = _obj.get_catalog();
			if (i < v.size())
				return new LocalizationManagerMessageCatalog_closure(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void ManagedEntity_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ManagedEntity", context);
	update_member_with_version(update, "alarmActionsEnabled", "xsd:boolean", basic2str(_obj.get_alarmActionsEnabled()), context, "4.0");
	update_member(update, "configIssue", "Event[]", a2s_object(_obj.get_configIssue()), context);
	update_member(update, "configStatus", "ManagedEntityStatus", handle_obj(_obj.get_configStatus()), context);
	update_member(update, "customValue", "CustomFieldValue[]", a2s_object(_obj.get_customValue()), context);
	update_member(update, "declaredAlarmState", "AlarmState[]", a2s_object(_obj.get_declaredAlarmState()), context);
	update_member(update, "disabledMethod", "xsd:string[]", a2s_basic(_obj.get_disabledMethod()), context);
	update_member(update, "effectiveRole", "xsd:int[]", a2s_basic(_obj.get_effectiveRole()), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.get_name()), context);
	update_member(update, "overallStatus", "ManagedEntityStatus", handle_obj(_obj.get_overallStatus()), context);
	update_member(update, "parent", "ManagedEntity", handle_obj(_obj.get_parent()), context);
	update_member(update, "permission", "Permission[]", a2s_object(_obj.get_permission()), context);
	update_member(update, "recentTask", "Task[]", a2s_object(_obj.get_recentTask()), context);
	update_member_with_version(update, "tag", "Tag[]", a2s_object(_obj.get_tag()), context, "4.0");
	update_member(update, "triggeredAlarmState", "AlarmState[]", a2s_object(_obj.get_triggeredAlarmState()), context);
	update("Base", "ExtensibleManagedObject", context);
	ExtensibleManagedObject_closure(dynamic_cast<const ExtensibleManagedObject&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ManagedEntity_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__Event> v = _obj.get_configIssue();
			if (i < v.size())
				return new Event_closure(v[i]);
			else
				return 0;
		}
	case 3:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__CustomFieldValue> v = _obj.get_customValue();
			if (i < v.size())
				return new CustomFieldValue_closure(v[i]);
			else
				return 0;
		}
	case 4:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__AlarmState> v = _obj.get_declaredAlarmState();
			if (i < v.size())
				return new AlarmState_closure(v[i]);
			else
				return 0;
		}
	case 9:
		return new ManagedEntity_closure(_obj.get_parent());
	case 10:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__Permission> v = _obj.get_permission();
			if (i < v.size())
				return new Permission_closure(v[i]);
			else
				return 0;
		}
	case 11:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Task> v = _obj.get_recentTask();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 12:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__Tag> v = _obj.get_tag();
			if (i < v.size())
				return new Tag_closure(v[i]);
			else
				return 0;
		}
	case 13:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__AlarmState> v = _obj.get_triggeredAlarmState();
			if (i < v.size())
				return new AlarmState_closure(v[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ExtensibleManagedObject_closure(_obj).get_sub_closure(((prop_index - 14) << 16) + arr_index);
	}
	return 0;
}

void ManagedObjectView_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ManagedObjectView", context);
	update_member(update, "view", "ManagedObjectReference[]", a2s_object(_obj.get_view()), context);
	update("Base", "View", context);
	View_closure(dynamic_cast<const View&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ManagedObjectView_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<View> v = _obj.get_view();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return View_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void Network_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Network", context);
	update_member(update, "host", "HostSystem[]", a2s_object(_obj.get_host()), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.get_name()), context);
	update_member(update, "summary", "NetworkSummary", handle_obj(_obj.get_summary()), context);
	update_member(update, "vm", "VirtualMachine[]", a2s_object(_obj.get_vm()), context);
	update("Base", "ManagedEntity", context);
	ManagedEntity_closure(dynamic_cast<const ManagedEntity&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* Network_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<HostSystem> v = _obj.get_host();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 2:
		return new NetworkSummary_closure(_obj.get_summary());
	case 3:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<VirtualMachine> v = _obj.get_vm();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ManagedEntity_closure(_obj).get_sub_closure(((prop_index - 4) << 16) + arr_index);
	}
	return 0;
}

void OptionManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OptionManager", context);
	update_member(update, "setting", "OptionValue[]", a2s_object(_obj.get_setting()), context);
	update_member(update, "supportedOption", "OptionDef[]", a2s_object(_obj.get_supportedOption()), context);
	update("End", std::string(), context);
}

closure* OptionManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__OptionValue> v = _obj.get_setting();
			if (i < v.size())
				return new OptionValue_closure(v[i]);
			else
				return 0;
		}
	case 1:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__OptionDef> v = _obj.get_supportedOption();
			if (i < v.size())
				return new OptionDef_closure(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void OvfManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "OvfManager", context);
	update("End", std::string(), context);
}

closure* OvfManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void PerformanceManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PerformanceManager", context);
	update_member(update, "description", "PerformanceDescription", handle_obj(_obj.get_description()), context);
	update_member(update, "historicalInterval", "PerfInterval[]", a2s_object(_obj.get_historicalInterval()), context);
	update_member(update, "perfCounter", "PerfCounterInfo[]", a2s_object(_obj.get_perfCounter()), context);
	update("End", std::string(), context);
}

closure* PerformanceManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new PerformanceDescription_closure(_obj.get_description());
	case 1:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__PerfInterval> v = _obj.get_historicalInterval();
			if (i < v.size())
				return new PerfInterval_closure(v[i]);
			else
				return 0;
		}
	case 2:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__PerfCounterInfo> v = _obj.get_perfCounter();
			if (i < v.size())
				return new PerfCounterInfo_closure(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void Profile_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Profile", context);
	update_member(update, "complianceStatus", "xsd:string", basic2str(_obj.get_complianceStatus()), context);
	update_member(update, "config", "ProfileConfigInfo", handle_obj(_obj.get_config()), context);
	update_member(update, "createdTime", "xsd:dateTime", basic2str(_obj.get_createdTime()), context);
	update_member(update, "description", "ProfileDescription", handle_obj(_obj.get_description()), context);
	update_member(update, "entity", "ManagedEntity[]", a2s_object(_obj.get_entity()), context);
	update_member(update, "modifiedTime", "xsd:dateTime", basic2str(_obj.get_modifiedTime()), context);
	update_member(update, "name", "xsd:string", basic2str(_obj.get_name()), context);
	update("End", std::string(), context);
}

closure* Profile_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return new ProfileConfigInfo_closure(_obj.get_config());
	case 3:
		return new ProfileDescription_closure(_obj.get_description());
	case 4:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<ManagedEntity> v = _obj.get_entity();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void ProfileComplianceManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileComplianceManager", context);
	update("End", std::string(), context);
}

closure* ProfileComplianceManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void ProfileManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ProfileManager", context);
	update_member(update, "profile", "Profile[]", a2s_object(_obj.get_profile()), context);
	update("End", std::string(), context);
}

closure* ProfileManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Profile> v = _obj.get_profile();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void PropertyCollector_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PropertyCollector", context);
	update_member(update, "filter", "PropertyFilter[]", a2s_object(_obj.get_filter()), context);
	update("End", std::string(), context);
}

closure* PropertyCollector_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<PropertyFilter> v = _obj.get_filter();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void PropertyFilter_closure::browse(pf_update update, void* context) const
{
	update("Begin", "PropertyFilter", context);
	update_member(update, "partialUpdates", "xsd:boolean", basic2str(_obj.get_partialUpdates()), context);
	update_member(update, "spec", "PropertyFilterSpec", handle_obj(_obj.get_spec()), context);
	update("End", std::string(), context);
}

closure* PropertyFilter_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 1:
		return new PropertyFilterSpec_closure(_obj.get_spec());
	default:
		return 0;
	}
	return 0;
}

void ResourcePlanningManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourcePlanningManager", context);
	update("End", std::string(), context);
}

closure* ResourcePlanningManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void ResourcePool_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ResourcePool", context);
	update_member(update, "childConfiguration", "ResourceConfigSpec[]", a2s_object(_obj.get_childConfiguration()), context);
	update_member(update, "config", "ResourceConfigSpec", handle_obj(_obj.get_config()), context);
	update_member(update, "owner", "ComputeResource", handle_obj(_obj.get_owner()), context);
	update_member(update, "resourcePool", "ResourcePool[]", a2s_object(_obj.get_resourcePool()), context);
	update_member(update, "runtime", "ResourcePoolRuntimeInfo", handle_obj(_obj.get_runtime()), context);
	update_member(update, "summary", "ResourcePoolSummary", handle_obj(_obj.get_summary()), context);
	update_member(update, "vm", "VirtualMachine[]", a2s_object(_obj.get_vm()), context);
	update("Base", "ManagedEntity", context);
	ManagedEntity_closure(dynamic_cast<const ManagedEntity&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ResourcePool_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__ResourceConfigSpec> v = _obj.get_childConfiguration();
			if (i < v.size())
				return new ResourceConfigSpec_closure(v[i]);
			else
				return 0;
		}
	case 1:
		return new ResourceConfigSpec_closure(_obj.get_config());
	case 2:
		return new ComputeResource_closure(_obj.get_owner());
	case 3:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<ResourcePool> v = _obj.get_resourcePool();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 4:
		return new ResourcePoolRuntimeInfo_closure(_obj.get_runtime());
	case 5:
		return new ResourcePoolSummary_closure(_obj.get_summary());
	case 6:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<VirtualMachine> v = _obj.get_vm();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return ManagedEntity_closure(_obj).get_sub_closure(((prop_index - 7) << 16) + arr_index);
	}
	return 0;
}

void ScheduledTask_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTask", context);
	update_member(update, "info", "ScheduledTaskInfo", handle_obj(_obj.get_info()), context);
	update("Base", "ExtensibleManagedObject", context);
	ExtensibleManagedObject_closure(dynamic_cast<const ExtensibleManagedObject&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* ScheduledTask_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new ScheduledTaskInfo_closure(_obj.get_info());
	default:
		int arr_index = index & 0xFFFF;
		return ExtensibleManagedObject_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void ScheduledTaskManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ScheduledTaskManager", context);
	update_member(update, "description", "ScheduledTaskDescription", handle_obj(_obj.get_description()), context);
	update_member(update, "scheduledTask", "ScheduledTask[]", a2s_object(_obj.get_scheduledTask()), context);
	update("End", std::string(), context);
}

closure* ScheduledTaskManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new ScheduledTaskDescription_closure(_obj.get_description());
	case 1:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<ScheduledTask> v = _obj.get_scheduledTask();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void SearchIndex_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SearchIndex", context);
	update("End", std::string(), context);
}

closure* SearchIndex_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void ServiceInstance_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ServiceInstance", context);
	update_member(update, "capability", "Capability", handle_obj(_obj.get_capability()), context);
	update_member(update, "content", "ServiceContent", handle_obj(_obj.get_content()), context);
	update_member(update, "serverClock", "xsd:dateTime", basic2str(_obj.get_serverClock()), context);
	update("End", std::string(), context);
}

closure* ServiceInstance_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new Capability_closure(_obj.get_capability());
	case 1:
		return new ServiceContent_closure(_obj.get_content());
	default:
		return 0;
	}
	return 0;
}

void SessionManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "SessionManager", context);
	update_member(update, "currentSession", "UserSession", handle_obj(_obj.get_currentSession()), context);
	update_member(update, "defaultLocale", "xsd:string", basic2str(_obj.get_defaultLocale()), context);
	update_member(update, "message", "xsd:string", basic2str(_obj.get_message()), context);
	update_member(update, "messageLocaleList", "xsd:string[]", a2s_basic(_obj.get_messageLocaleList()), context);
	update_member(update, "sessionList", "UserSession[]", a2s_object(_obj.get_sessionList()), context);
	update_member(update, "supportedLocaleList", "xsd:string[]", a2s_basic(_obj.get_supportedLocaleList()), context);
	update("End", std::string(), context);
}

closure* SessionManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new UserSession_closure(_obj.get_currentSession());
	case 4:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__UserSession> v = _obj.get_sessionList();
			if (i < v.size())
				return new UserSession_closure(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void StoragePod_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StoragePod", context);
	update_member(update, "podStorageDrsEntry", "PodStorageDrsEntry", handle_obj(_obj.get_podStorageDrsEntry()), context);
	update_member(update, "summary", "StoragePodSummary", handle_obj(_obj.get_summary()), context);
	update("Base", "Folder", context);
	Folder_closure(dynamic_cast<const Folder&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* StoragePod_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new PodStorageDrsEntry_closure(_obj.get_podStorageDrsEntry());
	case 1:
		return new StoragePodSummary_closure(_obj.get_summary());
	default:
		int arr_index = index & 0xFFFF;
		return Folder_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void StorageResourceManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "StorageResourceManager", context);
	update("End", std::string(), context);
}

closure* StorageResourceManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void Task_closure::browse(pf_update update, void* context) const
{
	update("Begin", "Task", context);
	update_member(update, "info", "TaskInfo", handle_obj(_obj.get_info()), context);
	update("Base", "ExtensibleManagedObject", context);
	ExtensibleManagedObject_closure(dynamic_cast<const ExtensibleManagedObject&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* Task_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new TaskInfo_closure(_obj.get_info());
	default:
		int arr_index = index & 0xFFFF;
		return ExtensibleManagedObject_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void TaskHistoryCollector_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskHistoryCollector", context);
	update_member(update, "latestPage", "TaskInfo[]", a2s_object(_obj.get_latestPage()), context);
	update("Base", "HistoryCollector", context);
	HistoryCollector_closure(dynamic_cast<const HistoryCollector&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* TaskHistoryCollector_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__TaskInfo> v = _obj.get_latestPage();
			if (i < v.size())
				return new TaskInfo_closure(v[i]);
			else
				return 0;
		}
	default:
		int arr_index = index & 0xFFFF;
		return HistoryCollector_closure(_obj).get_sub_closure(((prop_index - 1) << 16) + arr_index);
	}
	return 0;
}

void TaskManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "TaskManager", context);
	update_member(update, "description", "TaskDescription", handle_obj(_obj.get_description()), context);
	update_member(update, "maxCollector", "xsd:int", basic2str(_obj.get_maxCollector()), context);
	update_member(update, "recentTask", "Task[]", a2s_object(_obj.get_recentTask()), context);
	update("End", std::string(), context);
}

closure* TaskManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new TaskDescription_closure(_obj.get_description());
	case 2:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Task> v = _obj.get_recentTask();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void UserDirectory_closure::browse(pf_update update, void* context) const
{
	update("Begin", "UserDirectory", context);
	update_member(update, "domainList", "xsd:string[]", a2s_basic(_obj.get_domainList()), context);
	update("End", std::string(), context);
}

closure* UserDirectory_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void View_closure::browse(pf_update update, void* context) const
{
	update("Begin", "View", context);
	update("End", std::string(), context);
}

closure* View_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void ViewManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "ViewManager", context);
	update_member(update, "viewList", "View[]", a2s_object(_obj.get_viewList()), context);
	update("End", std::string(), context);
}

closure* ViewManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<View> v = _obj.get_viewList();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	default:
		return 0;
	}
	return 0;
}

void VirtualApp_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualApp", context);
	update_member_with_version(update, "childLink", "VirtualAppLinkInfo[]", a2s_object(_obj.get_childLink()), context, "4.1");
	update_member(update, "datastore", "Datastore[]", a2s_object(_obj.get_datastore()), context);
	update_member(update, "network", "Network[]", a2s_object(_obj.get_network()), context);
	update_member(update, "parentFolder", "Folder", handle_obj(_obj.get_parentFolder()), context);
	update_member_with_version(update, "parentVApp", "ManagedEntity", handle_obj(_obj.get_parentVApp()), context, "4.1");
	update_member(update, "vAppConfig", "VAppConfigInfo", handle_obj(_obj.get_vAppConfig()), context);
	update("Base", "ResourcePool", context);
	ResourcePool_closure(dynamic_cast<const ResourcePool&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualApp_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<vw1__VirtualAppLinkInfo> v = _obj.get_childLink();
			if (i < v.size())
				return new VirtualAppLinkInfo_closure(v[i]);
			else
				return 0;
		}
	case 1:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Datastore> v = _obj.get_datastore();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 2:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Network> v = _obj.get_network();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 3:
		return new Folder_closure(_obj.get_parentFolder());
	case 4:
		return new ManagedEntity_closure(_obj.get_parentVApp());
	case 5:
		return new VAppConfigInfo_closure(_obj.get_vAppConfig());
	default:
		int arr_index = index & 0xFFFF;
		return ResourcePool_closure(_obj).get_sub_closure(((prop_index - 6) << 16) + arr_index);
	}
	return 0;
}

void VirtualDiskManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualDiskManager", context);
	update("End", std::string(), context);
}

closure* VirtualDiskManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void VirtualMachine_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachine", context);
	update_member(update, "capability", "VirtualMachineCapability", handle_obj(_obj.get_capability()), context);
	update_member(update, "config", "VirtualMachineConfigInfo", handle_obj(_obj.get_config()), context);
	update_member(update, "datastore", "Datastore[]", a2s_object(_obj.get_datastore()), context);
	update_member(update, "environmentBrowser", "EnvironmentBrowser", handle_obj(_obj.get_environmentBrowser()), context);
	update_member(update, "guest", "GuestInfo", handle_obj(_obj.get_guest()), context);
	update_member(update, "guestHeartbeatStatus", "ManagedEntityStatus", handle_obj(_obj.get_guestHeartbeatStatus()), context);
	update_member(update, "layout", "VirtualMachineFileLayout", handle_obj(_obj.get_layout()), context);
	update_member_with_version(update, "layoutEx", "VirtualMachineFileLayoutEx", handle_obj(_obj.get_layoutEx()), context, "4.0");
	update_member(update, "network", "Network[]", a2s_object(_obj.get_network()), context);
	update_member_with_version(update, "parentVApp", "ManagedEntity", handle_obj(_obj.get_parentVApp()), context, "4.1");
	update_member(update, "resourceConfig", "ResourceConfigSpec", handle_obj(_obj.get_resourceConfig()), context);
	update_member(update, "resourcePool", "ResourcePool", handle_obj(_obj.get_resourcePool()), context);
	update_member_with_version(update, "rootSnapshot", "VirtualMachineSnapshot[]", a2s_object(_obj.get_rootSnapshot()), context, "4.1");
	update_member(update, "runtime", "VirtualMachineRuntimeInfo", handle_obj(_obj.get_runtime()), context);
	update_member(update, "snapshot", "VirtualMachineSnapshotInfo", handle_obj(_obj.get_snapshot()), context);
	update_member_with_version(update, "storage", "VirtualMachineStorageInfo", handle_obj(_obj.get_storage()), context, "4.0");
	update_member(update, "summary", "VirtualMachineSummary", handle_obj(_obj.get_summary()), context);
	update("Base", "ManagedEntity", context);
	ManagedEntity_closure(dynamic_cast<const ManagedEntity&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachine_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		return new VirtualMachineCapability_closure(_obj.get_capability());
	case 1:
		return new VirtualMachineConfigInfo_closure(_obj.get_config());
	case 2:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Datastore> v = _obj.get_datastore();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 3:
		return new EnvironmentBrowser_closure(_obj.get_environmentBrowser());
	case 4:
		return new GuestInfo_closure(_obj.get_guest());
	case 6:
		return new VirtualMachineFileLayout_closure(_obj.get_layout());
	case 7:
		return new VirtualMachineFileLayoutEx_closure(_obj.get_layoutEx());
	case 8:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<Network> v = _obj.get_network();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 9:
		return new ManagedEntity_closure(_obj.get_parentVApp());
	case 10:
		return new ResourceConfigSpec_closure(_obj.get_resourceConfig());
	case 11:
		return new ResourcePool_closure(_obj.get_resourcePool());
	case 12:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<VirtualMachineSnapshot> v = _obj.get_rootSnapshot();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 13:
		return new VirtualMachineRuntimeInfo_closure(_obj.get_runtime());
	case 14:
		return new VirtualMachineSnapshotInfo_closure(_obj.get_snapshot());
	case 15:
		return new VirtualMachineStorageInfo_closure(_obj.get_storage());
	case 16:
		return new VirtualMachineSummary_closure(_obj.get_summary());
	default:
		int arr_index = index & 0xFFFF;
		return ManagedEntity_closure(_obj).get_sub_closure(((prop_index - 17) << 16) + arr_index);
	}
	return 0;
}

void VirtualMachineCompatibilityChecker_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineCompatibilityChecker", context);
	update("End", std::string(), context);
}

closure* VirtualMachineCompatibilityChecker_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void VirtualMachineProvisioningChecker_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineProvisioningChecker", context);
	update("End", std::string(), context);
}

closure* VirtualMachineProvisioningChecker_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void VirtualMachineSnapshot_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualMachineSnapshot", context);
	update_member_with_version(update, "childSnapshot", "VirtualMachineSnapshot[]", a2s_object(_obj.get_childSnapshot()), context, "4.1");
	update_member(update, "config", "VirtualMachineConfigInfo", handle_obj(_obj.get_config()), context);
	update("Base", "ExtensibleManagedObject", context);
	ExtensibleManagedObject_closure(dynamic_cast<const ExtensibleManagedObject&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VirtualMachineSnapshot_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	int prop_index = index >> 16;
	switch (prop_index - 1)	// property is 1 based!
	{
	case 0:
		{
			int arr_index = index & 0xFFFF;
			size_t i = --arr_index;	// array index is 1 based also
			std::vector<VirtualMachineSnapshot> v = _obj.get_childSnapshot();
			if (i < v.size())
				return get_closure_from_mor(v[i]);
			else
				return 0;
		}
	case 1:
		return new VirtualMachineConfigInfo_closure(_obj.get_config());
	default:
		int arr_index = index & 0xFFFF;
		return ExtensibleManagedObject_closure(_obj).get_sub_closure(((prop_index - 2) << 16) + arr_index);
	}
	return 0;
}

void VirtualizationManager_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VirtualizationManager", context);
	update("End", std::string(), context);
}

closure* VirtualizationManager_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

void VmwareDistributedVirtualSwitch_closure::browse(pf_update update, void* context) const
{
	update("Begin", "VmwareDistributedVirtualSwitch", context);
	update("Base", "DistributedVirtualSwitch", context);
	DistributedVirtualSwitch_closure(dynamic_cast<const DistributedVirtualSwitch&>(_obj)).browse(update, context);
	update("End", std::string(), context);
}

closure* VmwareDistributedVirtualSwitch_closure::get_sub_closure(size_t index) const
{
	if (!_obj)
		return 0;

	return 0;
}

closure* get_closure_from_mor(vw1__ManagedObjectReference* mor)
{
	if (0)
		;
	else if (strcmp(mor->type, "Alarm") == 0)
		return new Alarm_closure(Alarm(mor));
	else if (strcmp(mor->type, "AlarmManager") == 0)
		return new AlarmManager_closure(AlarmManager(mor));
	else if (strcmp(mor->type, "AuthorizationManager") == 0)
		return new AuthorizationManager_closure(AuthorizationManager(mor));
	else if (strcmp(mor->type, "ClusterComputeResource") == 0)
		return new ClusterComputeResource_closure(ClusterComputeResource(mor));
	else if (strcmp(mor->type, "ClusterProfile") == 0)
		return new ClusterProfile_closure(ClusterProfile(mor));
	else if (strcmp(mor->type, "ClusterProfileManager") == 0)
		return new ClusterProfileManager_closure(ClusterProfileManager(mor));
	else if (strcmp(mor->type, "ComputeResource") == 0)
		return new ComputeResource_closure(ComputeResource(mor));
	else if (strcmp(mor->type, "ContainerView") == 0)
		return new ContainerView_closure(ContainerView(mor));
	else if (strcmp(mor->type, "CustomFieldsManager") == 0)
		return new CustomFieldsManager_closure(CustomFieldsManager(mor));
	else if (strcmp(mor->type, "CustomizationSpecManager") == 0)
		return new CustomizationSpecManager_closure(CustomizationSpecManager(mor));
	else if (strcmp(mor->type, "Datacenter") == 0)
		return new Datacenter_closure(Datacenter(mor));
	else if (strcmp(mor->type, "Datastore") == 0)
		return new Datastore_closure(Datastore(mor));
	else if (strcmp(mor->type, "DiagnosticManager") == 0)
		return new DiagnosticManager_closure(DiagnosticManager(mor));
	else if (strcmp(mor->type, "DistributedVirtualPortgroup") == 0)
		return new DistributedVirtualPortgroup_closure(DistributedVirtualPortgroup(mor));
	else if (strcmp(mor->type, "DistributedVirtualSwitch") == 0)
		return new DistributedVirtualSwitch_closure(DistributedVirtualSwitch(mor));
	else if (strcmp(mor->type, "DistributedVirtualSwitchManager") == 0)
		return new DistributedVirtualSwitchManager_closure(DistributedVirtualSwitchManager(mor));
	else if (strcmp(mor->type, "EnvironmentBrowser") == 0)
		return new EnvironmentBrowser_closure(EnvironmentBrowser(mor));
	else if (strcmp(mor->type, "EventHistoryCollector") == 0)
		return new EventHistoryCollector_closure(EventHistoryCollector(mor));
	else if (strcmp(mor->type, "EventManager") == 0)
		return new EventManager_closure(EventManager(mor));
	else if (strcmp(mor->type, "ExtensibleManagedObject") == 0)
		return new ExtensibleManagedObject_closure(ExtensibleManagedObject(mor));
	else if (strcmp(mor->type, "ExtensionManager") == 0)
		return new ExtensionManager_closure(ExtensionManager(mor));
	else if (strcmp(mor->type, "FileManager") == 0)
		return new FileManager_closure(FileManager(mor));
	else if (strcmp(mor->type, "Folder") == 0)
		return new Folder_closure(Folder(mor));
	else if (strcmp(mor->type, "GuestAuthManager") == 0)
		return new GuestAuthManager_closure(GuestAuthManager(mor));
	else if (strcmp(mor->type, "GuestFileManager") == 0)
		return new GuestFileManager_closure(GuestFileManager(mor));
	else if (strcmp(mor->type, "GuestOperationsManager") == 0)
		return new GuestOperationsManager_closure(GuestOperationsManager(mor));
	else if (strcmp(mor->type, "GuestProcessManager") == 0)
		return new GuestProcessManager_closure(GuestProcessManager(mor));
	else if (strcmp(mor->type, "HistoryCollector") == 0)
		return new HistoryCollector_closure(HistoryCollector(mor));
	else if (strcmp(mor->type, "HostActiveDirectoryAuthentication") == 0)
		return new HostActiveDirectoryAuthentication_closure(HostActiveDirectoryAuthentication(mor));
	else if (strcmp(mor->type, "HostAuthenticationManager") == 0)
		return new HostAuthenticationManager_closure(HostAuthenticationManager(mor));
	else if (strcmp(mor->type, "HostAuthenticationStore") == 0)
		return new HostAuthenticationStore_closure(HostAuthenticationStore(mor));
	else if (strcmp(mor->type, "HostAutoStartManager") == 0)
		return new HostAutoStartManager_closure(HostAutoStartManager(mor));
	else if (strcmp(mor->type, "HostBootDeviceSystem") == 0)
		return new HostBootDeviceSystem_closure(HostBootDeviceSystem(mor));
	else if (strcmp(mor->type, "HostCacheConfigurationManager") == 0)
		return new HostCacheConfigurationManager_closure(HostCacheConfigurationManager(mor));
	else if (strcmp(mor->type, "HostCpuSchedulerSystem") == 0)
		return new HostCpuSchedulerSystem_closure(HostCpuSchedulerSystem(mor));
	else if (strcmp(mor->type, "HostDatastoreBrowser") == 0)
		return new HostDatastoreBrowser_closure(HostDatastoreBrowser(mor));
	else if (strcmp(mor->type, "HostDatastoreSystem") == 0)
		return new HostDatastoreSystem_closure(HostDatastoreSystem(mor));
	else if (strcmp(mor->type, "HostDateTimeSystem") == 0)
		return new HostDateTimeSystem_closure(HostDateTimeSystem(mor));
	else if (strcmp(mor->type, "HostDiagnosticSystem") == 0)
		return new HostDiagnosticSystem_closure(HostDiagnosticSystem(mor));
	else if (strcmp(mor->type, "HostDirectoryStore") == 0)
		return new HostDirectoryStore_closure(HostDirectoryStore(mor));
	else if (strcmp(mor->type, "HostEsxAgentHostManager") == 0)
		return new HostEsxAgentHostManager_closure(HostEsxAgentHostManager(mor));
	else if (strcmp(mor->type, "HostFirewallSystem") == 0)
		return new HostFirewallSystem_closure(HostFirewallSystem(mor));
	else if (strcmp(mor->type, "HostFirmwareSystem") == 0)
		return new HostFirmwareSystem_closure(HostFirmwareSystem(mor));
	else if (strcmp(mor->type, "HostHealthStatusSystem") == 0)
		return new HostHealthStatusSystem_closure(HostHealthStatusSystem(mor));
	else if (strcmp(mor->type, "HostImageConfigManager") == 0)
		return new HostImageConfigManager_closure(HostImageConfigManager(mor));
	else if (strcmp(mor->type, "HostKernelModuleSystem") == 0)
		return new HostKernelModuleSystem_closure(HostKernelModuleSystem(mor));
	else if (strcmp(mor->type, "HostLocalAccountManager") == 0)
		return new HostLocalAccountManager_closure(HostLocalAccountManager(mor));
	else if (strcmp(mor->type, "HostLocalAuthentication") == 0)
		return new HostLocalAuthentication_closure(HostLocalAuthentication(mor));
	else if (strcmp(mor->type, "HostMemorySystem") == 0)
		return new HostMemorySystem_closure(HostMemorySystem(mor));
	else if (strcmp(mor->type, "HostNetworkSystem") == 0)
		return new HostNetworkSystem_closure(HostNetworkSystem(mor));
	else if (strcmp(mor->type, "HostPatchManager") == 0)
		return new HostPatchManager_closure(HostPatchManager(mor));
	else if (strcmp(mor->type, "HostPciPassthruSystem") == 0)
		return new HostPciPassthruSystem_closure(HostPciPassthruSystem(mor));
	else if (strcmp(mor->type, "HostPowerSystem") == 0)
		return new HostPowerSystem_closure(HostPowerSystem(mor));
	else if (strcmp(mor->type, "HostProfile") == 0)
		return new HostProfile_closure(HostProfile(mor));
	else if (strcmp(mor->type, "HostProfileManager") == 0)
		return new HostProfileManager_closure(HostProfileManager(mor));
	else if (strcmp(mor->type, "HostServiceSystem") == 0)
		return new HostServiceSystem_closure(HostServiceSystem(mor));
	else if (strcmp(mor->type, "HostSnmpSystem") == 0)
		return new HostSnmpSystem_closure(HostSnmpSystem(mor));
	else if (strcmp(mor->type, "HostStorageSystem") == 0)
		return new HostStorageSystem_closure(HostStorageSystem(mor));
	else if (strcmp(mor->type, "HostSystem") == 0)
		return new HostSystem_closure(HostSystem(mor));
	else if (strcmp(mor->type, "HostVMotionSystem") == 0)
		return new HostVMotionSystem_closure(HostVMotionSystem(mor));
	else if (strcmp(mor->type, "HostVirtualNicManager") == 0)
		return new HostVirtualNicManager_closure(HostVirtualNicManager(mor));
	else if (strcmp(mor->type, "HttpNfcLease") == 0)
		return new HttpNfcLease_closure(HttpNfcLease(mor));
	else if (strcmp(mor->type, "InventoryView") == 0)
		return new InventoryView_closure(InventoryView(mor));
	else if (strcmp(mor->type, "IpPoolManager") == 0)
		return new IpPoolManager_closure(IpPoolManager(mor));
	else if (strcmp(mor->type, "IscsiManager") == 0)
		return new IscsiManager_closure(IscsiManager(mor));
	else if (strcmp(mor->type, "LicenseAssignmentManager") == 0)
		return new LicenseAssignmentManager_closure(LicenseAssignmentManager(mor));
	else if (strcmp(mor->type, "LicenseManager") == 0)
		return new LicenseManager_closure(LicenseManager(mor));
	else if (strcmp(mor->type, "ListView") == 0)
		return new ListView_closure(ListView(mor));
	else if (strcmp(mor->type, "LocalizationManager") == 0)
		return new LocalizationManager_closure(LocalizationManager(mor));
	else if (strcmp(mor->type, "ManagedEntity") == 0)
		return new ManagedEntity_closure(ManagedEntity(mor));
	else if (strcmp(mor->type, "ManagedObjectView") == 0)
		return new ManagedObjectView_closure(ManagedObjectView(mor));
	else if (strcmp(mor->type, "Network") == 0)
		return new Network_closure(Network(mor));
	else if (strcmp(mor->type, "OptionManager") == 0)
		return new OptionManager_closure(OptionManager(mor));
	else if (strcmp(mor->type, "OvfManager") == 0)
		return new OvfManager_closure(OvfManager(mor));
	else if (strcmp(mor->type, "PerformanceManager") == 0)
		return new PerformanceManager_closure(PerformanceManager(mor));
	else if (strcmp(mor->type, "Profile") == 0)
		return new Profile_closure(Profile(mor));
	else if (strcmp(mor->type, "ProfileComplianceManager") == 0)
		return new ProfileComplianceManager_closure(ProfileComplianceManager(mor));
	else if (strcmp(mor->type, "ProfileManager") == 0)
		return new ProfileManager_closure(ProfileManager(mor));
	else if (strcmp(mor->type, "PropertyCollector") == 0)
		return new PropertyCollector_closure(PropertyCollector(mor));
	else if (strcmp(mor->type, "PropertyFilter") == 0)
		return new PropertyFilter_closure(PropertyFilter(mor));
	else if (strcmp(mor->type, "ResourcePlanningManager") == 0)
		return new ResourcePlanningManager_closure(ResourcePlanningManager(mor));
	else if (strcmp(mor->type, "ResourcePool") == 0)
		return new ResourcePool_closure(ResourcePool(mor));
	else if (strcmp(mor->type, "ScheduledTask") == 0)
		return new ScheduledTask_closure(ScheduledTask(mor));
	else if (strcmp(mor->type, "ScheduledTaskManager") == 0)
		return new ScheduledTaskManager_closure(ScheduledTaskManager(mor));
	else if (strcmp(mor->type, "SearchIndex") == 0)
		return new SearchIndex_closure(SearchIndex(mor));
	else if (strcmp(mor->type, "ServiceInstance") == 0)
		return new ServiceInstance_closure(ServiceInstance(mor));
	else if (strcmp(mor->type, "SessionManager") == 0)
		return new SessionManager_closure(SessionManager(mor));
	else if (strcmp(mor->type, "StoragePod") == 0)
		return new StoragePod_closure(StoragePod(mor));
	else if (strcmp(mor->type, "StorageResourceManager") == 0)
		return new StorageResourceManager_closure(StorageResourceManager(mor));
	else if (strcmp(mor->type, "Task") == 0)
		return new Task_closure(Task(mor));
	else if (strcmp(mor->type, "TaskHistoryCollector") == 0)
		return new TaskHistoryCollector_closure(TaskHistoryCollector(mor));
	else if (strcmp(mor->type, "TaskManager") == 0)
		return new TaskManager_closure(TaskManager(mor));
	else if (strcmp(mor->type, "UserDirectory") == 0)
		return new UserDirectory_closure(UserDirectory(mor));
	else if (strcmp(mor->type, "View") == 0)
		return new View_closure(View(mor));
	else if (strcmp(mor->type, "ViewManager") == 0)
		return new ViewManager_closure(ViewManager(mor));
	else if (strcmp(mor->type, "VirtualApp") == 0)
		return new VirtualApp_closure(VirtualApp(mor));
	else if (strcmp(mor->type, "VirtualDiskManager") == 0)
		return new VirtualDiskManager_closure(VirtualDiskManager(mor));
	else if (strcmp(mor->type, "VirtualMachine") == 0)
		return new VirtualMachine_closure(VirtualMachine(mor));
	else if (strcmp(mor->type, "VirtualMachineCompatibilityChecker") == 0)
		return new VirtualMachineCompatibilityChecker_closure(VirtualMachineCompatibilityChecker(mor));
	else if (strcmp(mor->type, "VirtualMachineProvisioningChecker") == 0)
		return new VirtualMachineProvisioningChecker_closure(VirtualMachineProvisioningChecker(mor));
	else if (strcmp(mor->type, "VirtualMachineSnapshot") == 0)
		return new VirtualMachineSnapshot_closure(VirtualMachineSnapshot(mor));
	else if (strcmp(mor->type, "VirtualizationManager") == 0)
		return new VirtualizationManager_closure(VirtualizationManager(mor));
	else if (strcmp(mor->type, "VmwareDistributedVirtualSwitch") == 0)
		return new VmwareDistributedVirtualSwitch_closure(VmwareDistributedVirtualSwitch(mor));
	else
		return 0;
}
} // namespace vim_browser
